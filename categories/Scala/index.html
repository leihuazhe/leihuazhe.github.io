<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>分类: Scala - 非普通程序员</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非普通程序员"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非普通程序员"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="非普通程序员的技术博客，以源码分析和连载为主"><meta property="og:type" content="blog"><meta property="og:title" content="非普通程序员"><meta property="og:url" content="http://leihuazhe.github.io/"><meta property="og:site_name" content="非普通程序员"><meta property="og:description" content="非普通程序员的技术博客，以源码分析和连载为主"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://leihuazhe.github.io/img/og_image.png"><meta property="article:author" content="Zane Ray"><meta property="article:tag" content="Java, Scala, Spring, Dubbo, MQ, Middleware"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://leihuazhe.github.io"},"headline":"非普通程序员","image":["http://leihuazhe.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Zane Ray"},"description":"非普通程序员的技术博客，以源码分析和连载为主"}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a><a class="navbar-item" href="/tools">工具</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">Scala</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/p/ac45747d.html"><img class="fill" src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/ac45747d.html"><i class="fa fa-bolt" aria-hidden="true"></i> Spring 学习 [1]</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-05-07</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-07</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">几秒读完 (大约7个字)</span></div></div><div class="content"><p>图片测试</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/spring/">spring</a></div><a class="article-more button is-small is-size-7" href="/p/ac45747d.html#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/p/a8949b93.html"><img class="fill" src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/a8949b93.html"><i class="fa fa-bolt" aria-hidden="true"></i> Scala实战 -- 对List中的部分元素进行合并操作</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2019-04-01</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">5 分钟读完 (大约737个字)</span></div></div><div class="content"><blockquote><p>近期业务出现了一个需求，需要对一个相同实体的List中，部分实体名和id相同的元素进行合并，将其合并为一个实体，以便在业务上做统计处理，合并后的实体为合并前的实体的某些数值相加。<br>此需求催生了本篇文章。我们将抽象一个简单的实体来介绍，<strong>如何在Scala List 中合并部分Element 元素。</strong></p></blockquote></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div><a class="article-more button is-small is-size-7" href="/p/a8949b93.html#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/2ed76eda.html"><i class="fa fa-bolt" aria-hidden="true"></i> 从示例逐渐理解Scala隐式转换</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-11-18</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">16 分钟读完 (大约2379个字)</span></div></div><div class="content"><blockquote><p>隐式转换和隐式参数是 <code>Scala</code> 的两个功能强大的工具。隐式转换可以丰富现有类的功能，隐式对象是如何被自动呼出以用于执行转换或其他任务的。利用这两点，我们可以提供优雅的类库。</p></blockquote><p>本文将通过几个示例代码来整体学习一下 <code>Scala</code> 隐式转换的四个特性和运用。它们分别是 隐式函数运用、隐式类扩展运用、隐式参数、类型类(<code>Type class</code>)运用。</p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><blockquote><p>implicit conversion function：指的是那种以 <code>implicit</code> 关键字声明的带有单个参数的函数。这样的函数将被自动应用，将值从一种类型转换为另一种类型。</p></blockquote><h3 id="隐式函数-implicit-def"><a href="#隐式函数-implicit-def" class="headerlink" title="隐式函数 implicit def"></a>隐式函数 implicit def</h3><p>定义一个 <code>case class</code> 类 <code>Multiply</code>，并定义一个方法 <code>multiply</code> ，接收一个当前对象，并将值相乘后返回。<br>定义隐式转换函数 <code>int2Multiply</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span>(<span class="params">m: <span class="type">Int</span>, n: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(other: <span class="type">Multiply</span>): <span class="type">Multiply</span> = &#123;</span><br><span class="line">        <span class="type">Multiply</span>(other.m * m, other.n * n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyImplicit</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义隐式转换函数，参数单个，将 int 隐式转换为 Multiply 对象</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类 <code>MultiplyMain</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//导入隐式转换方法（局部引用可以避免不想要的隐式转换发生）</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> x: <span class="type">Multiply</span> = <span class="number">3.</span>multiply(<span class="type">Multiply</span>(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(x.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行程序结果如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结果为：Multiply(6,2)</span><br><span class="line">&#x2F;&#x2F;计算过程，3 隐式转换为 Multiply(3, 2)</span><br><span class="line">3 &#x3D;&gt; Multiply(3, 2)</span><br><span class="line">&#x2F;&#x2F;调用multiply计算</span><br><span class="line">Multiply(3, 2).multiply(Multiply(2, 1)) &#x3D;Multiply( 3*2 , 2*1 )</span><br></pre></td></tr></table></figure>如果我们提供多个隐式转换函数<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyImplicit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">2</span>)</span><br><span class="line">  <span class="comment">//提供第二个隐式转换函数</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply2</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在 <code>Main</code> 中，我们可以通过两种方式进行指定具体使用哪个隐式转换函数。<br>比如我们选择使用 <code>int2Multiply</code>的隐式转换<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//方法1: 排除 int2Multiply2 方法，引入其余所有的方法</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>.&#123;int2Multiply2 ⇒ _, _&#125;</span><br><span class="line"> <span class="comment">// 方法2: 精确引入</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>.int2Multiply</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> x: <span class="type">Multiply</span> = <span class="number">3.</span>multiply(<span class="type">Multiply</span>(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(x.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式类，丰富现有类库功能"><a href="#隐式类，丰富现有类库功能" class="headerlink" title="隐式类，丰富现有类库功能"></a>隐式类，丰富现有类库功能</h3><blockquote><p>你是否希望某个类拥有新的方法，而此方法该类并没有提供，那么隐式转换可以丰富这个类，给它提供更多的方法</p></blockquote></li></ul><p>例如数据库连接类 <code>Connection</code>, 我们希望给它新增一个 <code>executeUpdate</code> 方法来对数据进行修改，例子如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.maple.implic.two</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.<span class="type">Connection</span></span><br><span class="line"><span class="keyword">import</span> scala.language.implicitConversions</span><br><span class="line"><span class="comment">//隐式类，Rich表示对Connection的增强类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichConnection</span>(<span class="params">conn: <span class="type">Connection</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//定义的新方法 executeUpdate，对数据操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">executeUpdate</span></span>(sql: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    conn.prepareStatement(sql).executeUpdate()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供隐式转换 func 来将原有类型转换为Rich 类型</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichConnection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">executeUpdate</span></span>(connection: <span class="type">Connection</span>) = <span class="keyword">new</span> <span class="type">RichConnection</span>(connection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConnectionMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引入隐式转换 func</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.two.<span class="type">RichConnection</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//定义 dataSource</span></span><br><span class="line">    <span class="keyword">val</span> ds: <span class="type">DataSource</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> ds = <span class="keyword">new</span> <span class="type">MysqlDataSource</span></span><br><span class="line">      ds.setURL(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/maple?useUnicode=true&amp;characterEncoding=utf8&quot;</span>)</span><br><span class="line">      ds.setUser(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">      ds.setPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">      ds</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取 conn</span></span><br><span class="line">    <span class="keyword">val</span> connection = ds.getConnection</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    connection.executeUpdate(<span class="string">&quot;UPDATE t_user SET name = &#x27;maple&#x27; WHERE id = 1&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面通过定义一个 <code>RichConnection</code> 我们可以增强现有类 <code>Connection</code> 的功能。这样一来，通过 <code>connection</code> 对数据库进行增删改查，可以简化大量代码。</p><h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><blockquote><p>函数或方法可以带有一个标记为 <code>implicit</code> 的参数列表。在这种情况下，编译器将会查找默认值，提供给本次函数调用。</p></blockquote><h3 id="利用隐式参数进行隐式转换"><a href="#利用隐式参数进行隐式转换" class="headerlink" title="利用隐式参数进行隐式转换"></a>利用隐式参数进行隐式转换</h3><blockquote><p>隐式的函数参数也可以被用作隐式转换。如果我们定义一个泛型函数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">larger</span></span>[<span class="type">T</span>](x: <span class="type">T</span>, y: <span class="type">T</span>) = <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><h2><a href="#" class="headerlink"></a><img src="https://upload-images.jianshu.io/upload_images/6393906-98ae4bd56e64e4de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="ex.png"></h2><p>关于隐式参数的另一件事是，它们可能最常用于提供有关在早期参数列表中显式提到的类型的信息，类似于Haskell的类型类。作为示例，请考虑清单21.2中所示的maxListUpBound函数，该函数返回传递列表的最大元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxListUpBound</span></span>[<span class="type">T</span> &lt;: <span class="type">Ordered</span>[<span class="type">T</span>]](elements: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">    elements <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;empty list!&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">      <span class="keyword">case</span> x :: rest =&gt;</span><br><span class="line">        <span class="keyword">val</span> maxRest = maxListUpBound(rest)</span><br><span class="line">        <span class="keyword">if</span> (x &gt; maxRest) x</span><br><span class="line">        <span class="keyword">else</span> maxRest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>maxListUpBound</code> 表示传入一个 <code>List</code>，然后返回 <code>list</code> 中最大的一个元素。功能简单，但是用法十分限制，该List中的成员必须是 <code>Ordered[T]</code> 的子类，否则就会报错。比如我们运行如下例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParameterMain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.three.<span class="type">ImplicitParameter</span>._</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = maxListUpBound(<span class="type">List</span>[<span class="type">Integer</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    println(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们运行 <code>main</code> 函数时，编译器会报如下错。意思是 <code>Int</code> 不是 <code>Ordered[T]</code> 子类，因此无法使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error:(49, 18) inferred type arguments [Int] do not conform to method maxListUpBound&#39;s type parameter bounds [T &lt;: Ordered[T]]</span><br><span class="line">    val result &#x3D; maxListUpBound(List[Int](1, 2, 3))</span><br><span class="line">Error:(49, 42) type mismatch;</span><br><span class="line"> found   : List[Int]</span><br><span class="line"> required: List[T]</span><br><span class="line">    val result &#x3D; maxListUpBound(List[Int](1, 2, 3))</span><br></pre></td></tr></table></figure><h4 id="使用隐式参数优化"><a href="#使用隐式参数优化" class="headerlink" title="使用隐式参数优化"></a>使用隐式参数优化</h4><blockquote><p>如果让 <code>maxListUpBound</code> 更通用，我们需要分离这个函数，增加一个参数，来将 <code>T</code> 转换为 <code>Ordered[T]</code>，使用隐式参数 <code>implicit orders: T ⇒ Ordered[T]</code>来做到这一点。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxListUpBound2</span></span>[<span class="type">T</span>](elements: <span class="type">List</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> orders: <span class="type">T</span> ⇒ <span class="type">Ordered</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">    elements <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;empty list!&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">      <span class="keyword">case</span> x :: rest =&gt;</span><br><span class="line">        <span class="keyword">val</span> maxRest = maxListUpBound2(rest)</span><br><span class="line">        <span class="keyword">if</span> (x &gt; maxRest) x</span><br><span class="line">        <span class="keyword">else</span> maxRest</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.three.<span class="type">ImplicitParameter</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = maxListUpBound2(<span class="type">List</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为3，并没有报错。这其中编译器是将 <code>Int</code> 转换为了 <code>Ordered[Int]</code></p><h3 id="类型类-type-class"><a href="#类型类-type-class" class="headerlink" title="类型类(type class)"></a>类型类(type class)</h3><blockquote><p>让某个类拥有某个算法，我们无需修改这个类，提供一个隐式转换即可。这种做法相对于面向对象的继承扩展来的更灵活。</p></blockquote><p>看下面两个例子，<code>Ordering</code> 是 <code>Scala</code> 提供的类型类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Implicits</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedExt</span>[<span class="type">T</span>: <span class="type">Ordering</span>](<span class="params">v: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">between</span></span>(min: <span class="type">T</span>, max: <span class="type">T</span>) = &#123;</span><br><span class="line">        <span class="keyword">val</span> ordering = implicitly[<span class="type">Ordering</span>[<span class="type">T</span>]]</span><br><span class="line">        ordering.lteq(min, v) &amp;&amp; ordering.lteq(v, max)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedExt2</span>[<span class="type">T</span>](<span class="params">v: <span class="type">T</span></span>)(<span class="params">implicit ordering: <span class="type">Ordering</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">between2</span></span>(min: <span class="type">T</span>, max: <span class="type">T</span>) = &#123;</span><br><span class="line">      ordering.lteq(min, v) &amp;&amp; ordering.lteq(v, max)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用，上面两种写法都可以达到相同的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.<span class="type">Implicits</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> isBetween = <span class="number">10.</span>between(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> isBetween2 = <span class="number">30.</span>between2(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">    println(isBetween)</span><br><span class="line">    println(isBetween2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ordering</code> 这样的特质(<code>trait</code>) 被称为类型类(<code>type class</code>，源自 <code>Haskell</code>) 。类型类定义了某种行为，任何类型都可以通过提供相应的行为来加入这个类。这个类是因为共用的目的而组合在一起的类型。</p><h3 id="自定义类型类"><a href="#自定义类型类" class="headerlink" title="自定义类型类"></a>自定义类型类</h3><blockquote><p><code>Scala</code> 标准类库提供了不少类型类。比如 <code>Equiv</code>、<code>Numeric</code>、<code>Fractional</code>、<code>Hashing</code>、<code>IsTraverableOne</code>、<code>IsTraverableLike</code> 等。我们通过自定义一个类型 <code>CustomOperation</code> 来更深入的学习。</p></blockquote><p><strong>定义特质 <code>CustomOperation</code></strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CustomOperation</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 加操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="comment">// 乘操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在伴生对象中给 String 类型扩展基于 <code>CustomOperation</code> 的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CustomOperation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">StringCustomOperation</span> <span class="keyword">extends</span> <span class="title">CustomOperation</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + <span class="string">&quot;*&quot;</span> + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义隐式类,对 `String` 进行增强</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomImplicitClass</span>[<span class="type">T</span>: <span class="type">CustomOperation</span>](<span class="params">v: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">      <span class="comment">//从冥界召唤的CustomOperation[T]隐式类型。</span></span><br><span class="line">      <span class="keyword">val</span> custom = implicitly[<span class="type">CustomOperation</span>[<span class="type">T</span>]]</span><br><span class="line">      custom.multiply(v, x) + <span class="string">&quot;+&quot;</span> + custom.multiply(v, y).toString</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//另外一种写法</span></span><br><span class="line">  <span class="comment">/* def multiply(x: T, y: T)(implicit custom: CustomOperation[T]): String = &#123;</span></span><br><span class="line"><span class="comment">      custom.multiply(v, x) + custom.multiply(v, y).toString</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">String</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> custom = implicitly[<span class="type">CustomOperation</span>[<span class="type">T</span>]]</span><br><span class="line">      custom.plus(v, x) + custom.plus(v, y).toString</span><br><span class="line">      <span class="comment">//      custom.plus(x, y)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类 <code>CustomOperationMain</code>:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.typeclass.<span class="type">CustomOperation</span>._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CustomOperationMain</span> </span>&#123;</span><br><span class="line"> <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">&quot;maple&quot;</span>.plus(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    println(str)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maple&lt;maple&gt;</span><br><span class="line"><span class="comment">//隐式转换的运算过程为</span></span><br><span class="line"> custom.plus(v, x) + custom.plus(v, y).toString</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + y</span><br></pre></td></tr></table></figure><p>如果想要对 <code>Double</code> 支持上述操作，同样定义如下类型类扩展即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">DoubleCustomOperation</span> <span class="keyword">extends</span> <span class="title">CustomOperation</span>[<span class="type">Double</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>): <span class="type">Double</span> = x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>): <span class="type">Double</span> = x * y</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.typeclass.<span class="type">CustomOperation</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> doubleValue = <span class="number">5.5</span>.multiply(<span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    println(doubleValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为 <code>11.0+16.5</code><br>计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">custom.multiply(v, x) + &quot;+&quot; + custom.multiply(v, y).toString</span><br><span class="line">override def multiply(x: Double, y: Double): Double &#x3D; x * y</span><br><span class="line">&#x2F;&#x2F;相乘后字符串相加</span><br><span class="line">5.5*2.0 + 5.5*3.0 &#x3D;&#x3D;&#x3D;&gt;  11.0+16.5</span><br></pre></td></tr></table></figure><h3 id="Type-Class-总结"><a href="#Type-Class-总结" class="headerlink" title="Type Class 总结"></a>Type Class 总结</h3><p><code>TypeClass</code> 将 <strong>行为定义</strong> 与 <strong>具有行为的对象</strong> 分离。有点类似于 <code>AOP</code>，但是比 <code>AOP</code> 简洁很多。同时, 在函数式编程中，通常将 <strong>数据</strong> 与 <strong>行为</strong> 相分离，甚至是数据与行为按需绑定，已达到更为高级的组合特性。</p><h3 id="隐式转换触发时机"><a href="#隐式转换触发时机" class="headerlink" title="隐式转换触发时机"></a>隐式转换触发时机</h3><p><code>Scala</code> 会考虑如下的隐式转换函数：</p><ul><li>1.位于源或目标类型的伴生对象中的隐式函数或隐式类。</li><li>2.位于当前作用域中可以以单个标识符指代的隐式函数或隐式类。<br>隐式转换可以显示加上，来进行代码调试。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍 <code>Scala</code> 隐式转换的几种用法，通过详细的例子加深读者对隐式转换的理解。关于隐式转换的触发时机以及编译器优化顺序等，将不在本篇文章详细介绍，可以关注笔者后续文章。</p><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>最后推荐一下本人微信公众号，欢迎大家关注。</p><p><img src="https://upload-images.jianshu.io/upload_images/6393906-47e180d949563b81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/b2d7d4cd.html"><i class="fa fa-bolt" aria-hidden="true"></i> 从示例逐渐理解Scala尾递归</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-11-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">21 分钟读完 (大约3165个字)</span></div></div><div class="content"><h3 id="1-递归与尾递归"><a href="#1-递归与尾递归" class="headerlink" title="1.递归与尾递归"></a>1.递归与尾递归</h3><h4 id="1-1-递归"><a href="#1-1-递归" class="headerlink" title="1.1 递归"></a>1.1 递归</h4><h5 id="1-1-1-递归定义"><a href="#1-1-1-递归定义" class="headerlink" title="1.1.1 递归定义"></a>1.1.1 递归定义</h5><blockquote><p>递归大家都不陌生，一个函数直接或间接的调用它自己本身，就是递归。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以执行多次重复的计算。</p></blockquote><h5 id="1-1-2-递归的条件"><a href="#1-1-2-递归的条件" class="headerlink" title="1.1.2 递归的条件"></a>1.1.2 递归的条件</h5><p>一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p><p>以递归方式实现阶乘函数的实现：</p><p>代码清单1-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">factorial</span><span class="params">(n:Int)</span>: Long </span>=&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> n * factorial(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单中，<code>if(n &lt;= 0) 1</code>是递归返回段，<code>else</code>后面部分是递归前进段。</p><h5 id="1-1-3-递归的缺点："><a href="#1-1-3-递归的缺点：" class="headerlink" title="1.1.3 递归的缺点："></a>1.1.3 递归的缺点：</h5><ul><li>需要保持调用堆栈,如代码清单1-1,每一次递归都要保存<code>n*factorial(n-1)</code>栈帧信息。如果调用次数太多，可能会导致栈溢出</li><li>效率会比较低，递归就是不断的调用自己本身，如果方法本身比较复杂，每次调用自己效率会较低。</li></ul><h4 id="1-2-尾递归"><a href="#1-2-尾递归" class="headerlink" title="1.2 尾递归"></a>1.2 尾递归</h4><h5 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h5><p>尾递归的定义比较简单，即<strong>函数在函数体最后调用它本身，就被称为尾递归</strong>。</p><p>我们可以这样理解尾递归</p><ul><li>所有递归形式的调用都出现在函数的末尾</li><li>递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分</li></ul><h5 id="1-2-2-例子程序"><a href="#1-2-2-例子程序" class="headerlink" title="1.2.2 例子程序"></a>1.2.2 例子程序</h5><p>下面我们使用尾递归的模式实现上面的阶乘<br><br>代码清单1-2</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n:<span class="type">Int</span>):<span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(main:<span class="type">Int</span>,aggr:<span class="type">Int</span>): <span class="type">Long</span> =&#123;</span><br><span class="line">        <span class="keyword">if</span>(main &lt;= <span class="number">0</span>) aggr</span><br><span class="line">        <span class="keyword">else</span> factorial(main<span class="number">-1</span>,main*aggr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   factorial(n,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以比较代码清单1-1和1-2<br>1-1中，每次的递归调用都要本身时依赖n这个变量，所以，它只能是个不同的递归。</p><p>1-2中，函数<code>factorial</code>每次返回的都是它自己本身，没有依赖任何值。它做的是将main每次减1，将aggr每次乘main，然后将这两个结果作为下一次递归调用的参数，进行调用。</p><p>尾递归的核心思想是通过参数来传递每一次的调用结果，达到不压栈。它维护着一个迭代器和一个累加器。</p><h4 id="1-3-循环"><a href="#1-3-循环" class="headerlink" title="1.3 循环"></a>1.3 循环</h4><p>循环能够解决大多数的累计问题，循环可以完成累加和迭代，处理问题比较简单，思想也比较符合，容易理解</p><p>n的阶乘循环的写法</p><p>代码清单1-3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibfor</span><span class="params">(n:Int)</span>: Int </span>=&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        m = m * i</span><br><span class="line">    &#125;</span><br><span class="line">    m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本，会有var的可变变量，我们知道，函数式编程就应该更函数范，我们尽可能的要用vals去替换可变的vars<br>所以我们可以使用递归的方式来消除掉vars</p><hr><h3 id="2-改写-循环，递归-TO-尾递归"><a href="#2-改写-循环，递归-TO-尾递归" class="headerlink" title="2.改写 (循环，递归 TO 尾递归)"></a>2.改写 (循环，递归 TO 尾递归)</h3><blockquote><p>事实上，scala都是将尾递归直接编译成循环模式的。所以我们可以大胆的说，所有的循环模式都能改写为尾递归的写法模式</p></blockquote><p>尾递归会维护一个或多个累计值(<code>aggregate</code>)参数和一个迭代参数。我们具体分析</p><h4 id="2-1迭代器和累计器"><a href="#2-1迭代器和累计器" class="headerlink" title="2.1迭代器和累计器"></a>2.1迭代器和累计器</h4><ul><li><p>累计值参数<code>aggregate</code>将每次循环产生的结果进行累计，然后传到下一次的调用中。</p></li><li><p>迭代器，和普通递归或循环一样，每次递归或循环后，改变一次。(如for(i=0;i&lt;1-;i++)里面的i)</p></li></ul><h4 id="2-2-普通递归转换为尾递归"><a href="#2-2-普通递归转换为尾递归" class="headerlink" title="2.2 普通递归转换为尾递归"></a>2.2 普通递归转换为尾递归</h4><blockquote><p>并不是所有的递归都能改写为尾递归，那些比较复杂的递归调用时无法优化为尾递归的。但是大部分还是能够进行优化的。</p></blockquote><p>代码清单1-1 和代码清单 1-2 是求n阶阶乘的普通递归与尾递归的写法，前者没有进行优化，每次调用都会压栈。<br>后者，通过定义一个<code>aggregate</code>(累计)参数，对每一次调用后的结果做一次累计,而另一个参数main称为迭代器,每一次调用都会-1，当达到符合返回的条件时，将累计值返回。</p><h4 id="2-3-循环（while-loop）转为尾递归（tail-recursion）"><a href="#2-3-循环（while-loop）转为尾递归（tail-recursion）" class="headerlink" title="2.3 循环（while loop）转为尾递归（tail recursion）"></a>2.3 循环（while loop）转为尾递归（tail recursion）</h4><blockquote><p>正如上文循环例子所述，存在<code>var</code>,函数式编程就应该有函数范，我们尽量使用<code>val</code>来代替，所以接下来来看，怎么将循环转换为尾递归</p></blockquote><h5 id="2-3-1-循环和尾递归"><a href="#2-3-1-循环和尾递归" class="headerlink" title="2.3.1 循环和尾递归"></a>2.3.1 循环和尾递归</h5><blockquote><p>正如上文所说的迭代器和累计器，循环和尾递归都有这两个概念</p></blockquote><p><strong>迭代器</strong>和<strong>累计器</strong></p><p>尾递归每一次的调用自身都会有一次累加（或者累积，累减等），然后会有一个迭代器进行迭代，一个累加器进行累加迭代的结果，然后作为参数，再去调用自身。</p><h5 id="2-3-2-如上面求n阶乘的尾递归例子："><a href="#2-3-2-如上面求n阶乘的尾递归例子：" class="headerlink" title="2.3.2 如上面求n阶乘的尾递归例子："></a>2.3.2 如上面求n阶乘的尾递归例子：</h5><ul><li><p>1.循环的例子中存在一个<code>var</code>，它在每次循环中充当一个累加器的角色，累加每一次的迭代结果，而每次迭代过程就是<code>m*i</code>的一个过程。</p></li><li><p>2.尾递归也是一样的思想，以<code>main</code>作为迭代器，每次递减<code>1</code>，类似循环里的<code>i</code>，以<code>aggr</code>作为累加器，每次累计迭代的结果，类似循环的<code>m</code>。</p></li><li><p>3.相对于普通的递归，这里尾递归多的一个参数就是累加器<code>aggr</code>，用于累计每一次递归迭代的结果。这样做的目的就是每一次调用的结果可以作为下一次函数调用的参数。</p></li></ul><h3 id="3-具体示例-加深理解"><a href="#3-具体示例-加深理解" class="headerlink" title="3.具体示例-加深理解"></a>3.具体示例-加深理解</h3><h4 id="3-1-例子1-求斐波拉契数列"><a href="#3-1-例子1-求斐波拉契数列" class="headerlink" title="3.1 例子1 - 求斐波拉契数列"></a>3.1 例子1 - 求斐波拉契数列</h4><ul><li><p>普通递归写法（性能较低）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacci</span><span class="params">(n:Int)</span>: Long </span>=&#123;</span><br><span class="line">    n match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环的写法（循环写法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacciFor</span><span class="params">(n:Int)</span>: Int </span>= &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">2</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(i &lt;- <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> aggr = current + next</span><br><span class="line">            current = next</span><br><span class="line">            next = aggr</span><br><span class="line">        &#125;   </span><br><span class="line">        next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，aggr是累加器，然后将累加的值赋值给下一个next，而current等于next，每一次循环，都有给current和next赋予新值,当累加完成后，返回next的值。</p></li><li><p>尾递归写法</p><blockquote><p>如何对其进行优化？<br><br>仔细分析,上面的普通循环，每一轮两个值都在改变，然后又一个累加器aggr，对这两个值进行累加，并赋值给更大的next，然后进入下一次循环。</p></blockquote></li></ul><p>尾递归，我们也是同样的做法，定义两个接受值，当前的，和下一个，然后需要一个累加值。</p><p>这里普通方法的递归调用是两个原函数相加，涉及到的变量有 n , n-1 , n-2<br><br>因此,我们在考虑使用尾递归时，可能也需要使用到三个参数，初略涉及，尾递归函数需要使用三个参数，于是改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacci</span><span class="params">(n: Int)</span>: Long </span>= &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function">def <span class="title">fibonacciTail</span><span class="params">(main: Int, current: Int, next: Int)</span>: Long </span>= &#123;</span><br><span class="line">      main match &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; next</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; fibonacciByTail(main - <span class="number">1</span>, next, current+next)</span><br><span class="line">      &#125;</span><br><span class="line">      fibonacciTail(n, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fibonacciTail(n,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用尾递归和模式匹配。每一次调用自身，将next赋值给current，然后累加current和next的值赋值给新的next值，call下一轮。思想上和上面循环很像。但是更函数范，消除掉了var。</p><hr><h4 id="3-2-例子2-loadBalance算法"><a href="#3-2-例子2-loadBalance算法" class="headerlink" title="3.2 例子2 - loadBalance算法"></a>3.2 例子2 - loadBalance算法</h4><blockquote><p>需求，设计一个程序，传入一个比例数组，比如Array（1,3,6,一直调用该函数，返回的3个节点的比例也应该如传入的1:3:6的比例一样。</p></blockquote><ul><li>我最开始使用<code>for循环</code>和<code>return</code>实现了这个需求，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">loadBalance</span><span class="params">(arr:Array[Int])</span>: Int </span>=&#123;</span><br><span class="line">      <span class="comment">//根据传入的数组使用scan高级函数进行变化，具体算法例子：</span></span><br><span class="line">      <span class="comment">//eg （1，3，6） -&gt;  (1,4,10)</span></span><br><span class="line">      <span class="comment">//这样的目的是，随机出来的值为0-1时，选择第一个节点，为1-4时选择第二节点，依次类推</span></span><br><span class="line">      val segment:Array[Int] = arr.scan(<span class="number">0</span>)(_ + _).drop(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//随机数的范围，根据传入的数组的数据之和来，例如上的便是 10 ，产生的随机数介于0 - 9 之间</span></span><br><span class="line">      val weightSum:Int  = arr.sum</span><br><span class="line">      val random = <span class="keyword">new</span> Random().nextInt(weightSum)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until segment.size )&#123;</span><br><span class="line">        <span class="keyword">if</span>(random &lt; segment(i))&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我通过测试程序调用1万次该方法，返回的随机节点的比例是符合传入的比例的。</li></ul><p><strong>思考</strong>：<br><br>虽然这样可以达到目的，但是代码写的既不优雅，在scala函数式编程中最好是不能使用<code>return</code>来强行打断函数执行的，并且在最后，我还需要去写一个0来作为默认返回。</p><h5 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h5><blockquote><p>大部分或者几乎所有的for循环都能使用尾递归进行优化，那上面这个代码如何进行优化呢？</p></blockquote><p><strong>思路</strong>：上文的for循环，每次增加的是<code>segment</code>的下标，每循环一次 +1，因此，我们在设计尾递归时，可以使用一个参数来实现相同的功能，而另一个参数应该就是产生的随机数。<br>ok，我们来进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">loadBalance</span><span class="params">(arr:Array[Int])</span>: Int </span>=&#123;</span><br><span class="line">      <span class="comment">//根据传入的数组使用scan高级函数进行变化，具体算法例子：</span></span><br><span class="line">      <span class="comment">//eg （1，3，6） -&gt;  (1,4,10)</span></span><br><span class="line">      <span class="comment">//这样的目的是，随机出来的值为0-1时，选择第一个节点，为1-4时选择第二节点，依次类推</span></span><br><span class="line">      val segment:Array[Int] = arr.scan(<span class="number">0</span>)(_ + _).drop(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//随机数的范围，根据传入的数组的数据之和来，例如上的便是 10 ，产生的随机数介于0 - 9 之间</span></span><br><span class="line">      val weightSum:Int  = arr.sum</span><br><span class="line">      val random = <span class="keyword">new</span> Random().nextInt(weightSum)</span><br><span class="line">      <span class="comment">//写一个内部方法</span></span><br><span class="line">      <span class="function">def <span class="title">loadUtil</span><span class="params">(rand:Int,index:Int)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert，保证程序健壮</span></span><br><span class="line">        <span class="keyword">assert</span>(index &lt; arr.length &amp;&amp; arr(index) &gt;= <span class="number">0</span>)</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(rand &lt; segment(index)) index</span><br><span class="line">        <span class="keyword">else</span> loadUtil(rand,index+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    loadUtil(random,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，使用尾递归的做法，代码会非常的优雅，现在写一个测试类进行测试！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    val arr = Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">    val countMap = collection.mutable.Map[Int,Int]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(_ &lt;- <span class="number">1</span> until <span class="number">100000</span>) &#123;</span><br><span class="line">      val res = loadBalance(arr)</span><br><span class="line"></span><br><span class="line">      countMap.get(res) match &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(x)</span> </span>=&gt; countMap += (res -&gt; (x+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">case</span> None =&gt; countMap +=(res -&gt; <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countMap.foreach(x =&gt; &#123;</span><br><span class="line">      println(s<span class="string">&quot;$&#123;x._1&#125;  调用次数 $&#123;x._2&#125;&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试10000次，返回结果如下：</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>  调用次数 <span class="number">69966</span></span><br><span class="line"><span class="number">1</span>  调用次数 <span class="number">20028</span></span><br><span class="line"><span class="number">0</span>  调用次数 <span class="number">10005</span></span><br></pre></td></tr></table></figure><p>如上，测试是通过的！是不是很优雅，感受到了尾递归的魅力？</p><hr><h3 id="4-scala编译器对尾递归的优化"><a href="#4-scala编译器对尾递归的优化" class="headerlink" title="4. scala编译器对尾递归的优化"></a>4. scala编译器对尾递归的优化</h3><p>Scala 对形式上严格的尾递归进行了优化，对于严格的尾递归，不需要注解</p><p>@tailrec 可以让编译器去检查该函数到底是不是尾递归，如果不是会报错</p><h5 id="具体以上面那个计算斐波拉契数列的例子进行性能分析"><a href="#具体以上面那个计算斐波拉契数列的例子进行性能分析" class="headerlink" title="具体以上面那个计算斐波拉契数列的例子进行性能分析"></a>具体以上面那个计算斐波拉契数列的例子进行性能分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def time[T](t: =&gt;T): T  = &#123;</span><br><span class="line">    val b = System.nanoTime()</span><br><span class="line">    val x = t</span><br><span class="line">    val e = System.nanoTime();</span><br><span class="line">    println(<span class="string">&quot;time: &quot;</span> + (e-b)/<span class="number">1000</span> + <span class="string">&quot;us&quot;</span>);</span><br><span class="line">    x</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count: Long = <span class="number">0</span></span><br><span class="line">  <span class="comment">// @tailrec</span></span><br><span class="line">  <span class="function">def <span class="title">fib2</span><span class="params">(n: Long)</span>: Long </span>= &#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    n match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        fib2(n-<span class="number">1</span>) + fib2(n-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面时间和调用次数的测试，可以得出尾递归的性能消耗很低，速度很快。</p><h4 id="4-1-编译器对尾递归的优化"><a href="#4-1-编译器对尾递归的优化" class="headerlink" title="4.1 编译器对尾递归的优化"></a>4.1 编译器对尾递归的优化</h4><p>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。</p><p>scala编译器会察觉到尾递归，并对其进行优化，将它编译成循环的模式。</p><h4 id="4-2-Scala尾递归的限制"><a href="#4-2-Scala尾递归的限制" class="headerlink" title="4.2 Scala尾递归的限制"></a>4.2 Scala尾递归的限制</h4><ul><li><p>尾递归有严格的要求，就是最后一个语句是递归调用，因此写法比较严格。</p></li><li><p>尾递归最后调用的必须是它本身，间接的赋值它本身的函数也无法进行优化。</p></li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>循环调用都是一个累计器和一个迭代器的作用，同理，尾递归也是如此，它也是通过累加和迭代将结果赋值给新一轮的调用，通过这个思路，我们可以轻松的将循环转换为尾递归的形式。</p><p>[本文完，欢迎转载，转载请注明出处]</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/maple.png" alt="枫叶"></figure><p class="title is-size-4 is-block" style="line-height:inherit">枫叶</p><p class="is-size-6 is-block">技术博客</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·武汉</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="public_avatar" src="/img/%E9%9D%9E%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%91%982.jpeg" alt="zane ray"></figure><div class="level"><a class="level-item button is-primary is-rounded" href="/img/%E9%9D%9E%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%91%981.jpeg" target="_blank" rel="noopener">↑关注我的公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat.png"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><link href="/music/APlayer.min.css"><div id="aplayer" style="margin:0 auto"></div><script src="/music/APlayer.min.js"></script><script src="/music/APlayer_Music.js"></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Dubbo/"><span class="level-start"><span class="level-item">Dubbo</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Nginx/"><span class="level-start"><span class="level-item">Nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Nginx/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Play/"><span class="level-start"><span class="level-item">Play</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/java/rocketmq/"><span class="level-start"><span class="level-item">rocketmq</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/spring%E4%B8%93%E9%A2%98/"><span class="level-start"><span class="level-item">spring专题</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/angular/"><span class="level-start"><span class="level-item">angular</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/p/ac45747d.html"><img src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></figure><div class="media-content"><p class="date"><time datetime="2021-05-07T02:54:53.000Z">2021-05-07</time></p><p class="title"><a href="/p/ac45747d.html">Spring 学习 [1]</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/p/a8949b93.html"><img src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></figure><div class="media-content"><p class="date"><time datetime="2019-04-01T11:43:12.000Z">2019-04-01</time></p><p class="title"><a href="/p/a8949b93.html">Scala实战 -- 对List中的部分元素进行合并操作</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-09T16:00:00.000Z">2019-01-10</time></p><p class="title"><a href="/p/6e951315.html">🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-24T16:00:00.000Z">2018-12-25</time></p><p class="title"><a href="/p/87290a79.html">🎮 Play 入门与学习(五) Dependency Injection</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-16T16:00:00.000Z">2018-12-17</time></p><p class="title"><a href="/p/fe729f21.html">🎮 Play 入门与学习(三) Asynchronous results</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Play/"><span class="tag">Play</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a><p class="is-size-7"><span>&copy; 2021 Zane Ray</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>
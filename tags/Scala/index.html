<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>标签: Scala - 非普通程序员</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非普通程序员"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非普通程序员"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="非普通程序员的技术博客，以源码分析和连载为主"><meta property="og:type" content="blog"><meta property="og:title" content="非普通程序员"><meta property="og:url" content="http://leihuazhe.github.io/"><meta property="og:site_name" content="非普通程序员"><meta property="og:description" content="非普通程序员的技术博客，以源码分析和连载为主"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://leihuazhe.github.io/img/og_image.png"><meta property="article:author" content="Zane Ray"><meta property="article:tag" content="Java, Scala, Spring, Dubbo, MQ, Middleware"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://leihuazhe.github.io"},"headline":"非普通程序员","image":["http://leihuazhe.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Zane Ray"},"description":"非普通程序员的技术博客，以源码分析和连载为主"}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Scala</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/p/a8949b93.html"><img class="fill" src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/a8949b93.html"><i class="fas fa-angle-double-right"></i>Scala实战 -- 对List中的部分元素进行合并操作</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2019-04-01</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">5 分钟读完 (大约737个字)</span></div></div><div class="content"><blockquote><p>近期业务出现了一个需求，需要对一个相同实体的List中，部分实体名和id相同的元素进行合并，将其合并为一个实体，以便在业务上做统计处理，合并后的实体为合并前的实体的某些数值相加。<br>此需求催生了本篇文章。我们将抽象一个简单的实体来介绍，<strong>如何在Scala List 中合并部分Element 元素。</strong></p></blockquote></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div><a class="article-more button is-small is-size-7" href="/p/a8949b93.html#more"><i class="fas fa-book-reader has-text-grey"></i>  阅读更多</a></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/6e951315.html"><i class="fas fa-angle-double-right"></i>🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2019-01-10</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">几秒读完 (大约87个字)</span></div></div><div class="content"><blockquote><p>由于目前在公司使用的 Play 版本是 2.5.4，本章将会讲解一下对此版本 Action 的相关知识。</p></blockquote><h2 id="使用-ActionBuilder-构建一个通用的-Action"><a href="#使用-ActionBuilder-构建一个通用的-Action" class="headerlink" title="使用 ActionBuilder 构建一个通用的 Action"></a>使用 ActionBuilder 构建一个通用的 Action</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LogAction</span> <span class="keyword">extends</span> <span class="title">ActionBuilder</span>[<span class="type">Request</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>], block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>]): <span class="type">Future</span>[<span class="type">Result</span>] = &#123;</span><br><span class="line">        <span class="keyword">val</span> start = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">        block(request).map &#123; result =&gt;</span><br><span class="line">            <span class="keyword">val</span> duration = <span class="type">System</span>.currentTimeMillis() - start</span><br><span class="line">            println(<span class="string">s&quot;请求 <span class="subst">$request</span> 耗时 <span class="subst">$duration</span>&quot;</span>)</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/87290a79.html"><i class="fas fa-angle-double-right"></i>🎮 Play 入门与学习(五) Dependency Injection</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-25</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">28 分钟读完 (大约4222个字)</span></div></div><div class="content"><blockquote><p>依赖注入是一种广泛使用的设计模式，有助于将组件的行为与依赖性解析分开。Play支持基于JSR 330（在本页中描述）的运行时依赖注入和在Scala中编译时依赖注入。<br>之所以调用运行时依赖项注入，是因为依赖关系图是在运行时创建，连接和验证的。 如果找不到特定组件的依赖项，则在运行应用程序之前不会出现错误。</p></blockquote><p>Play支持Guice开箱即用，但可以插入其他JSR 330实现. <a target="_blank" rel="noopener" href="https://github.com/google/guice/wiki/">Guice wiki</a> 是一个很好的资源，可以更多地了解Guice和DI设计模式的功能。</p><p>注意：Guice是一个Java库，本文档中的示例使用Guice的内置Java API。 如果您更喜欢Scala DSL，您可能希望使用scala-guice或sse-guice库。</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>依赖注入实现了几个目标：</p><ul><li>它允许您轻松绑定同一组件的不同实现。 这对于测试尤其有用，您可以使用模拟依赖项手动实例化组件或注入备用实现。</li><li>它允许您避免全局静态。 虽然静态工厂可以实现第一个目标，但您必须小心确保正确设置状态。 特别是Play（现已弃用）的静态API需要运行的应用程序，这使得测试的灵活性降低。 并且一次有多个实例可以并行运行测试。</li></ul><p><code>Guice wiki</code> 有一些很好的例子可以更详细地解释这一点。</p><h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h2><p>Play 提供了许多内置组件，并在诸如 <code>BuiltinModule</code> 之类的模块中声明它们。 这些绑定描述了创建 <code>Application</code> 实例所需的所有内容，默认情况下包括由 <code>routes compiler</code> 生成的 <code>route</code>，该 route 将控制器注入到构造函数中。 然后可以将这些绑定转换为在 <code>Guice</code> 和其他运行时DI框架中工作。</p><p>Play团队维护Guice模块，该模块提供 <code>GuiceApplicationLoader</code>。 这为 <code>Guice</code> 进行绑定转换，使用这些绑定创建Guice注入器，并从注入器请求Application实例。</p><p>There are also third-party loaders that do this for other frameworks, including <a target="_blank" rel="noopener" href="https://github.com/scaldi/scaldi-play">Scaldi </a>and <a target="_blank" rel="noopener" href="https://github.com/remithieblin/play-spring-loader">Spring</a>.</p><p>或者，Play提供了一个 <code>BuiltInComponents</code> 特性，允许您创建一个纯Scala实现，在编译时将您的应用程序连接在一起。</p><p>我们将在下面详细介绍如何自定义默认绑定和应用程序加载器。</p><h2 id="Declaring-runtime-DI-dependencies"><a href="#Declaring-runtime-DI-dependencies" class="headerlink" title="Declaring runtime DI dependencies"></a>Declaring runtime DI dependencies</h2><blockquote><p>声明运行时DI依赖项</p></blockquote><p>如果您有一个组件（例如控制器），并且它需要一些其他组件作为依赖项，那么可以使用 <code>@Inject</code> 注解来声明它。 <code>@Inject</code> 注解可用于字段或构造函数。 我们建议您在构造函数上使用它，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.ws._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">ws: <span class="type">WSClient</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>@Inject</code> 注释必须位于类名之后但在构造函数参数之前，并且必须具有括号。</p><p>此外，Guice 确实提供了其他几种类型的注入方式，但构造函数注入通常是 <code>Scala</code> 中最清晰，简洁和可测试的，因此我们建议使用它。</p><p><code>Guice</code> 能够在其构造函数上使用 <code>@Inject</code> 自动实例化任何类，而无需显式绑定它。此功能被称为 <a target="_blank" rel="noopener" href="https://github.com/google/guice/wiki/JustInTimeBindings">just in time bindings</a>，<code>Guice</code> 文档中对此进行了更详细的描述。 如果您需要执行更复杂的操作，可以声明自定义绑定，如下所述。</p><h2 id="Dependency-injecting-controllers"><a href="#Dependency-injecting-controllers" class="headerlink" title="Dependency injecting controllers"></a>Dependency injecting controllers</h2><blockquote><p>依赖注入控制器</p></blockquote><p>There are two ways to make Play use dependency injected controllers.</p><p>有两种方法可以使 <code>Play</code> 使用依赖注入控制器。</p><h3 id="Injected-routes-generator"><a href="#Injected-routes-generator" class="headerlink" title="Injected routes generator"></a>Injected routes generator</h3><p>默认情况下（从2.5.0开始），<code>Play</code> 将生成一个 router ，该 router 将声明它所路由的所有控制器作为依赖项，允许您的控制器自己依赖注入。</p><p>要专门启用注入的路由生成器，请将以下内容添加到 <code>build.sbt</code> 中的构建设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routesGenerator :&#x3D; InjectedRoutesGenerator</span><br></pre></td></tr></table></figure><p>当使用 <code>injected routes generator</code> 时，为操作添加 <code>@</code> 符号前缀具有特殊含义，这意味着不是直接注入控制器，而是注入控制器的提供者。 例如，这允许 prototype controllers，以及用于打破循环依赖性的选项。</p><h3 id="Static-routes-generator"><a href="#Static-routes-generator" class="headerlink" title="Static routes generator"></a>Static routes generator</h3><p>您可以将Play配置为使用 legacy（pre 2.5.0）静态路由生成器，该生成器假定所有操作都是静态方法。 要配置项目，请将以下内容添加到 <code>build.sbt</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routesGenerator :&#x3D; StaticRoutesGenerator</span><br></pre></td></tr></table></figure><p>我们建议始终使用注入的路由生成器。 静态路由生成器主要作为辅助迁移的工具存在，因此现有项目不必一次使所有控制器不是静态的。</p><p>如果使用静态路由生成器，则可以通过在操作前加上@来指示操作具有注入的控制器，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET        &#x2F;some&#x2F;path           @controllers.Application.index</span><br></pre></td></tr></table></figure><h2 id="Component-lifecycle"><a href="#Component-lifecycle" class="headerlink" title="Component lifecycle"></a>Component lifecycle</h2><p>依赖注入系统管理注入组件的生命周期，根据需要创建它们并将它们注入其他组件。以下是组件生命周期的工作原理：</p><ul><li><strong>每次需要组件时都会创建新实例</strong>。如果组件多次使用，则默认情况下将创建组件的多个实例。如果您只需要组件的单个实例，则需要将其标记为单个实例。</li><li><strong>实例在需要时会以懒加载的形式创建</strong>。如果组件从未被其他组件使用，则根本不会创建它。这通常是你想要的。对于大多数组件而言，在需要之前创建它们是没有意义的。但是，在某些情况下，您希望直接启动组件，或者即使它们未被其他组件使用也是如此。例如，您可能希望在应用程序启动时向远程系统发送消息或预热缓存。您可以使用急切绑定 (<code>eager binding</code>) 强制创建组件。</li><li><strong>除了正常的垃圾收集之外，实例不会自动清理</strong>。当组件不再被引用时，它们将被垃圾收集，但框架将不会执行任何特殊操作来关闭组件，例如调用 <code>close</code> 方法。但是，<code>Play</code> 提供了一种特殊类型的组件，称为<code>ApplicationLifecycle</code>，它允许您注册组件以在应用程序停止时关闭。</li></ul><h2 id="Singletons"><a href="#Singletons" class="headerlink" title="Singletons"></a>Singletons</h2><p>有时，您可能拥有一个包含某些状态的组件，例如缓存，或者与外部资源的连接，或者创建组件可能很昂贵。 在这些情况下，该组件应该是单例的。 这可以使用 <code>@Singleton</code> 注解来实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrentSharePrice</span> </span>&#123;</span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> price = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set</span></span>(p: <span class="type">Int</span>) = price = p</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= price</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stopping-cleaning-up"><a href="#Stopping-cleaning-up" class="headerlink" title="Stopping/cleaning up"></a>Stopping/cleaning up</h2><p><code>Play</code> 关闭时可能需要清理某些组件，例如，停止线程池。 Play提供了一个 <code>ApplicationLifecycle</code> 组件，可用于在 <code>Play</code> 关闭时注册挂钩以停止组件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Future</span></span><br><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.inject.<span class="type">ApplicationLifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueueConnection</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">lifecycle: <span class="type">ApplicationLifecycle</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> connection = connectToMessageQueue()</span><br><span class="line">  lifecycle.addStopHook &#123; () =&gt;</span><br><span class="line">    <span class="type">Future</span>.successful(connection.stop())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationLifecycle</code> 将在创建时以相反的顺序停止所有组件。 这意味着您依赖的任何组件仍然可以安全地用在组件的停止钩子上。 因为您依赖它们，所以它们必须在组件之前创建，因此在组件停止之前不会停止。</p><p>注意：确保注册 <code>stop hook</code> 的所有组件都是单例非常重要。 注册 <code>stop</code> 钩子的任何非单例组件都可能是内存泄漏的来源，因为每次创建组件时都会注册一个新的钩子。</p><h2 id="Providing-custom-bindings"><a href="#Providing-custom-bindings" class="headerlink" title="Providing custom bindings"></a>Providing custom bindings</h2><blockquote><p>提供自定义绑定</p></blockquote><p>为组件定义 <code>trait</code> 被认为是一种好习惯，并且其他类依赖于该 <code>trait</code>，而不是组件的实现。 通过这样做，您可以注入不同的实现，例如，在测试应用程序时注入模拟实现。</p><p>在这种情况下，DI系统需要知道哪个实现应该绑定到该 <code>trait</code>。 我们建议您声明这一点的方式取决于您是将 <code>Play</code> 应用程序编写为 <code>Play</code> 的最终用户，还是编写其他 <code>Play</code> 应用程序将使用的库。</p><h3 id="Play-applications"><a href="#Play-applications" class="headerlink" title="Play applications"></a>Play applications</h3><p>我们建议 <code>Play</code> 应用程序使用应用程序正在使用的 <code>DI</code> 框架提供的任何机制。 尽管Play确实提供了绑定API，但此API有些限制，并且不允许您充分利用您正在使用的框架的强大功能。</p><p>由于Play为Guice提供了开箱即用的支持，下面的示例显示了如何为 <code>Guice</code> 提供绑定。</p><h4 id="Binding-annotations"><a href="#Binding-annotations" class="headerlink" title="Binding annotations"></a>Binding annotations</h4><p>将实现绑定到接口的最简单方法是使用 <code>Guice</code> <code>@ImplementedBy</code> 注释。 例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">ImplementedBy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ImplementedBy</span>(classOf[<span class="type">EnglishHello</span>])</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnglishHello</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name: <span class="type">String</span>) = <span class="string">&quot;Hello &quot;</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Programmatic-bindings"><a href="#Programmatic-bindings" class="headerlink" title="Programmatic bindings"></a>Programmatic bindings</h4><p>在一些更复杂的情况下，您可能希望提供更复杂的绑定，例如当您有一个 <code>trait</code> 的多个实现时，这些 <code>trait</code> 由 <code>@Named</code> 注释限定。 在这些情况下，您可以实现自定义 <code>Guice</code> 模块</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.<span class="type">Names</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line"></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;en&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">EnglishHello</span>])</span><br><span class="line"></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;de&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">GermanHello</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您将此模块称为 <code>Module</code> 并将其放在根包中，它将自动注册到 <code>Play</code>。 或者，如果要为其指定不同的名称或将其放在不同的包中，可以通过将其全限定名附加到 <code>application.conf</code> 中的 <code>play.modules.enabled</code> 列表来将其注册到 <code>Play</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.enabled +&#x3D; &quot;modules.HelloModule&quot;</span><br></pre></td></tr></table></figure><p>您还可以通过将以下模块添加到已禁用的模块来禁用根软件包中名为 <code>Module</code> 的模块的自动注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.disabled +&#x3D; &quot;Module&quot;</span><br></pre></td></tr></table></figure><h4 id="Configurable-bindings"><a href="#Configurable-bindings" class="headerlink" title="Configurable bindings"></a>Configurable bindings</h4><blockquote><p>可配置的绑定</p></blockquote><p>有时您可能希望在配置 <code>Guice</code> 绑定时读取 Play <code>Configuration</code> 或使用 <code>ClassLoader</code>。 您可以通过将这些对象添加到模块的构造函数来访问这些对象。</p><p>在下面的示例中，从配置文件中读取每种语言的 <code>Hello</code> 绑定。 这允许通过在 <code>application.conf</code> 文件中添加新设置来添加新的 <code>Hello</code> 绑定。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.<span class="type">Names</span></span><br><span class="line"><span class="keyword">import</span> play.api.&#123; <span class="type">Configuration</span>, <span class="type">Environment</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span>(<span class="params">environment: <span class="type">Environment</span>,configuration: <span class="type">Configuration</span></span>) </span></span><br><span class="line"><span class="class">															<span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line">    <span class="comment">// Expect configuration like:</span></span><br><span class="line">    <span class="comment">// hello.en = &quot;myapp.EnglishHello&quot;</span></span><br><span class="line">    <span class="comment">// hello.de = &quot;myapp.GermanHello&quot;</span></span><br><span class="line">    <span class="keyword">val</span> helloConfiguration: <span class="type">Configuration</span> =</span><br><span class="line">      configuration.getOptional[<span class="type">Configuration</span>](<span class="string">&quot;hello&quot;</span>).getOrElse(<span class="type">Configuration</span>.empty)</span><br><span class="line">    <span class="keyword">val</span> languages: <span class="type">Set</span>[<span class="type">String</span>] = helloConfiguration.subKeys</span><br><span class="line">    <span class="comment">// Iterate through all the languages and bind the</span></span><br><span class="line">    <span class="comment">// class associated with that language. Use Play&#x27;s</span></span><br><span class="line">    <span class="comment">// ClassLoader to load the classes.</span></span><br><span class="line">    <span class="keyword">for</span> (l &lt;- languages) &#123;</span><br><span class="line">      <span class="keyword">val</span> bindingClassName: <span class="type">String</span> = helloConfiguration.get[<span class="type">String</span>](l)</span><br><span class="line">      <span class="keyword">val</span> bindingClass: <span class="type">Class</span>[_ &lt;: <span class="type">Hello</span>] =</span><br><span class="line">        environment.classLoader.loadClass(bindingClassName)</span><br><span class="line">        .asSubclass(classOf[<span class="type">Hello</span>])</span><br><span class="line">      bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">        .annotatedWith(<span class="type">Names</span>.named(l))</span><br><span class="line">        .to(bindingClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在大多数情况下，如果在创建组件时需要访问 <code>Configuration</code>，则应将 <code>Configuration</code> 对象注入组件本身或组件的 <code>Provider</code> 中。 然后，您可以在创建组件时读取“配置”。 在为组件创建绑定时，通常不需要读取<code>Configuration</code>。</p><h4 id="Eager-bindings"><a href="#Eager-bindings" class="headerlink" title="Eager bindings"></a>Eager bindings</h4><blockquote><p>提前绑定</p></blockquote><p>在上面的代码中，每次使用时都会创建新的 <code>EnglishHello</code> 和 <code>GermanHello</code> 对象。 如果您只想创建一次这些对象，可能因为创建它们很昂贵，那么您应该使用 <code>@Singleton</code> 注释。 如果你想创建它们一次并在应用程序启动时急切地创建它们，而不是在需要它们懒加载，那么你就可以使用 <a target="_blank" rel="noopener" href="https://github.com/google/guice/wiki/Scopes#eager-singletons">Guice’s eager singleton binding</a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.<span class="type">Names</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Module is needed to register bindings</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the `Hello` interface to the `EnglishHello` implementation as eager singleton.</span></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;en&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">EnglishHello</span>]).asEagerSingleton()</span><br><span class="line"></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;de&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">GermanHello</span>]).asEagerSingleton()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用程序启动时，可以使用 <code>Eager</code> 单例来启动服务。 它们通常与关闭钩子组合在一起，以便服务可以在应用程序停止时清理其资源。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Future</span></span><br><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.inject.<span class="type">ApplicationLifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This creates an `ApplicationStart` object once at start-up and registers hook for shut-down.</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationStart</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">lifecycle: <span class="type">ApplicationLifecycle</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Shut-down hook</span></span><br><span class="line">  lifecycle.addStopHook &#123; () =&gt;</span><br><span class="line">    <span class="type">Future</span>.successful(())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line">    bind(classOf[<span class="type">ApplicationStart</span>]).asEagerSingleton()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Play-libraries"><a href="#Play-libraries" class="headerlink" title="Play libraries"></a>Play libraries</h3><p>如果您正在为Play实现一个库，那么您可能希望它与DI框架无关，这样无论在应用程序中使用哪个DI框架，您的库都可以开箱即用。 出于这个原因，Play提供了一个轻量级绑定API，用于以DI框架无关的方式提供绑定。</p><p>要提供绑定，请实现Module以返回要提供的绑定序列。 Module trait还提供用于构建绑定的DSL：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.inject._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloModule</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bindings</span></span>(environment: <span class="type">Environment</span>,</span><br><span class="line">               configuration: <span class="type">Configuration</span>) = <span class="type">Seq</span>(</span><br><span class="line">    bind[<span class="type">Hello</span>].qualifiedWith(<span class="string">&quot;en&quot;</span>).to[<span class="type">EnglishHello</span>],</span><br><span class="line">    bind[<span class="type">Hello</span>].qualifiedWith(<span class="string">&quot;de&quot;</span>).to[<span class="type">GermanHello</span>]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将该模块附加到reference.conf中的play.modules.enabled列表，可以自动注册该模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.enabled +&#x3D; &quot;com.example.HelloModule&quot;</span><br></pre></td></tr></table></figure><p>Module bindings方法采用Play环境和配置。 如果要动态配置绑定，可以访问这些。<br>模块绑定支持急切绑定。 要声明一个急切绑定，请在绑定结束时添加.eagerly。</p><p>为了最大化跨框架兼容性，请记住以下事项：</p><ul><li>并非所有DI框架都只支持时间绑定。 确保明确绑定库提供的所有组件。</li><li>尝试保持绑定键简单 - 不同的运行时DI框架对键是什么以及它应该如何唯一或不唯一有不同的看</li></ul><h3 id="Excluding-modules"><a href="#Excluding-modules" class="headerlink" title="Excluding modules"></a>Excluding modules</h3><p>如果有一个您不想加载的模块，可以通过将其附加到application.conf中的play.modules.disabled属性来将其排除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.disabled +&#x3D; &quot;play.api.db.evolutions.EvolutionsModule&quot;</span><br></pre></td></tr></table></figure><h2 id="Managing-circular-dependencies"><a href="#Managing-circular-dependencies" class="headerlink" title="Managing circular dependencies"></a>Managing circular dependencies</h2><p>当您的某个组件依赖于依赖于原始组件的另一个组件（直接或间接）时，就会发生循环依赖关系。 例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.<span class="type">Inject</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">bar: <span class="type">Bar</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Bar</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">baz: <span class="type">Baz</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Baz</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">foo: <span class="type">Foo</span></span>)</span></span><br></pre></td></tr></table></figure><p>在这种情况下，Foo依赖于Bar，它取决于Baz，它依赖于Foo。 因此，您将无法实例化任何这些类。 您可以使用提供程序解决此问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.&#123; <span class="type">Inject</span>, <span class="type">Provider</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">bar: <span class="type">Bar</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Bar</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">baz: <span class="type">Baz</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Baz</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">foo: <span class="type">Provider</span>[<span class="type">Foo</span>]</span>)</span></span><br></pre></td></tr></table></figure><p>通常，可以通过以更原子的方式分解组件或查找要依赖的更具体的组件来解决循环依赖性。 常见问题是对Application的依赖。 当你的组件依赖于应用程序时，它说它需要一个完整的应用程序来完成它的工作; 通常情况并非如此。 您的依赖项应该位于具有您需要的特定功能的更具体的组件（例如，环境）上。 作为最后的手段，您可以通过注入Provider [Application]来解决问题。</p><h2 id="Advanced-Extending-the-GuiceApplicationLoader"><a href="#Advanced-Extending-the-GuiceApplicationLoader" class="headerlink" title="Advanced: Extending the GuiceApplicationLoader"></a>Advanced: Extending the GuiceApplicationLoader</h2><p>Play的运行时依赖注入由GuiceApplicationLoader类引导。 该类加载所有模块，将模块提供给Guice，然后使用Guice创建应用程序。 如果要控制Guice如何初始化应用程序，则可以扩展GuiceApplicationLoader类。</p><p>您可以覆盖几种方法，但通常需要覆盖构建器方法。 此方法读取ApplicationLoader.Context并创建GuiceApplicationBuilder。 您可以在下面看到构建器的标准实现，您可以按照自己喜欢的方式进行更改。 您可以在有关使用Guice进行测试的部分中找到如何使用GuiceApplicationBuilder。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.<span class="type">ApplicationLoader</span></span><br><span class="line"><span class="keyword">import</span> play.api.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> play.api.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.inject.guice._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomApplicationLoader</span> <span class="keyword">extends</span> <span class="title">GuiceApplicationLoader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">builder</span></span>(context: <span class="type">ApplicationLoader</span>.<span class="type">Context</span>): <span class="type">GuiceApplicationBuilder</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> extra = <span class="type">Configuration</span>(<span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>)</span><br><span class="line">    initialBuilder</span><br><span class="line">      .in(context.environment)</span><br><span class="line">      .loadConfig(extra ++ context.initialConfiguration)</span><br><span class="line">      .overrides(overrides(context): _*)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您覆盖ApplicationLoader时，您需要告诉Play。 将以下设置添加到application.conf：</p><p>play.application.loader =“modules.CustomApplicationLoader”<br>您不仅限于使用Guice进行依赖注入。 通过重写ApplicationLoader，您可以控制应用程序的初始化方式。 在下一节中了解更多信息。</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/fe729f21.html"><i class="fas fa-angle-double-right"></i>🎮 Play 入门与学习(三) Asynchronous results</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-17</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">14 分钟读完 (大约2145个字)</span></div></div><div class="content"><blockquote><p>本章我们将讲解使用 Play 进行异步非阻塞编程情况下，如何处理异步返回结果的问题。</p></blockquote><h2 id="Handling-asynchronous-results"><a href="#Handling-asynchronous-results" class="headerlink" title="Handling asynchronous results"></a>Handling asynchronous results</h2><blockquote><p>从现在开始我们将进入异步 <code>http</code> 编程模块，本章将会介绍如何处理异步返回结果。</p></blockquote><h3 id="Make-controllers-asynchronous"><a href="#Make-controllers-asynchronous" class="headerlink" title="Make controllers asynchronous"></a>Make controllers asynchronous</h3><blockquote><p>使 controllers 变为异步的</p></blockquote><p>在 <code>Play Framework</code> 内部，其机制是自底向上全异步编程模式的，Play 会以异步、非阻塞的方式处理每个请求。</p><p>默认配置(<code>configuration</code>) 针对异步控制器(<code>asynchronous controllers</code>) 进行了优化。换句话说，应用程序代码应该尽量避免在控制器中进行阻塞,这样会导致控制器一直等待那个阻塞的操作。此类阻塞操作的常见示例有JDBC调用、流API、HTTP请求和长计算等。</p><p>虽然可以增加默认 <code>executionContext</code> 中线程的数量，以允许阻塞控制器处理更多的并发请求，但是遵循建议的保持控制器异步的方法可以更容易地进行扩展，并在负载下保持系统响应。</p><h3 id="Creating-non-blocking-actions"><a href="#Creating-non-blocking-actions" class="headerlink" title="Creating non-blocking actions"></a>Creating non-blocking actions</h3><blockquote><p>创建非阻塞的 <code>actions</code></p></blockquote><p>由于 <code>Play</code> 的工作方式，<code>action</code> 代码必须尽可能快，即非阻塞。那么，如果我们在还没有生成结果情形下，如何返回结果呢?答案是使用 <code>Future</code>。</p><p>A <code>Future[Result]</code> will eventually be redeemed with a value of type <code>Result</code>.</p><p>By giving a <code>Future[Result]</code> instead of a normal <code>Result</code>, we are able to quickly generate the result without blocking.</p><p>Play will then serve the result as soon as the promise is redeemed.</p><p>The web client will be blocked while waiting for the response, but nothing will be blocked on the server, and server resources can be used to serve other clients.</p><p>Using a <code>Future</code> is only half of the picture though!</p><blockquote><p>然而，使用<code>Future</code>只是这幅画的一半. (使用 Future 只是 Play 异步编程的一半)</p></blockquote><p>If you are calling out to a blocking API such as JDBC,then you still will need to have your ExecutionStage(<code>执行阶段</code>) run with a different executor, to move it off Play’s rendering thread pool.</p><p>You can do this by creating a subclass of <code>play.api.libs.concurrent.CustomExecutionContext</code>with a reference to the <a target="_blank" rel="noopener" href="https://doc.akka.io/docs/akka/2.5/dispatchers.html?language=scala">custom dispatcher</a>.</p><blockquote><p>这里意思是如果针对长时间阻塞的任务，比如JDBC，像上述方式操作，我们只不过是把当前任务的执行放到了另外一条线程中继续阻塞了而已，因此仍然是假异步。这时候，我们可以定义自定义的<code>CustomExecutionContext</code></p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.libs.concurrent.<span class="type">CustomExecutionContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请确保使用&quot;Scala Dependency Injection&quot;文档页面中列出的 custom binding 技术之一</span></span><br><span class="line"><span class="comment">//将 new context 绑定到当前 trait </span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyExecutionContext</span> <span class="keyword">extends</span> <span class="title">ExecutionContext</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyExecutionContextImpl</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">system: <span class="type">ActorSystem</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">CustomExecutionContext</span>(<span class="params">system, &quot;my.executor&quot;</span>) <span class="keyword">with</span> <span class="title">MyExecutionContext</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HomeController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">myExecutionContext: <span class="type">MyExecutionContext</span>, val controllerComponents: <span class="type">ControllerComponents</span></span>) <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">    <span class="type">Future</span> &#123;</span><br><span class="line">      <span class="comment">// Call some blocking API</span></span><br><span class="line">      <span class="type">Ok</span>(<span class="string">&quot;result of blocking call&quot;</span>)</span><br><span class="line">    &#125;(myExecutionContext)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="How-to-create-a-Future-Result"><a href="#How-to-create-a-Future-Result" class="headerlink" title="How to create a Future[Result]"></a>How to create a Future[Result]</h3><blockquote><p>要创建一个 <code>Future[Result]</code>，我们首先需要另一个<code>future</code>, 这个 <code>future</code> 会给我们返回我们需要计算的实际的结果。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futurePIValue: <span class="type">Future</span>[<span class="type">Double</span>] = computePIAsynchronously()</span><br><span class="line"><span class="keyword">val</span> futureResult: <span class="type">Future</span>[<span class="type">Result</span>] = futurePIValue.map &#123; pi =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;PI value computed: &quot;</span> + pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All of Play’s asynchronous API calls give you a <code>Future</code>. This is the case whether you are calling an external web service using the <code>play.api.libs.WS</code> API, or using Akka to schedule asynchronous tasks or to communicate with actors using <code>play.api.libs.Akka</code>.</p><blockquote><p><code>PlayFramework</code> 所有异步的 <code>API</code> 返回的结果都是一个 <code>Future</code>，无论你是通过 <code>play.api.libs.WS</code> API 调用一个外部的 <code>web</code> 服务，或者使用Akka调度异步任务，或者使用 <code>play. API .lib .Akka</code>与 <code>actor</code> 通信等等，返回都是 <code>Future</code>。</p></blockquote><p>下面是一个通过异步模式执行一段阻塞的代码，并返回一个 Future 简单的例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futureInt: <span class="type">Future</span>[<span class="type">Int</span>] = scala.concurrent.<span class="type">Future</span> &#123;</span><br><span class="line">  intensiveComputation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>It’s important to understand which thread code runs on with futures. In the two code blocks above, there is an import on Plays default execution context. This is an implicit parameter that gets passed to all methods on the future API that accept callbacks. The execution context will often be equivalent to a thread pool, though not necessarily.</p><blockquote><p>理解哪些线程代码在 Future 上运行是很重要的。在上面的两个代码块中，在 Play 默认 executionContext 上有一个导入。这是一个隐式参数，传递给 future API上所有接受回调的方法。executionContext 通常等价于线程池，但也不一定。</p></blockquote><p>You can’t magically turn synchronous IO into asynchronous by wrapping it in a <code>Future</code>. If you can’t change the application’s architecture to avoid blocking operations, at some point that operation will have to be executed, and that thread is going to block. So in addition to enclosing the operation in a <code>Future</code>, it’s necessary to configure it to run in a separate execution context that has been configured with enough threads to deal with the expected concurrency. See <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/ThreadPools">Understanding Play thread pools</a> for more information, and download the <a target="_blank" rel="noopener" href="https://playframework.com/download#examples">play example templates</a> that show database integration.</p><blockquote><p>你不能通过将代码块包装在一个 Future下来神奇地把<strong>同步IO</strong>变成异步的。如果您不能更改应用程序的体系结构以避免阻塞操作，那么在某个时刻，该操作将不得不执行，而该线程将阻塞。</p><p>因此，除了将操作封装在 <code>Future</code> 中之外，还需要将其配置为在一个单独的 <code>executionContext</code> 中运行，该上下文中已经配置了足够的线程来处理预期的并发。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/ThreadPools">了解Play线程池</a>，并下载显示数据库集成的<a target="_blank" rel="noopener" href="https://playframework.com/download#example">Play示例模板</a></p></blockquote><p>It can also be helpful to use Actors for blocking operations.</p><p>Actors provide a clean model for handling timeouts and failures, setting up blocking execution contexts, and managing any state that may be associated with the service.</p><p>Also Actors provide patterns like <code>ScatterGatherFirstCompletedRouter</code> to address simultaneous cache and database requests and allow remote execution on a cluster of backend servers. But an Actor may be overkill depending on what you need.</p><blockquote><p>对于阻塞操作场景，使用 Actors 模式是一个不错的选择。<code>Actors</code> 提供了一个简单一个简单的模型，来处理超时、故障、设置阻塞的 <code>executionContext</code> 以及与服务关联的任何状态。</p><p>Actors 还提供了像 “ScatterGatherFirstCompletedRouter” 这样的模式来处理同步缓存和数据库请求，并允许在后端服务器集群上远程执行。但是一个 actor 可能会因为你的需要而 overkill。</p></blockquote><h3 id="Returning-futures"><a href="#Returning-futures" class="headerlink" title="Returning futures"></a>Returning futures</h3><blockquote><p>返回 futures</p></blockquote><p>While we were using the <code>Action.apply</code> builder method to build actions until now, to send an asynchronous result we need to use the <code>Action.async</code> builder method:</p><p>当我们使用 <code>Action.apply</code> 时，将 <code>builder</code> 方法应用于 <code>actions</code> ，到目前为止，要发送异步结果，我们需要使用异步的 Actiton builder 方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">  <span class="keyword">val</span> futureInt = scala.concurrent.<span class="type">Future</span> &#123; intensiveComputation() &#125;</span><br><span class="line">  futureInt.map(i =&gt; <span class="type">Ok</span>(<span class="string">&quot;Got result: &quot;</span> + i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Actions-are-asynchronous-by-default"><a href="#Actions-are-asynchronous-by-default" class="headerlink" title="Actions are asynchronous by default"></a>Actions are asynchronous by default</h3><blockquote><p>默认情况下，<code>Actions</code> 是异步的。例如，在下面的控制器代码中，代码的<code>&#123;Ok(…)&#125;</code> 部分不是控制器的方法体。它是一个匿名函数，被传递给 <code>Action</code> 对象的 <code>apply</code>方法，该方法创建一个 <code>Action</code> 类型的对象。在内部，您编写的匿名函数将被调用，其结果将返回在 <code>Future</code>中。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span> </span>= <span class="type">Action</span> &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got request [&quot;</span> + request + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Both <code>Action.apply</code> and <code>Action.async</code> create <code>Action</code> objects that are handled internally in the same way. There is a single kind of <code>Action</code>, which is asynchronous, and not two kinds (a synchronous one and an asynchronous one). The <code>.async</code> builder is just a facility to simplify creating actions based on APIs that return a <code>Future</code>, which makes it easier to write non-blocking code.</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><code>Action.apply</code> 和 <code>Action.async</code> 在内部都以相同的方式来处理 <code>Action</code> 对象。</p><p>有一种单独的 Action，它是异步的，但是不是a synchronous one and an asynchronous one 中的一种。</p><p><code>.async</code> builder只是一个工具，用于在创建 <code>actions</code> 时基于返回 <code>Future</code> result 的 api 的操作进行简化，这使得编写非阻塞代码更加容易。</p><h3 id="Handling-time-outs"><a href="#Handling-time-outs" class="headerlink" title="Handling time-outs"></a>Handling time-outs</h3><blockquote><p>处理超时情况</p></blockquote><p>正确处理超时，避免 <code>web</code> 浏览器阻塞并在出现问题时等待，这通常很有用。您可以使用 <code>play.api.libs.concurrent.Futures</code> 来将非阻塞的超时包装在一个 <code>Futures</code> 中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.concurrent.<span class="type">Futures</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">  <span class="comment">// 你可以隐式的提供一个超时参数，这题哦你歌唱可以通过controller的构造参数来达到。</span></span><br><span class="line">  intensiveComputation().withTimeout(<span class="number">1.</span>seconds).map &#123; i =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Got result: &quot;</span> + i)</span><br><span class="line">  &#125;.recover &#123;</span><br><span class="line">    <span class="keyword">case</span> e: scala.concurrent.<span class="type">TimeoutException</span> =&gt;</span><br><span class="line">      <span class="type">InternalServerError</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>超时(Timeout)与取消(cancellation) 是不同的。对于超时而言，即使出现了超时，给定的 <code>Future</code> 仍然会完成，即使未返回已完成的值。</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/beeb0951.html"><i class="fas fa-angle-double-right"></i>🎮 Play 入门与学习(二) Action Composition</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-14</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">12 分钟读完 (大约1858个字)</span></div></div><div class="content"><blockquote><p>本章将讲解 Action 的组成和原理,并且介绍了几种定义通用 Action 的方法。</p></blockquote><h2 id="Action-composition"><a href="#Action-composition" class="headerlink" title="Action composition"></a>Action composition</h2><blockquote><p>Action 组成结构</p></blockquote><h3 id="Custom-action-builders"><a href="#Custom-action-builders" class="headerlink" title="Custom action builders"></a>Custom action builders</h3><blockquote><p>自定义 action builders<br>我们有多种方法来声明一个 <code>Action</code>，使用 <code>request</code> 参数,不使用 <code>request</code> 参数, 使用 <code>body parser</code> 等等。实际上，并不止这些，我们将在异步编程一节进行讲述。</p></blockquote><p>这些用于构建 <code>actions</code> 的方法实际上都是由一个名为 <code>ActionBuilder</code> 的 <code>trait</code> 定义的。而我们用来声明 <code>Action</code> 的 <code>Action Object</code> 只是这个 <code>trait</code> 的一个实例。通过实现自己的 <code>ActionBuilder</code>，您可以声明可重用的 <code>action stack</code>，然后可以使用它们来构建 <code>actions</code>。</p><p>让我们从日志修饰符(<code>logging decorator</code>) 的简单示例开始，我们希望记录对 <code>action</code> 的每次调用日志。</p><p>第一种方法是在 <code>invokeBlock</code> 方法中实现这个功能，<code>ActionBuilder</code> 构建的每一个 <code>action</code> 都会调用这个方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingAction</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">parser: <span class="type">BodyParsers</span>.<span class="type">Default</span></span>)(<span class="params">implicit ec: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">ActionBuilderImpl</span>(<span class="params">parser</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>], block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>])=&#123;</span><br><span class="line">    <span class="type">Logger</span>.info(<span class="string">&quot;Calling action&quot;</span>)</span><br><span class="line">    block(request)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以在 <code>controllers</code> 中使用依赖注入来获取 <code>LoggingAction</code> 的一个实例，并且以使用普通 <code>Action</code> 的方式来使用它。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">loggingAction: <span class="type">LoggingAction</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                             cc:<span class="type">ControllerComponents</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AbstractController</span>(<span class="params">cc</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= loggingAction &#123;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since <code>ActionBuilder</code> provides all the different methods of building actions, this also works with, for example, declaring a custom body parser:</p><p>由于 <code>ActionBuilder</code> 提供了创建 <code>actions</code> 所有不同的方法，所以我们也可以在自定义的 <code>Action</code> 中使用 <code>body parser</code> 等普通 <code>Action</code> 的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span> </span>= loggingAction(parse.text) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got a body &quot;</span> + request.body.length + <span class="string">&quot; bytes long&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-actions"><a href="#组合-actions" class="headerlink" title="组合 actions"></a>组合 actions</h3><blockquote><p>Composing actions</p></blockquote><p>在大多数应用程序中,我们希望有多个 <code>action builders</code>, 比如一些做不同类型的 <code>authentication</code>, 一些提供不同类型的通用功能组件,等等。</p><p>在这种情况下,我们不想为每一个 <code>action builder</code> 重写 <code>loggingAction</code>，我们需要定义一个可重用的方式来简化代码。可重用的操作代码可以通过包装操作（<code>wrapping actions</code>）来实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Logging</span>[<span class="type">A</span>](<span class="params">action: <span class="type">Action</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">Action</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(request: <span class="type">Request</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">Result</span>] = &#123;</span><br><span class="line">    <span class="type">Logger</span>.info(<span class="string">&quot;Calling action&quot;</span>)</span><br><span class="line">    action(request)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">parser</span> </span>= action.parser</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">executionContext</span> </span>= action.executionContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can also use the <code>Action</code> action builder to build actions without defining our own action class:</p><p>我们也可以使用 <code>Action</code> action builder 来 创建 <code>actions</code> 而不需要定义我们自己的 <code>action class</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>])= <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  <span class="type">Logger</span>.info(<span class="string">&quot;Calling action&quot;</span>)</span><br><span class="line">  action(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>composeAction</code> 方法将 <code>Action</code> 混合到 <code>action builders</code> 中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingAction</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">parser: <span class="type">BodyParsers</span>.<span class="type">Default</span></span>)(<span class="params">implicit ec: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">ActionBuilderImpl</span>(<span class="params">parser</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>], block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>]) = &#123;</span><br><span class="line">    block(request)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">composeAction</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="keyword">new</span> <span class="type">Logging</span>(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样 <code>code</code> 后使用，效果和之前的例子一样</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= loggingAction &#123;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在不使用 <code>action builder</code> 的情况下将 <code>action</code> 混合到 <code>wrapping actions</code> 中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Logging</span> &#123;</span><br><span class="line">  <span class="type">Action</span> &#123;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="More-complicated-actions"><a href="#More-complicated-actions" class="headerlink" title="More complicated actions"></a>More complicated actions</h3><blockquote><p>更复杂的 Action</p></blockquote><p>到目前为止，我们只展示了完全不会影响请求的 actions。当然，我们也可以对传入的请求对象进行读取和修改。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"><span class="keyword">import</span> play.api.mvc.request.<span class="type">RemoteConnection</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xForwardedFor</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  <span class="keyword">val</span> newRequest = request.headers.get(<span class="string">&quot;X-Forwarded-For&quot;</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; request</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(xff) =&gt;</span><br><span class="line">      <span class="keyword">val</span> xffConnection = <span class="type">RemoteConnection</span>(xff, request.connection.secure, <span class="type">None</span>)</span><br><span class="line">      request.withConnection(xffConnection)</span><br><span class="line">  &#125;</span><br><span class="line">  action(newRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Play already has built in support for <code>X-Forwarded-For</code> headers.</p><p>我们可以 <code>block</code> 请求</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"><span class="keyword">import</span> play.api.mvc.<span class="type">Results</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onlyHttps</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  request.headers.get(<span class="string">&quot;X-Forwarded-Proto&quot;</span>).collect &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;https&quot;</span> =&gt; action(request)</span><br><span class="line">  &#125; getOrElse &#123;</span><br><span class="line">    <span class="type">Future</span>.successful(<span class="type">Forbidden</span>(<span class="string">&quot;Only HTTPS requests allowed&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还能修改返回的结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addUaHeader</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  action(request).map(_.withHeaders(<span class="string">&quot;X-UA-Compatible&quot;</span> -&gt; <span class="string">&quot;Chrome=1&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Different-request-types"><a href="#Different-request-types" class="headerlink" title="Different request types"></a>Different request types</h3><blockquote><p>不同的请求类型</p></blockquote><p>虽然 <code>action composition</code> 允许您在 <code>HTTP</code> request 和 response 级别执行额外的处理，但是您通常希望构建数据转换管道( <code>pipelines</code>)，以便向请求本身添加上下文(<code>context</code>) 或 执行验证(<code>perfom validation</code>)。</p><p><code>ActionFunction</code> 可以看作是作用在 request 上的一个函数，在输入请求类型和传递到下一层的输出类型上都<strong>参数化</strong>。</p><p>每个操作函数都可以表示模块处理，例如身份验证、对象的数据库查找、权限检查或希望跨操作组合和重用的其他操作。</p><p>一些实现了实现 <code>ActionFunction</code> 的预定义的 <code>trait</code> 对于不同类型的处理非常有用。</p><ul><li><code>ActionTransformer</code><ul><li>can change the request, for example by adding additional information.</li><li>可以改变一个请求，例如为此请求添加额外信息等。</li></ul></li><li><code>ActionFilter</code><ul><li>can selectively intercept requests, for example to produce errors, without changing the request value.</li><li>可以选择性的拦截请求，例如在不改变请求的前提下产生一个错误。</li></ul></li><li><code>ActionRefiner</code><ul><li>is the general case of both of the above.</li><li>上面两个 trait 的通用父类(trait)。</li></ul></li><li><code>ActionBuilder</code><ul><li>is the special case of functions that take <code>Request</code> as input, and thus can build actions.</li><li>以 “<code>Request</code>“ 作为输入的函数的一种特殊情况，并且是否可以构建 actions。</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ActionRefiner</span>[-<span class="type">R</span>[_], <span class="title">+P</span>[_]] <span class="keyword">extends</span> <span class="title">ActionFunction</span>[<span class="type">R</span>, <span class="type">P</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 确定怎么处理一个请求，这是继承 ActionRefiner 后需要实现的主方法。</span></span><br><span class="line"><span class="comment">   *	 </span></span><br><span class="line"><span class="comment">   * 它可以决定立即拦截请求并返回结果(Left)，或者继续处理类型为P的新参数(Right)。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return Either a result or a new parameter to pass to the Action block</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">refine</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">Either</span>[<span class="type">Result</span>, <span class="type">P</span>[<span class="type">A</span>]]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>], block: <span class="type">P</span>[<span class="type">A</span>] =&gt; <span class="type">Future</span>[<span class="type">Result</span>]) =</span><br><span class="line">    refine(request).flatMap(_.fold(<span class="type">Future</span>.successful, block))(executionContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ActionFilter</span>[<span class="type">R</span>[_]] <span class="keyword">extends</span> <span class="title">ActionRefiner</span>[<span class="type">R</span>, <span class="type">R</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 确定是否处理请求。这是 ActionFilter 必须实现的主要方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 它可以决定立即拦截请求并返回结果(Some)，或者继续处理(None)。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return An optional Result with which to abort the request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">Option</span>[<span class="type">Result</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">refine</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]) =</span><br><span class="line">    filter(request).map(_.toLeft(request))(executionContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ActionTransformer</span>[-<span class="type">R</span>[_], <span class="title">+P</span>[_]] <span class="keyword">extends</span> <span class="title">ActionRefiner</span>[<span class="type">R</span>, <span class="type">P</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *扩展或转换现有请求。这是ActionTransformer必须实现的主要方法</span></span><br><span class="line"><span class="comment">   * @return The new parameter to pass to the Action block</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">P</span>[<span class="type">A</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">refine</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]) =</span><br><span class="line">    transform(request).map(<span class="type">Right</span>(_))(executionContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以通过实现 <code>invokeBlock</code> 方法定义自己的 <code>ActionFunction</code>。这样通常可以方便地创建请求的输入和输出类型实例(使用 <code>WrappedRequest</code>)，但这并不是严格必需的。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><blockquote><p><code>action functions</code> 最常见的用例之一是身份验证。我们可以很容易地实现我们自己的身份验证操作转换器，它从原始请求确定用户并将其添加到新的 <code>UserRequest</code>。注意，这也是一个 <code>ActionBuilder</code>，因为它接受一个简单的请求作为输入</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRequest</span>[<span class="type">A</span>](<span class="params">val username: <span class="type">Option</span>[<span class="type">String</span>], request: <span class="type">Request</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">WrappedRequest</span>[<span class="type">A</span>](<span class="params">request</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UserAction</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">val parser: <span class="type">BodyParsers</span>.<span class="type">Default</span></span>)(<span class="params">implicit val executionContext: <span class="type">ExecutionContext</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ActionBuilder</span>[<span class="type">UserRequest</span>, <span class="type">AnyContent</span>] <span class="keyword">with</span> <span class="title">ActionTransformer</span>[<span class="type">Request</span>, <span class="type">UserRequest</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>]) = <span class="type">Future</span>.successful &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">UserRequest</span>(request.session.get(<span class="string">&quot;username&quot;</span>), request)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的 <code>authentication action builder</code> 只是一个方便的帮助程序，它可以最小化实现简单情况下身份验证所需的代码，其实现与上面的示例非常相似。</p><p>由于编写自己的身份验证帮助程序很简单，所以如果内置的帮助程序不适合您的需要，我们建议这样做。</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/468029a2.html"><i class="fas fa-angle-double-right"></i>🎮 Play 入门与学习(一) Controller &amp; Router &amp; BodyParser</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">24 分钟读完 (大约3592个字)</span></div></div><div class="content"><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">cc: <span class="type">ControllerComponents</span></span>) <span class="keyword">extends</span> <span class="title">AbstractController</span>(<span class="params">cc</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.index())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">explore</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.explore())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tutorial</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.tutorial())</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>conf</code> 目录下配置 <code>routes</code> 文件，对请求url 进行映射到 <code>controllers</code>，和 <code>springmvc</code> 的 <code>@RequestMapping</code> 很类似。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Routes</span></span><br><span class="line"><span class="comment"># This file defines all application routes (Higher priority routes first)</span></span><br><span class="line"><span class="comment"># https://www.playframework.com/documentation/latest/ScalaRouting</span></span><br><span class="line"><span class="comment"># ~~~~</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># An example controller showing a sample home page</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/                    controllers.HomeController.index</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/explore             controllers.HomeController.explore</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/tutorial            controllers.HomeController.tutorial</span></span><br></pre></td></tr></table></figure><p>通过上述配置之后，我们就可以通过 url 访问到具体的 请求方法了。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>每一个请求是被一个 Action 进行处理了，处理之后返回 Results</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>常见的 <code>results</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Got request [&quot;</span> + request + <span class="string">&quot;]&quot;</span>)</span><br></pre></td></tr></table></figure><p>重定向到另一个 <code>url</code> 对应的 <code>Action</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Redirect</span>(<span class="string">&quot;/echo&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>mark</code> 方法还没有完成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">todo</span></span>() = <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>自定义 <code>Result</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Result</span>(</span><br><span class="line">  header = <span class="type">ResponseHeader</span>(<span class="number">200</span>, <span class="type">Map</span>.empty),</span><br><span class="line">  body = <span class="type">HttpEntity</span>.<span class="type">Strict</span>(<span class="type">ByteString</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="type">Some</span>(<span class="string">&quot;text/plain&quot;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Http-Routing"><a href="#Http-Routing" class="headerlink" title="Http Routing"></a>Http Routing</h2><blockquote><p>所有路由信息将定义在 <code>conf/routes</code> 文件下,前文有提及到。<code>router</code> 是负责将每个传入 <code>HTTP</code> 请求转换为 <code>Action</code> 的组件。</p></blockquote><p>每一个 <code>Http</code> 请求被 Play MVC Framework 认为是一个事件。每个请求包含两条主要信息：</p><ul><li>请求路径，restful 风格</li><li>http 请求方法，类似 Get、Post、Delete、Put 等</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>conf/routes</code> 是 <code>router</code> 使用的配置文件。该文件列出了应用程序所需的所有 <code>routes</code>。每个路由由一个 <code>HTTP</code> 方法和 <code>URI</code> 模式组成，它们都与 <code>Action</code> 的调用相关联。</p><p>让我们看看路由定义是什么样的:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br></pre></td></tr></table></figure><p>通过 <code>-&gt;</code> 来使用不同的路由规则</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>      <span class="string">/api                        api.MyRouter</span></span><br></pre></td></tr></table></figure><p>当与字符串插值路由DSL(也称为SIRD路由)结合使用时，或者在处理使用多个路由文件路由的子项目时，这一点尤其有用。</p><p>通过 <code>nocsrf</code> 来禁用 <code>CSRF filter</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">+</span> <span class="string">nocsrf</span></span><br><span class="line"><span class="attr">POST</span>  <span class="string">/api/new              controllers.Api.newThing</span></span><br></pre></td></tr></table></figure><p>URL规则:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态 path</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/all          controllers.Clients.list()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态 path</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则匹配模式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/files/*name          controllers.Application.download(name)</span></span><br></pre></td></tr></table></figure><p>逆向、反转 routing</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Redirect(routes.HelloController.echo())</span></span><br></pre></td></tr></table></figure><h2 id="操作处理结果返回"><a href="#操作处理结果返回" class="headerlink" title="操作处理结果返回"></a>操作处理结果返回</h2><p>结果内容类型自动从您指定作为响应体的Scala值推断出来。</p><p>通过 <code>play.api.http.ContentTypeOf</code> 来实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Will automatically set the Content-Type header to text/plain, while:</span></span><br><span class="line"><span class="keyword">val</span> textResult = <span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//will set the Content-Type header to application/xml.</span></span><br><span class="line"><span class="keyword">val</span> xmlResult = <span class="type">Ok</span>(&lt;message&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/message&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己定义返回类型</span></span><br><span class="line"><span class="keyword">val</span> htmlResult = <span class="type">Ok</span>(&lt;h1&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/h1&gt;).as(<span class="string">&quot;text/html&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> htmlResult2 = <span class="type">Ok</span>(&lt;h1&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/h1&gt;).as(<span class="type">HTML</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Manipulating-Http-headers-操纵-Http-头"><a href="#Manipulating-Http-headers-操纵-Http-头" class="headerlink" title="Manipulating Http headers (操纵 Http 头)"></a>Manipulating Http headers (操纵 Http 头)</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加返回头信息</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>).withHeaders(<span class="type">CACHE_CONTROL</span> -&gt; <span class="string">&quot;max-age=3600&quot;</span>,<span class="type">ETAG</span> -&gt; <span class="string">&quot;xx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Session-and-Flash"><a href="#Session-and-Flash" class="headerlink" title="Session and Flash"></a>Session and Flash</h2><blockquote><p>存储在 session 中的数据在整个会话期间都是可用的，存储在 flash 作用域的数据只对下一个请求可用。</p><p>需要注意，session 和 flash 的数据不是由服务器存储的，而是使用 cookie 机制添加到每个后续 http 请求中的。这意味着数据大小将非常有限(up to 4kb),并且只能存储字符串值。 cookie 的默认名称是 <code>PLAY_SESSION</code>。这可以在 <code>application.conf</code> 通过配置 key <code>play.http.session</code> 来更改。</p></blockquote><h3 id="Session-存储"><a href="#Session-存储" class="headerlink" title="Session 存储"></a>Session 存储</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这会将 session 完全替换掉</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Welcome!&quot;</span>).withSession(<span class="string">&quot;connected&quot;</span> -&gt; <span class="string">&quot;user@gmail.com&quot;</span>)</span><br><span class="line"><span class="comment">//在现有session 基础上添加 element 内容即可</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>).withSession(request.session + (<span class="string">&quot;saidHello&quot;</span> -&gt; <span class="string">&quot;yes&quot;</span>))</span><br><span class="line"><span class="comment">//通过key remove 部分内容</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Theme reset!&quot;</span>).withSession(request.session - <span class="string">&quot;theme&quot;</span>)</span><br></pre></td></tr></table></figure><p>读取 <code>Session</code> 内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span> &#123; request =&gt;</span><br><span class="line">  request.session.get(<span class="string">&quot;connected&quot;</span>).map &#123; user =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Hello &quot;</span> + user)</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    <span class="type">Unauthorized</span>(<span class="string">&quot;Oops, you are not connected&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>丢弃整个 <code>Session</code> 内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Bye&quot;</span>).withNewSession</span><br></pre></td></tr></table></figure><h3 id="Flash-Scope-Flash作用域"><a href="#Flash-Scope-Flash作用域" class="headerlink" title="Flash Scope (Flash作用域)"></a>Flash Scope (<code>Flash</code>作用域)</h3><blockquote><p>flash scope 和 session 作用很像，但是有两个区别</p></blockquote><ul><li>data are kept for only one request</li><li>the Flash cookie is not signed, making it possible for the user to modify it.</li></ul><p>session 的 cookie 会进行加密，而 flash 的 cookie 不会进行加密。</p><p><code>Flash作用域</code> 应该只用于在简单的 <code>非ajax</code> 应用程序上传输 成功/错误消息。由于数据只是为下一个请求保存的，而且在复杂的 <code>Web</code> 应用程序中不能保证请求顺序，所以 <code>Flash作用域</code> 受竞态条件的限制。(the Flash scope is subject to race conditions.)</p><h3 id="code-using-flash-scope"><a href="#code-using-flash-scope" class="headerlink" title="code using flash scope"></a>code using flash scope</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request =&gt;</span><br><span class="line">  <span class="type">Ok</span> &#123;</span><br><span class="line">    request.flash.get(<span class="string">&quot;success&quot;</span>).getOrElse(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span> &#123;</span><br><span class="line">  <span class="type">Redirect</span>(<span class="string">&quot;/home&quot;</span>).flashing(<span class="string">&quot;success&quot;</span> -&gt; <span class="string">&quot;The item has been created&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To retrieve the Flash scope value in your view, add an implicit Flash parameter</p><p>要在视图中检索Flash作用域值，请添加一个隐式Flash参数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@()(<span class="keyword">implicit</span> flash: <span class="type">Flash</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">@flash</span>.get(<span class="string">&quot;success&quot;</span>).getOrElse(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="请求体解析-Body-Parsers"><a href="#请求体解析-Body-Parsers" class="headerlink" title="请求体解析 Body Parsers"></a>请求体解析 Body Parsers</h2><blockquote><p>什么是 body parsers</p></blockquote><p><code>HTTP请求</code> 是header 后面跟着 body。header 通常很小——它可以安全地缓冲在内存中，因此在 <code>Play</code> 中它是使用<code>RequestHeader</code> 类建模的。</p><p>然而，<code>body</code> 可能非常长，因此不在内存中缓冲，而是建模为流。然而，许多请求体有效负载 (<code>payloads</code>) 都很小，并且可以在内存中建模，因此为了将 <code>body流</code> 映射到内存中的对象，<code>Play</code> 提供了一个<code>BodyParser</code> 抽象。</p><p>由于 <code>Play</code> 是一个异步框架，传统的 <code>InputStream</code> 不能用于读取请求体——输入流阻塞了，当您调用 <code>read</code> 时，调用它的线程必须等待数据可用。</p><p>相反，<code>Play</code> 使用一个名为 <code>Akka Streams</code> 的异步流库。<strong>Akka Streams</strong> 是 <strong>Reactive Streams</strong> 的一个实现。</p><p>允许许多异步流api 无缝地协同工作,所以尽管传统 <code>InputStream</code> 的基础技术不适合使用, 但是<code>Akka Streams</code> 和 <code>Reactive Streams</code> 的整个生态系统的异步库将为你提供你需要的一切。</p><h3 id="使用-Body-Parsers"><a href="#使用-Body-Parsers" class="headerlink" title="使用 Body Parsers"></a>使用 Body Parsers</h3><blockquote><p>如果没有显式选择 <code>body parser</code>，<code>Play</code> 将使用的缺省的 <code>body parser</code> 将查看传入的 <code>Content-Type</code>，并相应地解析body。</p><p>例如，类型 <code>application/json</code> 的内容类型将被解析为 <code>JsValue</code>，而类型 <code>application/x-www-form- urlencoding</code> 的内容类型将被解析为 <code>Map[String, Seq[String]]</code></p></blockquote><p>默认的 <code>Body Parser</code> 生成 <code>AnyContent</code> 类型的 <code>Body</code>。<code>AnyContent</code> 支持的各种类型, 可以通过 <code>as方法</code> 访问，例如 <code>asJson</code>，它返回一个 Option[body类型]</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span> &#123; request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">  <span class="keyword">val</span> body: <span class="type">AnyContent</span> = request.body</span><br><span class="line">  <span class="keyword">val</span> jsonBody: <span class="type">Option</span>[<span class="type">JsValue</span>] = body.asJson</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Expecting json body</span></span><br><span class="line">  jsonBody.map &#123; json =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (json \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    <span class="type">BadRequest</span>(<span class="string">&quot;Expecting application/json request body&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是默认 <code>body parser</code> 支持的类型映射 (<code>The following is a mapping of types supported by the default body parser</code>)</p><ul><li><strong>text/plain</strong>: <code>String</code>, accessible via <code>asText</code>.</li><li><strong>application/json</strong>: <a target="_blank" rel="noopener" href="https://static.javadoc.io/com.typesafe.play/play-json_2.12/2.6.9/play/api/libs/json/JsValue.html"><code>JsValue</code></a>, accessible via <code>asJson</code>.</li><li><strong>application/xml</strong>, <strong>text/xml</strong> or <strong>application/XXX+xml</strong>: <code>scala.xml.NodeSeq</code>, accessible via <code>asXml</code>.</li><li><strong>application/x-www-form-urlencoded</strong>: <code>Map[String, Seq[String]]</code>, accessible via <code>asFormUrlEncoded</code>.</li><li><strong>multipart/form-data</strong>: <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/api/scala/play/api/mvc/MultipartFormData.html"><code>MultipartFormData</code></a>, accessible via <code>asMultipartFormData</code>.</li><li>Any other content type: <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/api/scala/play/api/mvc/RawBuffer.html"><code>RawBuffer</code></a>, accessible via <code>asRaw</code>.</li></ul><p>默认的 body parser 在解析之前会 <code>try to determine</code> 请求是否具有 <code>body</code>。</p><p>根据 <code>HTTP</code> 规范(spec)，内容长度(Content-Length) 或 传输编码标头(Transfer-Encoding) 的出现都表示主体的存在，因此解析器只在出现其中一个标头时进行解析，或者在显式设置非空主体时在 FakeRequest 上进行解析。</p><p>如果希望在所有情况下解析主体，可以使用下面描述的anyContent主体解析器。</p><h3 id="显示的选择一个-Body-Parser"><a href="#显示的选择一个-Body-Parser" class="headerlink" title="显示的选择一个 Body Parser"></a>显示的选择一个 Body Parser</h3><p>如果希望显式地选择主体解析器，可以将 body parser 传递给 Action 的 apply或 async 方法。</p><p>Play 提供了许多开箱即用的 body parser (<code>Play provides a number of body parsers out of the box</code>)，</p><p>这是通过 <code>PlayBodyParsers</code> trait 提供的，它可以注入到您的控制器中。</p><p>例子，如果要定义一个 request body 期望是 Json Body 的 Action</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不是 Json类型会返回 415 Unsupported Media Type , 类似 Springmvc 在参数前面加 @RequestBody</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.json) &#123; request: <span class="type">Request</span>[<span class="type">JsValue</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (request.body \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述 body 的类型为 <code>JsValue</code>, 它不是 <code>Option</code> 类型的了。原因是 json body parser 会验证请求是否具有 <code>application/json</code> 的 <code>Content-Type</code>，如果不是，则会返回 415 的错误，即 <code>415 Unsupported Media Type</code>,这样我们就不用再次检查了。</p><p>这样依赖，这个方法将要对请求的type 有严格的限制了，客户端要清楚这一点。如果希望有更宽松的做法，即不是 ``application/json<code>类型的</code>Content-Type` 也能够进行解析，可以使用如下方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会返回 415，会尝试进行解析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.tolerantJson) &#123; request: <span class="type">Request</span>[<span class="type">JsValue</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (request.body \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子，保存文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.file(to = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;/tmp/upload&quot;</span>))) &#123; request: <span class="type">Request</span>[<span class="type">File</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-Body-Parsers-Combining-body-parsers"><a href="#组合-Body-Parsers-Combining-body-parsers" class="headerlink" title="组合 Body Parsers (Combining body parsers)"></a>组合 Body Parsers (Combining body parsers)</h3><p>在上一个保存文件的示例中，所有请求 bodies 都存储在同一个文件中 (<code>/tmp/upload</code>)，这是存在问题的。</p><p>我们可以编写另一个自定义主体解析器，它从请求会话中提取用户名，为每个用户提供一个惟一的文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> storeInUserFile: <span class="type">BodyParser</span>[<span class="type">File</span>] = parse.using &#123; request =&gt;</span><br><span class="line">  request.session.get(<span class="string">&quot;username&quot;</span>).map &#123; user =&gt;</span><br><span class="line">    parse.file(to = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;/tmp/&quot;</span> + user + <span class="string">&quot;.upload&quot;</span>))</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    sys.error(<span class="string">&quot;You don&#x27;t have the right to upload here&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义 body parser</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span></span>: <span class="type">Action</span>[<span class="type">File</span>] = <span class="type">Action</span>(storeInUserFile) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们并没有真正编写自己的 <code>BodyParser</code>，而只是组合现有的 <code>BodyParser</code>。这通常就足够了，应该涵盖大多数用例。高级主题部分将介绍从头编写 <code>BodyParser</code></p><h3 id="Max-content-length"><a href="#Max-content-length" class="headerlink" title="Max content length"></a>Max content length</h3><p>基于文本的 body parsers (例如 text、json、xml 或 formurlencoding) 需要有一个最大内容长度。因为它们必须将所有内容加载到内存中。默认情况下，它们将解析的最大内容长度是 <code>100KB</code>。可以通过指定 <code>play.http.parser</code> 来覆盖它。可以通过在 <code>application.conf</code> 指定 <code>maxMemoryBuffer</code>属性来改变这个大小。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.conf</span></span><br><span class="line"><span class="meta">play.http.parser.maxMemoryBuffer</span>=<span class="string">128K</span></span><br></pre></td></tr></table></figure><p>对于将内容缓冲 (<code>buffer</code>) 到磁盘上的 body parser，例如 <code>raw parser</code> 或 <code>multipart/form-data</code> 等，它们的最大内容长度使用 <code>play.http.parser</code> 的 <code>maxDiskBuffer</code> 来进行指定。</p><p><code>maxDiskBuffer</code>属性，默认值为<code>10MB</code>。<code>multipart/form-data</code> 解析器还强制为数据字段的聚合设置文本最大长度属性。</p><p>您还可以通过在 <code>Action</code> 中显示指定来覆盖默认的最大长度。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept only 10KB of data.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.text(maxLength = <span class="number">1024</span> * <span class="number">10</span>)) &#123; request: <span class="type">Request</span>[<span class="type">String</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can also wrap any body parser with <code>maxLength</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept only 10KB of data.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.maxLength(<span class="number">1024</span> * <span class="number">10</span>, storeInUserFile)) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Writing-a-custom-body-parser"><a href="#Writing-a-custom-body-parser" class="headerlink" title="Writing a custom body parser"></a>Writing a custom body parser</h3><blockquote><p>我们可以实现 <code>BodyParser</code> 特质来自定义 body parser，这个 trait 是一个很简单的函数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BodyParser</span>[+<span class="type">A</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">RequestHeader</span> =&gt; <span class="type">Accumulator</span>[<span class="type">ByteString</span>, <span class="type">Either</span>[<span class="type">Result</span>, <span class="type">A</span>]]</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p>接收一个 <code>RequestHeader</code>，这样我们可以检查关于请求的信息，它通常用于获取 Content-Type,这样 body 就会被正确的解析。</p></li><li><p>函数的返回类型是 <code>Accumulator</code>，它是一个累加器。<code>Accumulator</code> 是 围绕 <code>Akka Streams Sink</code> 的一层薄层。<code>Accumulator</code> 异步地将 <code>streams of elements</code> 加到结果中，它可以通过传入 <code>Akka Streams Source</code> 来运行。这将返回一个 <code>Future</code>，并且在累加器完成时，<code>future</code>得到完成。</p></li><li><p><code>Accumulator</code> 本质上和 Sink[E,Future[A]] 一样，事实上，Accumulator 是 Sink 的一个包装器。但是最大的区别是 Accumulator 提供了方便的方法，比如 map、mapFuture、recover 等等。</p></li><li><p><code>Accumulator</code> 用于将结果作为一个 <code>promise</code> 来处理，其中 Sink 要求将所有的操作包装在 mapMaterializedValue 的调用中。</p></li><li><p>Accumulator 的 apply 返回 ByteString 类型的元素，这些元素本质上是字节数组，但与 byte[] 不同的是，<code>ByteString</code> 是不可变的，它的许多操作(如 slicing 或者 appending) 都是在固定的时间内完成的。</p></li></ul><p><code>Accumulator</code> 的返回类型是 <code>Either[Result, A]</code>，它要么返回一个 <code>Result</code>，要么返回一个类型 <code>A</code>。通常在发生错误的情况下返回 <code>Result</code>。例如，如果 body 解析失败，比如 Content-Type 与 Body Parser 接受的类型不匹配，或者内存缓冲区溢出了。当 <code>body parser</code> 返回一个 <code>result</code> 时，这将缩短 <code>action</code> 的处理时间，<code>action</code> 的结果将里脊返回，并且永远不会调用该操作。</p><h4 id="将-Body-引向别处-Directing-the-body-elsewhere"><a href="#将-Body-引向别处-Directing-the-body-elsewhere" class="headerlink" title="将 Body 引向别处 Directing the body elsewhere"></a>将 Body 引向别处 Directing the body elsewhere</h4><blockquote><p>编写 body parser 的一个常见用例是，当您实际上不想解析主体时，而是想将它以流的形式引入到其他地方(<code>stream it elsewhere</code>)。为此，您可以定义一个自定义 body parser</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.streams._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.ws._</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span></span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">ByteString</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyController</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">ws: <span class="type">WSClient</span>, val controllerComponents: <span class="type">ControllerComponents</span></span>)(<span class="params">implicit ec: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span></span>(request: <span class="type">WSRequest</span>): <span class="type">BodyParser</span>[<span class="type">WSResponse</span>] = <span class="type">BodyParser</span> &#123; req =&gt;</span><br><span class="line">    <span class="type">Accumulator</span>.source[<span class="type">ByteString</span>].mapFuture &#123; source =&gt;</span><br><span class="line">      request</span><br><span class="line">    	.withBody(source)</span><br><span class="line">        .execute()</span><br><span class="line">        .map(<span class="type">Right</span>.apply)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myAction</span> </span>= <span class="type">Action</span>(forward(ws.url(<span class="string">&quot;https://example.com&quot;</span>))) &#123; req =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Uploaded&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Akka-Streams-进行自定义的解析"><a href="#使用-Akka-Streams-进行自定义的解析" class="headerlink" title="使用 Akka Streams 进行自定义的解析"></a>使用 Akka Streams 进行自定义的解析</h4><blockquote><p>Custom parsing using Akka Streams</p></blockquote><p>在很少的情况下，可能需要使用 <code>Akka Streams</code> 编写自定义解析器。在大多数情况下，先用 <code>ByteString</code> 缓冲 body 就足够了，这通常提供一种简单得多的解析方法，因为您可以对主体使用强制方法和随机访问。</p><p>但是，当这不可行时，例如需要解析的主体太长而无法装入内存时，则可能需要编写自定义主体解析器。</p><p>关于如何使用 <code>Akka Streams</code> 的完整描述超出了本文档的范围——最好从阅读 <code>Akka Streams</code> 文档开始。但是，下面显示了一个 <code>CSV</code> 解析器，它基于<code>Akka Streams</code> 烹饪书中 <code>ByteStrings</code> 文档流的解析行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc.<span class="type">BodyParser</span></span><br><span class="line"><span class="keyword">import</span> play.api.libs.streams._</span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">ByteString</span></span><br><span class="line"><span class="keyword">import</span> akka.stream.scaladsl._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> csv: <span class="type">BodyParser</span>[<span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">String</span>]]] = <span class="type">BodyParser</span> &#123; req =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A flow that splits the stream into CSV lines</span></span><br><span class="line">  <span class="keyword">val</span> sink: <span class="type">Sink</span>[<span class="type">ByteString</span>, <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">String</span>]]]] = <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">    <span class="comment">//我们按照 new line character 进行分割，每行最多允许 1000个字符。</span></span><br><span class="line">    .via(<span class="type">Framing</span>.delimiter(<span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>), <span class="number">1000</span>, allowTruncation = <span class="literal">true</span>))</span><br><span class="line">    <span class="comment">//把每一行变成一个String，用逗号分隔</span></span><br><span class="line">    .map(_.utf8String.trim.split(<span class="string">&quot;,&quot;</span>).toSeq)</span><br><span class="line">    <span class="comment">// 现在我们使用 fold 将其变为一个列表 List</span></span><br><span class="line">    .toMat(<span class="type">Sink</span>.fold(<span class="type">Seq</span>.empty[<span class="type">Seq</span>[<span class="type">String</span>]])(_ :+ _))(<span class="type">Keep</span>.right)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 body 转为为 Either right 返回</span></span><br><span class="line">  <span class="type">Accumulator</span>(sink).map(<span class="type">Right</span>.apply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/2ed76eda.html"><i class="fas fa-angle-double-right"></i>从示例逐渐理解Scala隐式转换</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-11-18</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">16 分钟读完 (大约2379个字)</span></div></div><div class="content"><blockquote><p>隐式转换和隐式参数是 <code>Scala</code> 的两个功能强大的工具。隐式转换可以丰富现有类的功能，隐式对象是如何被自动呼出以用于执行转换或其他任务的。利用这两点，我们可以提供优雅的类库。</p></blockquote><p>本文将通过几个示例代码来整体学习一下 <code>Scala</code> 隐式转换的四个特性和运用。它们分别是 隐式函数运用、隐式类扩展运用、隐式参数、类型类(<code>Type class</code>)运用。</p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><blockquote><p>implicit conversion function：指的是那种以 <code>implicit</code> 关键字声明的带有单个参数的函数。这样的函数将被自动应用，将值从一种类型转换为另一种类型。</p></blockquote><h3 id="隐式函数-implicit-def"><a href="#隐式函数-implicit-def" class="headerlink" title="隐式函数 implicit def"></a>隐式函数 implicit def</h3><p>定义一个 <code>case class</code> 类 <code>Multiply</code>，并定义一个方法 <code>multiply</code> ，接收一个当前对象，并将值相乘后返回。<br>定义隐式转换函数 <code>int2Multiply</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span>(<span class="params">m: <span class="type">Int</span>, n: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(other: <span class="type">Multiply</span>): <span class="type">Multiply</span> = &#123;</span><br><span class="line">        <span class="type">Multiply</span>(other.m * m, other.n * n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyImplicit</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义隐式转换函数，参数单个，将 int 隐式转换为 Multiply 对象</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类 <code>MultiplyMain</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//导入隐式转换方法（局部引用可以避免不想要的隐式转换发生）</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> x: <span class="type">Multiply</span> = <span class="number">3.</span>multiply(<span class="type">Multiply</span>(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(x.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行程序结果如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结果为：Multiply(6,2)</span><br><span class="line">&#x2F;&#x2F;计算过程，3 隐式转换为 Multiply(3, 2)</span><br><span class="line">3 &#x3D;&gt; Multiply(3, 2)</span><br><span class="line">&#x2F;&#x2F;调用multiply计算</span><br><span class="line">Multiply(3, 2).multiply(Multiply(2, 1)) &#x3D;Multiply( 3*2 , 2*1 )</span><br></pre></td></tr></table></figure>如果我们提供多个隐式转换函数<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyImplicit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">2</span>)</span><br><span class="line">  <span class="comment">//提供第二个隐式转换函数</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply2</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在 <code>Main</code> 中，我们可以通过两种方式进行指定具体使用哪个隐式转换函数。<br>比如我们选择使用 <code>int2Multiply</code>的隐式转换<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//方法1: 排除 int2Multiply2 方法，引入其余所有的方法</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>.&#123;int2Multiply2 ⇒ _, _&#125;</span><br><span class="line"> <span class="comment">// 方法2: 精确引入</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>.int2Multiply</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> x: <span class="type">Multiply</span> = <span class="number">3.</span>multiply(<span class="type">Multiply</span>(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(x.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式类，丰富现有类库功能"><a href="#隐式类，丰富现有类库功能" class="headerlink" title="隐式类，丰富现有类库功能"></a>隐式类，丰富现有类库功能</h3><blockquote><p>你是否希望某个类拥有新的方法，而此方法该类并没有提供，那么隐式转换可以丰富这个类，给它提供更多的方法</p></blockquote></li></ul><p>例如数据库连接类 <code>Connection</code>, 我们希望给它新增一个 <code>executeUpdate</code> 方法来对数据进行修改，例子如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.maple.implic.two</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.<span class="type">Connection</span></span><br><span class="line"><span class="keyword">import</span> scala.language.implicitConversions</span><br><span class="line"><span class="comment">//隐式类，Rich表示对Connection的增强类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichConnection</span>(<span class="params">conn: <span class="type">Connection</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//定义的新方法 executeUpdate，对数据操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">executeUpdate</span></span>(sql: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    conn.prepareStatement(sql).executeUpdate()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供隐式转换 func 来将原有类型转换为Rich 类型</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichConnection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">executeUpdate</span></span>(connection: <span class="type">Connection</span>) = <span class="keyword">new</span> <span class="type">RichConnection</span>(connection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConnectionMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引入隐式转换 func</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.two.<span class="type">RichConnection</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//定义 dataSource</span></span><br><span class="line">    <span class="keyword">val</span> ds: <span class="type">DataSource</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> ds = <span class="keyword">new</span> <span class="type">MysqlDataSource</span></span><br><span class="line">      ds.setURL(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/maple?useUnicode=true&amp;characterEncoding=utf8&quot;</span>)</span><br><span class="line">      ds.setUser(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">      ds.setPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">      ds</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取 conn</span></span><br><span class="line">    <span class="keyword">val</span> connection = ds.getConnection</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    connection.executeUpdate(<span class="string">&quot;UPDATE t_user SET name = &#x27;maple&#x27; WHERE id = 1&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面通过定义一个 <code>RichConnection</code> 我们可以增强现有类 <code>Connection</code> 的功能。这样一来，通过 <code>connection</code> 对数据库进行增删改查，可以简化大量代码。</p><h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><blockquote><p>函数或方法可以带有一个标记为 <code>implicit</code> 的参数列表。在这种情况下，编译器将会查找默认值，提供给本次函数调用。</p></blockquote><h3 id="利用隐式参数进行隐式转换"><a href="#利用隐式参数进行隐式转换" class="headerlink" title="利用隐式参数进行隐式转换"></a>利用隐式参数进行隐式转换</h3><blockquote><p>隐式的函数参数也可以被用作隐式转换。如果我们定义一个泛型函数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">larger</span></span>[<span class="type">T</span>](x: <span class="type">T</span>, y: <span class="type">T</span>) = <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><h2><a href="#" class="headerlink"></a><img src="https://upload-images.jianshu.io/upload_images/6393906-98ae4bd56e64e4de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="ex.png"></h2><p>关于隐式参数的另一件事是，它们可能最常用于提供有关在早期参数列表中显式提到的类型的信息，类似于Haskell的类型类。作为示例，请考虑清单21.2中所示的maxListUpBound函数，该函数返回传递列表的最大元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxListUpBound</span></span>[<span class="type">T</span> &lt;: <span class="type">Ordered</span>[<span class="type">T</span>]](elements: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">    elements <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;empty list!&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">      <span class="keyword">case</span> x :: rest =&gt;</span><br><span class="line">        <span class="keyword">val</span> maxRest = maxListUpBound(rest)</span><br><span class="line">        <span class="keyword">if</span> (x &gt; maxRest) x</span><br><span class="line">        <span class="keyword">else</span> maxRest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>maxListUpBound</code> 表示传入一个 <code>List</code>，然后返回 <code>list</code> 中最大的一个元素。功能简单，但是用法十分限制，该List中的成员必须是 <code>Ordered[T]</code> 的子类，否则就会报错。比如我们运行如下例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParameterMain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.three.<span class="type">ImplicitParameter</span>._</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = maxListUpBound(<span class="type">List</span>[<span class="type">Integer</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    println(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们运行 <code>main</code> 函数时，编译器会报如下错。意思是 <code>Int</code> 不是 <code>Ordered[T]</code> 子类，因此无法使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error:(49, 18) inferred type arguments [Int] do not conform to method maxListUpBound&#39;s type parameter bounds [T &lt;: Ordered[T]]</span><br><span class="line">    val result &#x3D; maxListUpBound(List[Int](1, 2, 3))</span><br><span class="line">Error:(49, 42) type mismatch;</span><br><span class="line"> found   : List[Int]</span><br><span class="line"> required: List[T]</span><br><span class="line">    val result &#x3D; maxListUpBound(List[Int](1, 2, 3))</span><br></pre></td></tr></table></figure><h4 id="使用隐式参数优化"><a href="#使用隐式参数优化" class="headerlink" title="使用隐式参数优化"></a>使用隐式参数优化</h4><blockquote><p>如果让 <code>maxListUpBound</code> 更通用，我们需要分离这个函数，增加一个参数，来将 <code>T</code> 转换为 <code>Ordered[T]</code>，使用隐式参数 <code>implicit orders: T ⇒ Ordered[T]</code>来做到这一点。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxListUpBound2</span></span>[<span class="type">T</span>](elements: <span class="type">List</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> orders: <span class="type">T</span> ⇒ <span class="type">Ordered</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">    elements <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;empty list!&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">      <span class="keyword">case</span> x :: rest =&gt;</span><br><span class="line">        <span class="keyword">val</span> maxRest = maxListUpBound2(rest)</span><br><span class="line">        <span class="keyword">if</span> (x &gt; maxRest) x</span><br><span class="line">        <span class="keyword">else</span> maxRest</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.three.<span class="type">ImplicitParameter</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = maxListUpBound2(<span class="type">List</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为3，并没有报错。这其中编译器是将 <code>Int</code> 转换为了 <code>Ordered[Int]</code></p><h3 id="类型类-type-class"><a href="#类型类-type-class" class="headerlink" title="类型类(type class)"></a>类型类(type class)</h3><blockquote><p>让某个类拥有某个算法，我们无需修改这个类，提供一个隐式转换即可。这种做法相对于面向对象的继承扩展来的更灵活。</p></blockquote><p>看下面两个例子，<code>Ordering</code> 是 <code>Scala</code> 提供的类型类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Implicits</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedExt</span>[<span class="type">T</span>: <span class="type">Ordering</span>](<span class="params">v: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">between</span></span>(min: <span class="type">T</span>, max: <span class="type">T</span>) = &#123;</span><br><span class="line">        <span class="keyword">val</span> ordering = implicitly[<span class="type">Ordering</span>[<span class="type">T</span>]]</span><br><span class="line">        ordering.lteq(min, v) &amp;&amp; ordering.lteq(v, max)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedExt2</span>[<span class="type">T</span>](<span class="params">v: <span class="type">T</span></span>)(<span class="params">implicit ordering: <span class="type">Ordering</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">between2</span></span>(min: <span class="type">T</span>, max: <span class="type">T</span>) = &#123;</span><br><span class="line">      ordering.lteq(min, v) &amp;&amp; ordering.lteq(v, max)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用，上面两种写法都可以达到相同的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.<span class="type">Implicits</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> isBetween = <span class="number">10.</span>between(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> isBetween2 = <span class="number">30.</span>between2(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">    println(isBetween)</span><br><span class="line">    println(isBetween2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ordering</code> 这样的特质(<code>trait</code>) 被称为类型类(<code>type class</code>，源自 <code>Haskell</code>) 。类型类定义了某种行为，任何类型都可以通过提供相应的行为来加入这个类。这个类是因为共用的目的而组合在一起的类型。</p><h3 id="自定义类型类"><a href="#自定义类型类" class="headerlink" title="自定义类型类"></a>自定义类型类</h3><blockquote><p><code>Scala</code> 标准类库提供了不少类型类。比如 <code>Equiv</code>、<code>Numeric</code>、<code>Fractional</code>、<code>Hashing</code>、<code>IsTraverableOne</code>、<code>IsTraverableLike</code> 等。我们通过自定义一个类型 <code>CustomOperation</code> 来更深入的学习。</p></blockquote><p><strong>定义特质 <code>CustomOperation</code></strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CustomOperation</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 加操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="comment">// 乘操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在伴生对象中给 String 类型扩展基于 <code>CustomOperation</code> 的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CustomOperation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">StringCustomOperation</span> <span class="keyword">extends</span> <span class="title">CustomOperation</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + <span class="string">&quot;*&quot;</span> + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义隐式类,对 `String` 进行增强</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomImplicitClass</span>[<span class="type">T</span>: <span class="type">CustomOperation</span>](<span class="params">v: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">      <span class="comment">//从冥界召唤的CustomOperation[T]隐式类型。</span></span><br><span class="line">      <span class="keyword">val</span> custom = implicitly[<span class="type">CustomOperation</span>[<span class="type">T</span>]]</span><br><span class="line">      custom.multiply(v, x) + <span class="string">&quot;+&quot;</span> + custom.multiply(v, y).toString</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//另外一种写法</span></span><br><span class="line">  <span class="comment">/* def multiply(x: T, y: T)(implicit custom: CustomOperation[T]): String = &#123;</span></span><br><span class="line"><span class="comment">      custom.multiply(v, x) + custom.multiply(v, y).toString</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">String</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> custom = implicitly[<span class="type">CustomOperation</span>[<span class="type">T</span>]]</span><br><span class="line">      custom.plus(v, x) + custom.plus(v, y).toString</span><br><span class="line">      <span class="comment">//      custom.plus(x, y)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类 <code>CustomOperationMain</code>:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.typeclass.<span class="type">CustomOperation</span>._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CustomOperationMain</span> </span>&#123;</span><br><span class="line"> <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">&quot;maple&quot;</span>.plus(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    println(str)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maple&lt;maple&gt;</span><br><span class="line"><span class="comment">//隐式转换的运算过程为</span></span><br><span class="line"> custom.plus(v, x) + custom.plus(v, y).toString</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + y</span><br></pre></td></tr></table></figure><p>如果想要对 <code>Double</code> 支持上述操作，同样定义如下类型类扩展即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">DoubleCustomOperation</span> <span class="keyword">extends</span> <span class="title">CustomOperation</span>[<span class="type">Double</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>): <span class="type">Double</span> = x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>): <span class="type">Double</span> = x * y</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.typeclass.<span class="type">CustomOperation</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> doubleValue = <span class="number">5.5</span>.multiply(<span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    println(doubleValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为 <code>11.0+16.5</code><br>计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">custom.multiply(v, x) + &quot;+&quot; + custom.multiply(v, y).toString</span><br><span class="line">override def multiply(x: Double, y: Double): Double &#x3D; x * y</span><br><span class="line">&#x2F;&#x2F;相乘后字符串相加</span><br><span class="line">5.5*2.0 + 5.5*3.0 &#x3D;&#x3D;&#x3D;&gt;  11.0+16.5</span><br></pre></td></tr></table></figure><h3 id="Type-Class-总结"><a href="#Type-Class-总结" class="headerlink" title="Type Class 总结"></a>Type Class 总结</h3><p><code>TypeClass</code> 将 <strong>行为定义</strong> 与 <strong>具有行为的对象</strong> 分离。有点类似于 <code>AOP</code>，但是比 <code>AOP</code> 简洁很多。同时, 在函数式编程中，通常将 <strong>数据</strong> 与 <strong>行为</strong> 相分离，甚至是数据与行为按需绑定，已达到更为高级的组合特性。</p><h3 id="隐式转换触发时机"><a href="#隐式转换触发时机" class="headerlink" title="隐式转换触发时机"></a>隐式转换触发时机</h3><p><code>Scala</code> 会考虑如下的隐式转换函数：</p><ul><li>1.位于源或目标类型的伴生对象中的隐式函数或隐式类。</li><li>2.位于当前作用域中可以以单个标识符指代的隐式函数或隐式类。<br>隐式转换可以显示加上，来进行代码调试。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍 <code>Scala</code> 隐式转换的几种用法，通过详细的例子加深读者对隐式转换的理解。关于隐式转换的触发时机以及编译器优化顺序等，将不在本篇文章详细介绍，可以关注笔者后续文章。</p><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>最后推荐一下本人微信公众号，欢迎大家关注。</p><p><img src="https://upload-images.jianshu.io/upload_images/6393906-47e180d949563b81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" href="/p/b2d7d4cd.html"><i class="fas fa-angle-double-right"></i>从示例逐渐理解Scala尾递归</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-11-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">21 分钟读完 (大约3165个字)</span></div></div><div class="content"><h3 id="1-递归与尾递归"><a href="#1-递归与尾递归" class="headerlink" title="1.递归与尾递归"></a>1.递归与尾递归</h3><h4 id="1-1-递归"><a href="#1-1-递归" class="headerlink" title="1.1 递归"></a>1.1 递归</h4><h5 id="1-1-1-递归定义"><a href="#1-1-1-递归定义" class="headerlink" title="1.1.1 递归定义"></a>1.1.1 递归定义</h5><blockquote><p>递归大家都不陌生，一个函数直接或间接的调用它自己本身，就是递归。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以执行多次重复的计算。</p></blockquote><h5 id="1-1-2-递归的条件"><a href="#1-1-2-递归的条件" class="headerlink" title="1.1.2 递归的条件"></a>1.1.2 递归的条件</h5><p>一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p><p>以递归方式实现阶乘函数的实现：</p><p>代码清单1-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">factorial</span><span class="params">(n:Int)</span>: Long </span>=&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> n * factorial(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单中，<code>if(n &lt;= 0) 1</code>是递归返回段，<code>else</code>后面部分是递归前进段。</p><h5 id="1-1-3-递归的缺点："><a href="#1-1-3-递归的缺点：" class="headerlink" title="1.1.3 递归的缺点："></a>1.1.3 递归的缺点：</h5><ul><li>需要保持调用堆栈,如代码清单1-1,每一次递归都要保存<code>n*factorial(n-1)</code>栈帧信息。如果调用次数太多，可能会导致栈溢出</li><li>效率会比较低，递归就是不断的调用自己本身，如果方法本身比较复杂，每次调用自己效率会较低。</li></ul><h4 id="1-2-尾递归"><a href="#1-2-尾递归" class="headerlink" title="1.2 尾递归"></a>1.2 尾递归</h4><h5 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h5><p>尾递归的定义比较简单，即<strong>函数在函数体最后调用它本身，就被称为尾递归</strong>。</p><p>我们可以这样理解尾递归</p><ul><li>所有递归形式的调用都出现在函数的末尾</li><li>递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分</li></ul><h5 id="1-2-2-例子程序"><a href="#1-2-2-例子程序" class="headerlink" title="1.2.2 例子程序"></a>1.2.2 例子程序</h5><p>下面我们使用尾递归的模式实现上面的阶乘<br><br>代码清单1-2</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n:<span class="type">Int</span>):<span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(main:<span class="type">Int</span>,aggr:<span class="type">Int</span>): <span class="type">Long</span> =&#123;</span><br><span class="line">        <span class="keyword">if</span>(main &lt;= <span class="number">0</span>) aggr</span><br><span class="line">        <span class="keyword">else</span> factorial(main<span class="number">-1</span>,main*aggr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   factorial(n,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以比较代码清单1-1和1-2<br>1-1中，每次的递归调用都要本身时依赖n这个变量，所以，它只能是个不同的递归。</p><p>1-2中，函数<code>factorial</code>每次返回的都是它自己本身，没有依赖任何值。它做的是将main每次减1，将aggr每次乘main，然后将这两个结果作为下一次递归调用的参数，进行调用。</p><p>尾递归的核心思想是通过参数来传递每一次的调用结果，达到不压栈。它维护着一个迭代器和一个累加器。</p><h4 id="1-3-循环"><a href="#1-3-循环" class="headerlink" title="1.3 循环"></a>1.3 循环</h4><p>循环能够解决大多数的累计问题，循环可以完成累加和迭代，处理问题比较简单，思想也比较符合，容易理解</p><p>n的阶乘循环的写法</p><p>代码清单1-3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibfor</span><span class="params">(n:Int)</span>: Int </span>=&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        m = m * i</span><br><span class="line">    &#125;</span><br><span class="line">    m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本，会有var的可变变量，我们知道，函数式编程就应该更函数范，我们尽可能的要用vals去替换可变的vars<br>所以我们可以使用递归的方式来消除掉vars</p><hr><h3 id="2-改写-循环，递归-TO-尾递归"><a href="#2-改写-循环，递归-TO-尾递归" class="headerlink" title="2.改写 (循环，递归 TO 尾递归)"></a>2.改写 (循环，递归 TO 尾递归)</h3><blockquote><p>事实上，scala都是将尾递归直接编译成循环模式的。所以我们可以大胆的说，所有的循环模式都能改写为尾递归的写法模式</p></blockquote><p>尾递归会维护一个或多个累计值(<code>aggregate</code>)参数和一个迭代参数。我们具体分析</p><h4 id="2-1迭代器和累计器"><a href="#2-1迭代器和累计器" class="headerlink" title="2.1迭代器和累计器"></a>2.1迭代器和累计器</h4><ul><li><p>累计值参数<code>aggregate</code>将每次循环产生的结果进行累计，然后传到下一次的调用中。</p></li><li><p>迭代器，和普通递归或循环一样，每次递归或循环后，改变一次。(如for(i=0;i&lt;1-;i++)里面的i)</p></li></ul><h4 id="2-2-普通递归转换为尾递归"><a href="#2-2-普通递归转换为尾递归" class="headerlink" title="2.2 普通递归转换为尾递归"></a>2.2 普通递归转换为尾递归</h4><blockquote><p>并不是所有的递归都能改写为尾递归，那些比较复杂的递归调用时无法优化为尾递归的。但是大部分还是能够进行优化的。</p></blockquote><p>代码清单1-1 和代码清单 1-2 是求n阶阶乘的普通递归与尾递归的写法，前者没有进行优化，每次调用都会压栈。<br>后者，通过定义一个<code>aggregate</code>(累计)参数，对每一次调用后的结果做一次累计,而另一个参数main称为迭代器,每一次调用都会-1，当达到符合返回的条件时，将累计值返回。</p><h4 id="2-3-循环（while-loop）转为尾递归（tail-recursion）"><a href="#2-3-循环（while-loop）转为尾递归（tail-recursion）" class="headerlink" title="2.3 循环（while loop）转为尾递归（tail recursion）"></a>2.3 循环（while loop）转为尾递归（tail recursion）</h4><blockquote><p>正如上文循环例子所述，存在<code>var</code>,函数式编程就应该有函数范，我们尽量使用<code>val</code>来代替，所以接下来来看，怎么将循环转换为尾递归</p></blockquote><h5 id="2-3-1-循环和尾递归"><a href="#2-3-1-循环和尾递归" class="headerlink" title="2.3.1 循环和尾递归"></a>2.3.1 循环和尾递归</h5><blockquote><p>正如上文所说的迭代器和累计器，循环和尾递归都有这两个概念</p></blockquote><p><strong>迭代器</strong>和<strong>累计器</strong></p><p>尾递归每一次的调用自身都会有一次累加（或者累积，累减等），然后会有一个迭代器进行迭代，一个累加器进行累加迭代的结果，然后作为参数，再去调用自身。</p><h5 id="2-3-2-如上面求n阶乘的尾递归例子："><a href="#2-3-2-如上面求n阶乘的尾递归例子：" class="headerlink" title="2.3.2 如上面求n阶乘的尾递归例子："></a>2.3.2 如上面求n阶乘的尾递归例子：</h5><ul><li><p>1.循环的例子中存在一个<code>var</code>，它在每次循环中充当一个累加器的角色，累加每一次的迭代结果，而每次迭代过程就是<code>m*i</code>的一个过程。</p></li><li><p>2.尾递归也是一样的思想，以<code>main</code>作为迭代器，每次递减<code>1</code>，类似循环里的<code>i</code>，以<code>aggr</code>作为累加器，每次累计迭代的结果，类似循环的<code>m</code>。</p></li><li><p>3.相对于普通的递归，这里尾递归多的一个参数就是累加器<code>aggr</code>，用于累计每一次递归迭代的结果。这样做的目的就是每一次调用的结果可以作为下一次函数调用的参数。</p></li></ul><h3 id="3-具体示例-加深理解"><a href="#3-具体示例-加深理解" class="headerlink" title="3.具体示例-加深理解"></a>3.具体示例-加深理解</h3><h4 id="3-1-例子1-求斐波拉契数列"><a href="#3-1-例子1-求斐波拉契数列" class="headerlink" title="3.1 例子1 - 求斐波拉契数列"></a>3.1 例子1 - 求斐波拉契数列</h4><ul><li><p>普通递归写法（性能较低）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacci</span><span class="params">(n:Int)</span>: Long </span>=&#123;</span><br><span class="line">    n match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环的写法（循环写法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacciFor</span><span class="params">(n:Int)</span>: Int </span>= &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">2</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(i &lt;- <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> aggr = current + next</span><br><span class="line">            current = next</span><br><span class="line">            next = aggr</span><br><span class="line">        &#125;   </span><br><span class="line">        next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，aggr是累加器，然后将累加的值赋值给下一个next，而current等于next，每一次循环，都有给current和next赋予新值,当累加完成后，返回next的值。</p></li><li><p>尾递归写法</p><blockquote><p>如何对其进行优化？<br><br>仔细分析,上面的普通循环，每一轮两个值都在改变，然后又一个累加器aggr，对这两个值进行累加，并赋值给更大的next，然后进入下一次循环。</p></blockquote></li></ul><p>尾递归，我们也是同样的做法，定义两个接受值，当前的，和下一个，然后需要一个累加值。</p><p>这里普通方法的递归调用是两个原函数相加，涉及到的变量有 n , n-1 , n-2<br><br>因此,我们在考虑使用尾递归时，可能也需要使用到三个参数，初略涉及，尾递归函数需要使用三个参数，于是改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacci</span><span class="params">(n: Int)</span>: Long </span>= &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function">def <span class="title">fibonacciTail</span><span class="params">(main: Int, current: Int, next: Int)</span>: Long </span>= &#123;</span><br><span class="line">      main match &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; next</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; fibonacciByTail(main - <span class="number">1</span>, next, current+next)</span><br><span class="line">      &#125;</span><br><span class="line">      fibonacciTail(n, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fibonacciTail(n,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用尾递归和模式匹配。每一次调用自身，将next赋值给current，然后累加current和next的值赋值给新的next值，call下一轮。思想上和上面循环很像。但是更函数范，消除掉了var。</p><hr><h4 id="3-2-例子2-loadBalance算法"><a href="#3-2-例子2-loadBalance算法" class="headerlink" title="3.2 例子2 - loadBalance算法"></a>3.2 例子2 - loadBalance算法</h4><blockquote><p>需求，设计一个程序，传入一个比例数组，比如Array（1,3,6,一直调用该函数，返回的3个节点的比例也应该如传入的1:3:6的比例一样。</p></blockquote><ul><li>我最开始使用<code>for循环</code>和<code>return</code>实现了这个需求，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">loadBalance</span><span class="params">(arr:Array[Int])</span>: Int </span>=&#123;</span><br><span class="line">      <span class="comment">//根据传入的数组使用scan高级函数进行变化，具体算法例子：</span></span><br><span class="line">      <span class="comment">//eg （1，3，6） -&gt;  (1,4,10)</span></span><br><span class="line">      <span class="comment">//这样的目的是，随机出来的值为0-1时，选择第一个节点，为1-4时选择第二节点，依次类推</span></span><br><span class="line">      val segment:Array[Int] = arr.scan(<span class="number">0</span>)(_ + _).drop(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//随机数的范围，根据传入的数组的数据之和来，例如上的便是 10 ，产生的随机数介于0 - 9 之间</span></span><br><span class="line">      val weightSum:Int  = arr.sum</span><br><span class="line">      val random = <span class="keyword">new</span> Random().nextInt(weightSum)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until segment.size )&#123;</span><br><span class="line">        <span class="keyword">if</span>(random &lt; segment(i))&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我通过测试程序调用1万次该方法，返回的随机节点的比例是符合传入的比例的。</li></ul><p><strong>思考</strong>：<br><br>虽然这样可以达到目的，但是代码写的既不优雅，在scala函数式编程中最好是不能使用<code>return</code>来强行打断函数执行的，并且在最后，我还需要去写一个0来作为默认返回。</p><h5 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h5><blockquote><p>大部分或者几乎所有的for循环都能使用尾递归进行优化，那上面这个代码如何进行优化呢？</p></blockquote><p><strong>思路</strong>：上文的for循环，每次增加的是<code>segment</code>的下标，每循环一次 +1，因此，我们在设计尾递归时，可以使用一个参数来实现相同的功能，而另一个参数应该就是产生的随机数。<br>ok，我们来进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">loadBalance</span><span class="params">(arr:Array[Int])</span>: Int </span>=&#123;</span><br><span class="line">      <span class="comment">//根据传入的数组使用scan高级函数进行变化，具体算法例子：</span></span><br><span class="line">      <span class="comment">//eg （1，3，6） -&gt;  (1,4,10)</span></span><br><span class="line">      <span class="comment">//这样的目的是，随机出来的值为0-1时，选择第一个节点，为1-4时选择第二节点，依次类推</span></span><br><span class="line">      val segment:Array[Int] = arr.scan(<span class="number">0</span>)(_ + _).drop(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//随机数的范围，根据传入的数组的数据之和来，例如上的便是 10 ，产生的随机数介于0 - 9 之间</span></span><br><span class="line">      val weightSum:Int  = arr.sum</span><br><span class="line">      val random = <span class="keyword">new</span> Random().nextInt(weightSum)</span><br><span class="line">      <span class="comment">//写一个内部方法</span></span><br><span class="line">      <span class="function">def <span class="title">loadUtil</span><span class="params">(rand:Int,index:Int)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert，保证程序健壮</span></span><br><span class="line">        <span class="keyword">assert</span>(index &lt; arr.length &amp;&amp; arr(index) &gt;= <span class="number">0</span>)</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(rand &lt; segment(index)) index</span><br><span class="line">        <span class="keyword">else</span> loadUtil(rand,index+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    loadUtil(random,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，使用尾递归的做法，代码会非常的优雅，现在写一个测试类进行测试！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    val arr = Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">    val countMap = collection.mutable.Map[Int,Int]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(_ &lt;- <span class="number">1</span> until <span class="number">100000</span>) &#123;</span><br><span class="line">      val res = loadBalance(arr)</span><br><span class="line"></span><br><span class="line">      countMap.get(res) match &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(x)</span> </span>=&gt; countMap += (res -&gt; (x+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">case</span> None =&gt; countMap +=(res -&gt; <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countMap.foreach(x =&gt; &#123;</span><br><span class="line">      println(s<span class="string">&quot;$&#123;x._1&#125;  调用次数 $&#123;x._2&#125;&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试10000次，返回结果如下：</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>  调用次数 <span class="number">69966</span></span><br><span class="line"><span class="number">1</span>  调用次数 <span class="number">20028</span></span><br><span class="line"><span class="number">0</span>  调用次数 <span class="number">10005</span></span><br></pre></td></tr></table></figure><p>如上，测试是通过的！是不是很优雅，感受到了尾递归的魅力？</p><hr><h3 id="4-scala编译器对尾递归的优化"><a href="#4-scala编译器对尾递归的优化" class="headerlink" title="4. scala编译器对尾递归的优化"></a>4. scala编译器对尾递归的优化</h3><p>Scala 对形式上严格的尾递归进行了优化，对于严格的尾递归，不需要注解</p><p>@tailrec 可以让编译器去检查该函数到底是不是尾递归，如果不是会报错</p><h5 id="具体以上面那个计算斐波拉契数列的例子进行性能分析"><a href="#具体以上面那个计算斐波拉契数列的例子进行性能分析" class="headerlink" title="具体以上面那个计算斐波拉契数列的例子进行性能分析"></a>具体以上面那个计算斐波拉契数列的例子进行性能分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def time[T](t: =&gt;T): T  = &#123;</span><br><span class="line">    val b = System.nanoTime()</span><br><span class="line">    val x = t</span><br><span class="line">    val e = System.nanoTime();</span><br><span class="line">    println(<span class="string">&quot;time: &quot;</span> + (e-b)/<span class="number">1000</span> + <span class="string">&quot;us&quot;</span>);</span><br><span class="line">    x</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count: Long = <span class="number">0</span></span><br><span class="line">  <span class="comment">// @tailrec</span></span><br><span class="line">  <span class="function">def <span class="title">fib2</span><span class="params">(n: Long)</span>: Long </span>= &#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    n match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        fib2(n-<span class="number">1</span>) + fib2(n-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面时间和调用次数的测试，可以得出尾递归的性能消耗很低，速度很快。</p><h4 id="4-1-编译器对尾递归的优化"><a href="#4-1-编译器对尾递归的优化" class="headerlink" title="4.1 编译器对尾递归的优化"></a>4.1 编译器对尾递归的优化</h4><p>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。</p><p>scala编译器会察觉到尾递归，并对其进行优化，将它编译成循环的模式。</p><h4 id="4-2-Scala尾递归的限制"><a href="#4-2-Scala尾递归的限制" class="headerlink" title="4.2 Scala尾递归的限制"></a>4.2 Scala尾递归的限制</h4><ul><li><p>尾递归有严格的要求，就是最后一个语句是递归调用，因此写法比较严格。</p></li><li><p>尾递归最后调用的必须是它本身，间接的赋值它本身的函数也无法进行优化。</p></li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>循环调用都是一个累计器和一个迭代器的作用，同理，尾递归也是如此，它也是通过累加和迭代将结果赋值给新一轮的调用，通过这个思路，我们可以轻松的将循环转换为尾递归的形式。</p><p>[本文完，欢迎转载，转载请注明出处]</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/maple.png" alt="枫叶"></figure><p class="title is-size-4 is-block" style="line-height:inherit">枫叶</p><p class="is-size-6 is-block">技术博客</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·武汉</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="public_avatar" src="/img/%E9%9D%9E%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%91%982.jpeg" alt="zane ray"></figure><div class="level"><a class="level-item button is-primary is-rounded" href="/img/%E9%9D%9E%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%91%981.jpeg" target="_blank" rel="noopener">↑关注我的公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat.png"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><link href="/music/APlayer.min.css"><div id="aplayer" style="margin:0 auto"></div><script src="/music/APlayer.min.js"></script><script src="/music/APlayer_Music.js"></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Dubbo/"><span class="level-start"><span class="level-item">Dubbo</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Nginx/"><span class="level-start"><span class="level-item">Nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Nginx/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Play/"><span class="level-start"><span class="level-item">Play</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/java/rocketmq/"><span class="level-start"><span class="level-item">rocketmq</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/spring%E4%B8%93%E9%A2%98/"><span class="level-start"><span class="level-item">spring专题</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/angular/"><span class="level-start"><span class="level-item">angular</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/p/ac45747d.html"><img src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></figure><div class="media-content"><p class="date"><time datetime="2021-05-07T02:54:53.000Z">2021-05-07</time></p><p class="title"><a href="/p/ac45747d.html">Spring 学习 [1]</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/p/a8949b93.html"><img src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></figure><div class="media-content"><p class="date"><time datetime="2019-04-01T11:43:12.000Z">2019-04-01</time></p><p class="title"><a href="/p/a8949b93.html">Scala实战 -- 对List中的部分元素进行合并操作</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-09T16:00:00.000Z">2019-01-10</time></p><p class="title"><a href="/p/6e951315.html">🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-24T16:00:00.000Z">2018-12-25</time></p><p class="title"><a href="/p/87290a79.html">🎮 Play 入门与学习(五) Dependency Injection</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-16T16:00:00.000Z">2018-12-17</time></p><p class="title"><a href="/p/fe729f21.html">🎮 Play 入门与学习(三) Asynchronous results</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Play/"><span class="tag">Play</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a><p class="is-size-7"><span>&copy; 2021 Zane Ray</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script></body></html>
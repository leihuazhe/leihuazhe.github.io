<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>标签: Play - 非普通程序员</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非普通程序员"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非普通程序员"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="非普通程序员的技术博客，以源码分析和连载为主"><meta property="og:type" content="blog"><meta property="og:title" content="非普通程序员"><meta property="og:url" content="http://leihuazhe.github.io/"><meta property="og:site_name" content="非普通程序员"><meta property="og:description" content="非普通程序员的技术博客，以源码分析和连载为主"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://leihuazhe.github.io/img/og_image.png"><meta property="article:author" content="Zane Ray"><meta property="article:tag" content="Java, Scala, Spring, Dubbo, MQ, Middleware"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://leihuazhe.github.io"},"headline":"非普通程序员","image":["http://leihuazhe.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Zane Ray"},"description":"非普通程序员的技术博客，以源码分析和连载为主"}</script><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Play</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/6e951315.html"><i class="fa fa-bolt" aria-hidden="true"></i> 🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2019-01-10</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">几秒读完 (大约87个字)</span></div></div><div class="content"><blockquote><p>由于目前在公司使用的 Play 版本是 2.5.4，本章将会讲解一下对此版本 Action 的相关知识。</p></blockquote><h2 id="使用-ActionBuilder-构建一个通用的-Action"><a href="#使用-ActionBuilder-构建一个通用的-Action" class="headerlink" title="使用 ActionBuilder 构建一个通用的 Action"></a>使用 ActionBuilder 构建一个通用的 Action</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LogAction</span> <span class="keyword">extends</span> <span class="title">ActionBuilder</span>[<span class="type">Request</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>], block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>]): <span class="type">Future</span>[<span class="type">Result</span>] = &#123;</span><br><span class="line">        <span class="keyword">val</span> start = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">        block(request).map &#123; result =&gt;</span><br><span class="line">            <span class="keyword">val</span> duration = <span class="type">System</span>.currentTimeMillis() - start</span><br><span class="line">            println(<span class="string">s&quot;请求 <span class="subst">$request</span> 耗时 <span class="subst">$duration</span>&quot;</span>)</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/87290a79.html"><i class="fa fa-bolt" aria-hidden="true"></i> 🎮 Play 入门与学习(五) Dependency Injection</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-25</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">28 分钟读完 (大约4222个字)</span></div></div><div class="content"><blockquote><p>依赖注入是一种广泛使用的设计模式，有助于将组件的行为与依赖性解析分开。Play支持基于JSR 330（在本页中描述）的运行时依赖注入和在Scala中编译时依赖注入。<br>之所以调用运行时依赖项注入，是因为依赖关系图是在运行时创建，连接和验证的。 如果找不到特定组件的依赖项，则在运行应用程序之前不会出现错误。</p></blockquote><p>Play支持Guice开箱即用，但可以插入其他JSR 330实现. <a target="_blank" rel="noopener" href="https://github.com/google/guice/wiki/">Guice wiki</a> 是一个很好的资源，可以更多地了解Guice和DI设计模式的功能。</p><p>注意：Guice是一个Java库，本文档中的示例使用Guice的内置Java API。 如果您更喜欢Scala DSL，您可能希望使用scala-guice或sse-guice库。</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>依赖注入实现了几个目标：</p><ul><li>它允许您轻松绑定同一组件的不同实现。 这对于测试尤其有用，您可以使用模拟依赖项手动实例化组件或注入备用实现。</li><li>它允许您避免全局静态。 虽然静态工厂可以实现第一个目标，但您必须小心确保正确设置状态。 特别是Play（现已弃用）的静态API需要运行的应用程序，这使得测试的灵活性降低。 并且一次有多个实例可以并行运行测试。</li></ul><p><code>Guice wiki</code> 有一些很好的例子可以更详细地解释这一点。</p><h2 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h2><p>Play 提供了许多内置组件，并在诸如 <code>BuiltinModule</code> 之类的模块中声明它们。 这些绑定描述了创建 <code>Application</code> 实例所需的所有内容，默认情况下包括由 <code>routes compiler</code> 生成的 <code>route</code>，该 route 将控制器注入到构造函数中。 然后可以将这些绑定转换为在 <code>Guice</code> 和其他运行时DI框架中工作。</p><p>Play团队维护Guice模块，该模块提供 <code>GuiceApplicationLoader</code>。 这为 <code>Guice</code> 进行绑定转换，使用这些绑定创建Guice注入器，并从注入器请求Application实例。</p><p>There are also third-party loaders that do this for other frameworks, including <a target="_blank" rel="noopener" href="https://github.com/scaldi/scaldi-play">Scaldi </a>and <a target="_blank" rel="noopener" href="https://github.com/remithieblin/play-spring-loader">Spring</a>.</p><p>或者，Play提供了一个 <code>BuiltInComponents</code> 特性，允许您创建一个纯Scala实现，在编译时将您的应用程序连接在一起。</p><p>我们将在下面详细介绍如何自定义默认绑定和应用程序加载器。</p><h2 id="Declaring-runtime-DI-dependencies"><a href="#Declaring-runtime-DI-dependencies" class="headerlink" title="Declaring runtime DI dependencies"></a>Declaring runtime DI dependencies</h2><blockquote><p>声明运行时DI依赖项</p></blockquote><p>如果您有一个组件（例如控制器），并且它需要一些其他组件作为依赖项，那么可以使用 <code>@Inject</code> 注解来声明它。 <code>@Inject</code> 注解可用于字段或构造函数。 我们建议您在构造函数上使用它，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.ws._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">ws: <span class="type">WSClient</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>@Inject</code> 注释必须位于类名之后但在构造函数参数之前，并且必须具有括号。</p><p>此外，Guice 确实提供了其他几种类型的注入方式，但构造函数注入通常是 <code>Scala</code> 中最清晰，简洁和可测试的，因此我们建议使用它。</p><p><code>Guice</code> 能够在其构造函数上使用 <code>@Inject</code> 自动实例化任何类，而无需显式绑定它。此功能被称为 <a target="_blank" rel="noopener" href="https://github.com/google/guice/wiki/JustInTimeBindings">just in time bindings</a>，<code>Guice</code> 文档中对此进行了更详细的描述。 如果您需要执行更复杂的操作，可以声明自定义绑定，如下所述。</p><h2 id="Dependency-injecting-controllers"><a href="#Dependency-injecting-controllers" class="headerlink" title="Dependency injecting controllers"></a>Dependency injecting controllers</h2><blockquote><p>依赖注入控制器</p></blockquote><p>There are two ways to make Play use dependency injected controllers.</p><p>有两种方法可以使 <code>Play</code> 使用依赖注入控制器。</p><h3 id="Injected-routes-generator"><a href="#Injected-routes-generator" class="headerlink" title="Injected routes generator"></a>Injected routes generator</h3><p>默认情况下（从2.5.0开始），<code>Play</code> 将生成一个 router ，该 router 将声明它所路由的所有控制器作为依赖项，允许您的控制器自己依赖注入。</p><p>要专门启用注入的路由生成器，请将以下内容添加到 <code>build.sbt</code> 中的构建设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routesGenerator :&#x3D; InjectedRoutesGenerator</span><br></pre></td></tr></table></figure><p>当使用 <code>injected routes generator</code> 时，为操作添加 <code>@</code> 符号前缀具有特殊含义，这意味着不是直接注入控制器，而是注入控制器的提供者。 例如，这允许 prototype controllers，以及用于打破循环依赖性的选项。</p><h3 id="Static-routes-generator"><a href="#Static-routes-generator" class="headerlink" title="Static routes generator"></a>Static routes generator</h3><p>您可以将Play配置为使用 legacy（pre 2.5.0）静态路由生成器，该生成器假定所有操作都是静态方法。 要配置项目，请将以下内容添加到 <code>build.sbt</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routesGenerator :&#x3D; StaticRoutesGenerator</span><br></pre></td></tr></table></figure><p>我们建议始终使用注入的路由生成器。 静态路由生成器主要作为辅助迁移的工具存在，因此现有项目不必一次使所有控制器不是静态的。</p><p>如果使用静态路由生成器，则可以通过在操作前加上@来指示操作具有注入的控制器，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET        &#x2F;some&#x2F;path           @controllers.Application.index</span><br></pre></td></tr></table></figure><h2 id="Component-lifecycle"><a href="#Component-lifecycle" class="headerlink" title="Component lifecycle"></a>Component lifecycle</h2><p>依赖注入系统管理注入组件的生命周期，根据需要创建它们并将它们注入其他组件。以下是组件生命周期的工作原理：</p><ul><li><strong>每次需要组件时都会创建新实例</strong>。如果组件多次使用，则默认情况下将创建组件的多个实例。如果您只需要组件的单个实例，则需要将其标记为单个实例。</li><li><strong>实例在需要时会以懒加载的形式创建</strong>。如果组件从未被其他组件使用，则根本不会创建它。这通常是你想要的。对于大多数组件而言，在需要之前创建它们是没有意义的。但是，在某些情况下，您希望直接启动组件，或者即使它们未被其他组件使用也是如此。例如，您可能希望在应用程序启动时向远程系统发送消息或预热缓存。您可以使用急切绑定 (<code>eager binding</code>) 强制创建组件。</li><li><strong>除了正常的垃圾收集之外，实例不会自动清理</strong>。当组件不再被引用时，它们将被垃圾收集，但框架将不会执行任何特殊操作来关闭组件，例如调用 <code>close</code> 方法。但是，<code>Play</code> 提供了一种特殊类型的组件，称为<code>ApplicationLifecycle</code>，它允许您注册组件以在应用程序停止时关闭。</li></ul><h2 id="Singletons"><a href="#Singletons" class="headerlink" title="Singletons"></a>Singletons</h2><p>有时，您可能拥有一个包含某些状态的组件，例如缓存，或者与外部资源的连接，或者创建组件可能很昂贵。 在这些情况下，该组件应该是单例的。 这可以使用 <code>@Singleton</code> 注解来实现：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrentSharePrice</span> </span>&#123;</span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> price = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set</span></span>(p: <span class="type">Int</span>) = price = p</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= price</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stopping-cleaning-up"><a href="#Stopping-cleaning-up" class="headerlink" title="Stopping/cleaning up"></a>Stopping/cleaning up</h2><p><code>Play</code> 关闭时可能需要清理某些组件，例如，停止线程池。 Play提供了一个 <code>ApplicationLifecycle</code> 组件，可用于在 <code>Play</code> 关闭时注册挂钩以停止组件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Future</span></span><br><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.inject.<span class="type">ApplicationLifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueueConnection</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">lifecycle: <span class="type">ApplicationLifecycle</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> connection = connectToMessageQueue()</span><br><span class="line">  lifecycle.addStopHook &#123; () =&gt;</span><br><span class="line">    <span class="type">Future</span>.successful(connection.stop())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationLifecycle</code> 将在创建时以相反的顺序停止所有组件。 这意味着您依赖的任何组件仍然可以安全地用在组件的停止钩子上。 因为您依赖它们，所以它们必须在组件之前创建，因此在组件停止之前不会停止。</p><p>注意：确保注册 <code>stop hook</code> 的所有组件都是单例非常重要。 注册 <code>stop</code> 钩子的任何非单例组件都可能是内存泄漏的来源，因为每次创建组件时都会注册一个新的钩子。</p><h2 id="Providing-custom-bindings"><a href="#Providing-custom-bindings" class="headerlink" title="Providing custom bindings"></a>Providing custom bindings</h2><blockquote><p>提供自定义绑定</p></blockquote><p>为组件定义 <code>trait</code> 被认为是一种好习惯，并且其他类依赖于该 <code>trait</code>，而不是组件的实现。 通过这样做，您可以注入不同的实现，例如，在测试应用程序时注入模拟实现。</p><p>在这种情况下，DI系统需要知道哪个实现应该绑定到该 <code>trait</code>。 我们建议您声明这一点的方式取决于您是将 <code>Play</code> 应用程序编写为 <code>Play</code> 的最终用户，还是编写其他 <code>Play</code> 应用程序将使用的库。</p><h3 id="Play-applications"><a href="#Play-applications" class="headerlink" title="Play applications"></a>Play applications</h3><p>我们建议 <code>Play</code> 应用程序使用应用程序正在使用的 <code>DI</code> 框架提供的任何机制。 尽管Play确实提供了绑定API，但此API有些限制，并且不允许您充分利用您正在使用的框架的强大功能。</p><p>由于Play为Guice提供了开箱即用的支持，下面的示例显示了如何为 <code>Guice</code> 提供绑定。</p><h4 id="Binding-annotations"><a href="#Binding-annotations" class="headerlink" title="Binding annotations"></a>Binding annotations</h4><p>将实现绑定到接口的最简单方法是使用 <code>Guice</code> <code>@ImplementedBy</code> 注释。 例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">ImplementedBy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ImplementedBy</span>(classOf[<span class="type">EnglishHello</span>])</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name: <span class="type">String</span>): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnglishHello</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name: <span class="type">String</span>) = <span class="string">&quot;Hello &quot;</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Programmatic-bindings"><a href="#Programmatic-bindings" class="headerlink" title="Programmatic bindings"></a>Programmatic bindings</h4><p>在一些更复杂的情况下，您可能希望提供更复杂的绑定，例如当您有一个 <code>trait</code> 的多个实现时，这些 <code>trait</code> 由 <code>@Named</code> 注释限定。 在这些情况下，您可以实现自定义 <code>Guice</code> 模块</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.<span class="type">Names</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line"></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;en&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">EnglishHello</span>])</span><br><span class="line"></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;de&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">GermanHello</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您将此模块称为 <code>Module</code> 并将其放在根包中，它将自动注册到 <code>Play</code>。 或者，如果要为其指定不同的名称或将其放在不同的包中，可以通过将其全限定名附加到 <code>application.conf</code> 中的 <code>play.modules.enabled</code> 列表来将其注册到 <code>Play</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.enabled +&#x3D; &quot;modules.HelloModule&quot;</span><br></pre></td></tr></table></figure><p>您还可以通过将以下模块添加到已禁用的模块来禁用根软件包中名为 <code>Module</code> 的模块的自动注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.disabled +&#x3D; &quot;Module&quot;</span><br></pre></td></tr></table></figure><h4 id="Configurable-bindings"><a href="#Configurable-bindings" class="headerlink" title="Configurable bindings"></a>Configurable bindings</h4><blockquote><p>可配置的绑定</p></blockquote><p>有时您可能希望在配置 <code>Guice</code> 绑定时读取 Play <code>Configuration</code> 或使用 <code>ClassLoader</code>。 您可以通过将这些对象添加到模块的构造函数来访问这些对象。</p><p>在下面的示例中，从配置文件中读取每种语言的 <code>Hello</code> 绑定。 这允许通过在 <code>application.conf</code> 文件中添加新设置来添加新的 <code>Hello</code> 绑定。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.<span class="type">Names</span></span><br><span class="line"><span class="keyword">import</span> play.api.&#123; <span class="type">Configuration</span>, <span class="type">Environment</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span>(<span class="params">environment: <span class="type">Environment</span>,configuration: <span class="type">Configuration</span></span>) </span></span><br><span class="line"><span class="class">															<span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line">    <span class="comment">// Expect configuration like:</span></span><br><span class="line">    <span class="comment">// hello.en = &quot;myapp.EnglishHello&quot;</span></span><br><span class="line">    <span class="comment">// hello.de = &quot;myapp.GermanHello&quot;</span></span><br><span class="line">    <span class="keyword">val</span> helloConfiguration: <span class="type">Configuration</span> =</span><br><span class="line">      configuration.getOptional[<span class="type">Configuration</span>](<span class="string">&quot;hello&quot;</span>).getOrElse(<span class="type">Configuration</span>.empty)</span><br><span class="line">    <span class="keyword">val</span> languages: <span class="type">Set</span>[<span class="type">String</span>] = helloConfiguration.subKeys</span><br><span class="line">    <span class="comment">// Iterate through all the languages and bind the</span></span><br><span class="line">    <span class="comment">// class associated with that language. Use Play&#x27;s</span></span><br><span class="line">    <span class="comment">// ClassLoader to load the classes.</span></span><br><span class="line">    <span class="keyword">for</span> (l &lt;- languages) &#123;</span><br><span class="line">      <span class="keyword">val</span> bindingClassName: <span class="type">String</span> = helloConfiguration.get[<span class="type">String</span>](l)</span><br><span class="line">      <span class="keyword">val</span> bindingClass: <span class="type">Class</span>[_ &lt;: <span class="type">Hello</span>] =</span><br><span class="line">        environment.classLoader.loadClass(bindingClassName)</span><br><span class="line">        .asSubclass(classOf[<span class="type">Hello</span>])</span><br><span class="line">      bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">        .annotatedWith(<span class="type">Names</span>.named(l))</span><br><span class="line">        .to(bindingClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在大多数情况下，如果在创建组件时需要访问 <code>Configuration</code>，则应将 <code>Configuration</code> 对象注入组件本身或组件的 <code>Provider</code> 中。 然后，您可以在创建组件时读取“配置”。 在为组件创建绑定时，通常不需要读取<code>Configuration</code>。</p><h4 id="Eager-bindings"><a href="#Eager-bindings" class="headerlink" title="Eager bindings"></a>Eager bindings</h4><blockquote><p>提前绑定</p></blockquote><p>在上面的代码中，每次使用时都会创建新的 <code>EnglishHello</code> 和 <code>GermanHello</code> 对象。 如果您只想创建一次这些对象，可能因为创建它们很昂贵，那么您应该使用 <code>@Singleton</code> 注释。 如果你想创建它们一次并在应用程序启动时急切地创建它们，而不是在需要它们懒加载，那么你就可以使用 <a target="_blank" rel="noopener" href="https://github.com/google/guice/wiki/Scopes#eager-singletons">Guice’s eager singleton binding</a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.<span class="type">Names</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Module is needed to register bindings</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the `Hello` interface to the `EnglishHello` implementation as eager singleton.</span></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;en&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">EnglishHello</span>]).asEagerSingleton()</span><br><span class="line"></span><br><span class="line">    bind(classOf[<span class="type">Hello</span>])</span><br><span class="line">      .annotatedWith(<span class="type">Names</span>.named(<span class="string">&quot;de&quot;</span>))</span><br><span class="line">      .to(classOf[<span class="type">GermanHello</span>]).asEagerSingleton()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用程序启动时，可以使用 <code>Eager</code> 单例来启动服务。 它们通常与关闭钩子组合在一起，以便服务可以在应用程序停止时清理其资源。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">Future</span></span><br><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.inject.<span class="type">ApplicationLifecycle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This creates an `ApplicationStart` object once at start-up and registers hook for shut-down.</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationStart</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">lifecycle: <span class="type">ApplicationLifecycle</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Shut-down hook</span></span><br><span class="line">  lifecycle.addStopHook &#123; () =&gt;</span><br><span class="line">    <span class="type">Future</span>.successful(())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.<span class="type">AbstractModule</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">configure</span></span>() = &#123;</span><br><span class="line">    bind(classOf[<span class="type">ApplicationStart</span>]).asEagerSingleton()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Play-libraries"><a href="#Play-libraries" class="headerlink" title="Play libraries"></a>Play libraries</h3><p>如果您正在为Play实现一个库，那么您可能希望它与DI框架无关，这样无论在应用程序中使用哪个DI框架，您的库都可以开箱即用。 出于这个原因，Play提供了一个轻量级绑定API，用于以DI框架无关的方式提供绑定。</p><p>要提供绑定，请实现Module以返回要提供的绑定序列。 Module trait还提供用于构建绑定的DSL：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.inject._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloModule</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bindings</span></span>(environment: <span class="type">Environment</span>,</span><br><span class="line">               configuration: <span class="type">Configuration</span>) = <span class="type">Seq</span>(</span><br><span class="line">    bind[<span class="type">Hello</span>].qualifiedWith(<span class="string">&quot;en&quot;</span>).to[<span class="type">EnglishHello</span>],</span><br><span class="line">    bind[<span class="type">Hello</span>].qualifiedWith(<span class="string">&quot;de&quot;</span>).to[<span class="type">GermanHello</span>]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将该模块附加到reference.conf中的play.modules.enabled列表，可以自动注册该模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.enabled +&#x3D; &quot;com.example.HelloModule&quot;</span><br></pre></td></tr></table></figure><p>Module bindings方法采用Play环境和配置。 如果要动态配置绑定，可以访问这些。<br>模块绑定支持急切绑定。 要声明一个急切绑定，请在绑定结束时添加.eagerly。</p><p>为了最大化跨框架兼容性，请记住以下事项：</p><ul><li>并非所有DI框架都只支持时间绑定。 确保明确绑定库提供的所有组件。</li><li>尝试保持绑定键简单 - 不同的运行时DI框架对键是什么以及它应该如何唯一或不唯一有不同的看</li></ul><h3 id="Excluding-modules"><a href="#Excluding-modules" class="headerlink" title="Excluding modules"></a>Excluding modules</h3><p>如果有一个您不想加载的模块，可以通过将其附加到application.conf中的play.modules.disabled属性来将其排除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play.modules.disabled +&#x3D; &quot;play.api.db.evolutions.EvolutionsModule&quot;</span><br></pre></td></tr></table></figure><h2 id="Managing-circular-dependencies"><a href="#Managing-circular-dependencies" class="headerlink" title="Managing circular dependencies"></a>Managing circular dependencies</h2><p>当您的某个组件依赖于依赖于原始组件的另一个组件（直接或间接）时，就会发生循环依赖关系。 例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.<span class="type">Inject</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">bar: <span class="type">Bar</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Bar</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">baz: <span class="type">Baz</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Baz</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">foo: <span class="type">Foo</span></span>)</span></span><br></pre></td></tr></table></figure><p>在这种情况下，Foo依赖于Bar，它取决于Baz，它依赖于Foo。 因此，您将无法实例化任何这些类。 您可以使用提供程序解决此问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.&#123; <span class="type">Inject</span>, <span class="type">Provider</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">bar: <span class="type">Bar</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Bar</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">baz: <span class="type">Baz</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Baz</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">foo: <span class="type">Provider</span>[<span class="type">Foo</span>]</span>)</span></span><br></pre></td></tr></table></figure><p>通常，可以通过以更原子的方式分解组件或查找要依赖的更具体的组件来解决循环依赖性。 常见问题是对Application的依赖。 当你的组件依赖于应用程序时，它说它需要一个完整的应用程序来完成它的工作; 通常情况并非如此。 您的依赖项应该位于具有您需要的特定功能的更具体的组件（例如，环境）上。 作为最后的手段，您可以通过注入Provider [Application]来解决问题。</p><h2 id="Advanced-Extending-the-GuiceApplicationLoader"><a href="#Advanced-Extending-the-GuiceApplicationLoader" class="headerlink" title="Advanced: Extending the GuiceApplicationLoader"></a>Advanced: Extending the GuiceApplicationLoader</h2><p>Play的运行时依赖注入由GuiceApplicationLoader类引导。 该类加载所有模块，将模块提供给Guice，然后使用Guice创建应用程序。 如果要控制Guice如何初始化应用程序，则可以扩展GuiceApplicationLoader类。</p><p>您可以覆盖几种方法，但通常需要覆盖构建器方法。 此方法读取ApplicationLoader.Context并创建GuiceApplicationBuilder。 您可以在下面看到构建器的标准实现，您可以按照自己喜欢的方式进行更改。 您可以在有关使用Guice进行测试的部分中找到如何使用GuiceApplicationBuilder。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.<span class="type">ApplicationLoader</span></span><br><span class="line"><span class="keyword">import</span> play.api.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> play.api.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.inject.guice._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomApplicationLoader</span> <span class="keyword">extends</span> <span class="title">GuiceApplicationLoader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">builder</span></span>(context: <span class="type">ApplicationLoader</span>.<span class="type">Context</span>): <span class="type">GuiceApplicationBuilder</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> extra = <span class="type">Configuration</span>(<span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>)</span><br><span class="line">    initialBuilder</span><br><span class="line">      .in(context.environment)</span><br><span class="line">      .loadConfig(extra ++ context.initialConfiguration)</span><br><span class="line">      .overrides(overrides(context): _*)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您覆盖ApplicationLoader时，您需要告诉Play。 将以下设置添加到application.conf：</p><p>play.application.loader =“modules.CustomApplicationLoader”<br>您不仅限于使用Guice进行依赖注入。 通过重写ApplicationLoader，您可以控制应用程序的初始化方式。 在下一节中了解更多信息。</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/fe729f21.html"><i class="fa fa-bolt" aria-hidden="true"></i> 🎮 Play 入门与学习(三) Asynchronous results</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-17</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">14 分钟读完 (大约2145个字)</span></div></div><div class="content"><blockquote><p>本章我们将讲解使用 Play 进行异步非阻塞编程情况下，如何处理异步返回结果的问题。</p></blockquote><h2 id="Handling-asynchronous-results"><a href="#Handling-asynchronous-results" class="headerlink" title="Handling asynchronous results"></a>Handling asynchronous results</h2><blockquote><p>从现在开始我们将进入异步 <code>http</code> 编程模块，本章将会介绍如何处理异步返回结果。</p></blockquote><h3 id="Make-controllers-asynchronous"><a href="#Make-controllers-asynchronous" class="headerlink" title="Make controllers asynchronous"></a>Make controllers asynchronous</h3><blockquote><p>使 controllers 变为异步的</p></blockquote><p>在 <code>Play Framework</code> 内部，其机制是自底向上全异步编程模式的，Play 会以异步、非阻塞的方式处理每个请求。</p><p>默认配置(<code>configuration</code>) 针对异步控制器(<code>asynchronous controllers</code>) 进行了优化。换句话说，应用程序代码应该尽量避免在控制器中进行阻塞,这样会导致控制器一直等待那个阻塞的操作。此类阻塞操作的常见示例有JDBC调用、流API、HTTP请求和长计算等。</p><p>虽然可以增加默认 <code>executionContext</code> 中线程的数量，以允许阻塞控制器处理更多的并发请求，但是遵循建议的保持控制器异步的方法可以更容易地进行扩展，并在负载下保持系统响应。</p><h3 id="Creating-non-blocking-actions"><a href="#Creating-non-blocking-actions" class="headerlink" title="Creating non-blocking actions"></a>Creating non-blocking actions</h3><blockquote><p>创建非阻塞的 <code>actions</code></p></blockquote><p>由于 <code>Play</code> 的工作方式，<code>action</code> 代码必须尽可能快，即非阻塞。那么，如果我们在还没有生成结果情形下，如何返回结果呢?答案是使用 <code>Future</code>。</p><p>A <code>Future[Result]</code> will eventually be redeemed with a value of type <code>Result</code>.</p><p>By giving a <code>Future[Result]</code> instead of a normal <code>Result</code>, we are able to quickly generate the result without blocking.</p><p>Play will then serve the result as soon as the promise is redeemed.</p><p>The web client will be blocked while waiting for the response, but nothing will be blocked on the server, and server resources can be used to serve other clients.</p><p>Using a <code>Future</code> is only half of the picture though!</p><blockquote><p>然而，使用<code>Future</code>只是这幅画的一半. (使用 Future 只是 Play 异步编程的一半)</p></blockquote><p>If you are calling out to a blocking API such as JDBC,then you still will need to have your ExecutionStage(<code>执行阶段</code>) run with a different executor, to move it off Play’s rendering thread pool.</p><p>You can do this by creating a subclass of <code>play.api.libs.concurrent.CustomExecutionContext</code>with a reference to the <a target="_blank" rel="noopener" href="https://doc.akka.io/docs/akka/2.5/dispatchers.html?language=scala">custom dispatcher</a>.</p><blockquote><p>这里意思是如果针对长时间阻塞的任务，比如JDBC，像上述方式操作，我们只不过是把当前任务的执行放到了另外一条线程中继续阻塞了而已，因此仍然是假异步。这时候，我们可以定义自定义的<code>CustomExecutionContext</code></p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.libs.concurrent.<span class="type">CustomExecutionContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请确保使用&quot;Scala Dependency Injection&quot;文档页面中列出的 custom binding 技术之一</span></span><br><span class="line"><span class="comment">//将 new context 绑定到当前 trait </span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyExecutionContext</span> <span class="keyword">extends</span> <span class="title">ExecutionContext</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyExecutionContextImpl</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">system: <span class="type">ActorSystem</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">CustomExecutionContext</span>(<span class="params">system, &quot;my.executor&quot;</span>) <span class="keyword">with</span> <span class="title">MyExecutionContext</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HomeController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">myExecutionContext: <span class="type">MyExecutionContext</span>, val controllerComponents: <span class="type">ControllerComponents</span></span>) <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">    <span class="type">Future</span> &#123;</span><br><span class="line">      <span class="comment">// Call some blocking API</span></span><br><span class="line">      <span class="type">Ok</span>(<span class="string">&quot;result of blocking call&quot;</span>)</span><br><span class="line">    &#125;(myExecutionContext)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="How-to-create-a-Future-Result"><a href="#How-to-create-a-Future-Result" class="headerlink" title="How to create a Future[Result]"></a>How to create a Future[Result]</h3><blockquote><p>要创建一个 <code>Future[Result]</code>，我们首先需要另一个<code>future</code>, 这个 <code>future</code> 会给我们返回我们需要计算的实际的结果。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futurePIValue: <span class="type">Future</span>[<span class="type">Double</span>] = computePIAsynchronously()</span><br><span class="line"><span class="keyword">val</span> futureResult: <span class="type">Future</span>[<span class="type">Result</span>] = futurePIValue.map &#123; pi =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;PI value computed: &quot;</span> + pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All of Play’s asynchronous API calls give you a <code>Future</code>. This is the case whether you are calling an external web service using the <code>play.api.libs.WS</code> API, or using Akka to schedule asynchronous tasks or to communicate with actors using <code>play.api.libs.Akka</code>.</p><blockquote><p><code>PlayFramework</code> 所有异步的 <code>API</code> 返回的结果都是一个 <code>Future</code>，无论你是通过 <code>play.api.libs.WS</code> API 调用一个外部的 <code>web</code> 服务，或者使用Akka调度异步任务，或者使用 <code>play. API .lib .Akka</code>与 <code>actor</code> 通信等等，返回都是 <code>Future</code>。</p></blockquote><p>下面是一个通过异步模式执行一段阻塞的代码，并返回一个 Future 简单的例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futureInt: <span class="type">Future</span>[<span class="type">Int</span>] = scala.concurrent.<span class="type">Future</span> &#123;</span><br><span class="line">  intensiveComputation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>It’s important to understand which thread code runs on with futures. In the two code blocks above, there is an import on Plays default execution context. This is an implicit parameter that gets passed to all methods on the future API that accept callbacks. The execution context will often be equivalent to a thread pool, though not necessarily.</p><blockquote><p>理解哪些线程代码在 Future 上运行是很重要的。在上面的两个代码块中，在 Play 默认 executionContext 上有一个导入。这是一个隐式参数，传递给 future API上所有接受回调的方法。executionContext 通常等价于线程池，但也不一定。</p></blockquote><p>You can’t magically turn synchronous IO into asynchronous by wrapping it in a <code>Future</code>. If you can’t change the application’s architecture to avoid blocking operations, at some point that operation will have to be executed, and that thread is going to block. So in addition to enclosing the operation in a <code>Future</code>, it’s necessary to configure it to run in a separate execution context that has been configured with enough threads to deal with the expected concurrency. See <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/ThreadPools">Understanding Play thread pools</a> for more information, and download the <a target="_blank" rel="noopener" href="https://playframework.com/download#examples">play example templates</a> that show database integration.</p><blockquote><p>你不能通过将代码块包装在一个 Future下来神奇地把<strong>同步IO</strong>变成异步的。如果您不能更改应用程序的体系结构以避免阻塞操作，那么在某个时刻，该操作将不得不执行，而该线程将阻塞。</p><p>因此，除了将操作封装在 <code>Future</code> 中之外，还需要将其配置为在一个单独的 <code>executionContext</code> 中运行，该上下文中已经配置了足够的线程来处理预期的并发。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/ThreadPools">了解Play线程池</a>，并下载显示数据库集成的<a target="_blank" rel="noopener" href="https://playframework.com/download#example">Play示例模板</a></p></blockquote><p>It can also be helpful to use Actors for blocking operations.</p><p>Actors provide a clean model for handling timeouts and failures, setting up blocking execution contexts, and managing any state that may be associated with the service.</p><p>Also Actors provide patterns like <code>ScatterGatherFirstCompletedRouter</code> to address simultaneous cache and database requests and allow remote execution on a cluster of backend servers. But an Actor may be overkill depending on what you need.</p><blockquote><p>对于阻塞操作场景，使用 Actors 模式是一个不错的选择。<code>Actors</code> 提供了一个简单一个简单的模型，来处理超时、故障、设置阻塞的 <code>executionContext</code> 以及与服务关联的任何状态。</p><p>Actors 还提供了像 “ScatterGatherFirstCompletedRouter” 这样的模式来处理同步缓存和数据库请求，并允许在后端服务器集群上远程执行。但是一个 actor 可能会因为你的需要而 overkill。</p></blockquote><h3 id="Returning-futures"><a href="#Returning-futures" class="headerlink" title="Returning futures"></a>Returning futures</h3><blockquote><p>返回 futures</p></blockquote><p>While we were using the <code>Action.apply</code> builder method to build actions until now, to send an asynchronous result we need to use the <code>Action.async</code> builder method:</p><p>当我们使用 <code>Action.apply</code> 时，将 <code>builder</code> 方法应用于 <code>actions</code> ，到目前为止，要发送异步结果，我们需要使用异步的 Actiton builder 方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">  <span class="keyword">val</span> futureInt = scala.concurrent.<span class="type">Future</span> &#123; intensiveComputation() &#125;</span><br><span class="line">  futureInt.map(i =&gt; <span class="type">Ok</span>(<span class="string">&quot;Got result: &quot;</span> + i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Actions-are-asynchronous-by-default"><a href="#Actions-are-asynchronous-by-default" class="headerlink" title="Actions are asynchronous by default"></a>Actions are asynchronous by default</h3><blockquote><p>默认情况下，<code>Actions</code> 是异步的。例如，在下面的控制器代码中，代码的<code>&#123;Ok(…)&#125;</code> 部分不是控制器的方法体。它是一个匿名函数，被传递给 <code>Action</code> 对象的 <code>apply</code>方法，该方法创建一个 <code>Action</code> 类型的对象。在内部，您编写的匿名函数将被调用，其结果将返回在 <code>Future</code>中。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span> </span>= <span class="type">Action</span> &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got request [&quot;</span> + request + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Both <code>Action.apply</code> and <code>Action.async</code> create <code>Action</code> objects that are handled internally in the same way. There is a single kind of <code>Action</code>, which is asynchronous, and not two kinds (a synchronous one and an asynchronous one). The <code>.async</code> builder is just a facility to simplify creating actions based on APIs that return a <code>Future</code>, which makes it easier to write non-blocking code.</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><code>Action.apply</code> 和 <code>Action.async</code> 在内部都以相同的方式来处理 <code>Action</code> 对象。</p><p>有一种单独的 Action，它是异步的，但是不是a synchronous one and an asynchronous one 中的一种。</p><p><code>.async</code> builder只是一个工具，用于在创建 <code>actions</code> 时基于返回 <code>Future</code> result 的 api 的操作进行简化，这使得编写非阻塞代码更加容易。</p><h3 id="Handling-time-outs"><a href="#Handling-time-outs" class="headerlink" title="Handling time-outs"></a>Handling time-outs</h3><blockquote><p>处理超时情况</p></blockquote><p>正确处理超时，避免 <code>web</code> 浏览器阻塞并在出现问题时等待，这通常很有用。您可以使用 <code>play.api.libs.concurrent.Futures</code> 来将非阻塞的超时包装在一个 <code>Futures</code> 中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.concurrent.<span class="type">Futures</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">  <span class="comment">// 你可以隐式的提供一个超时参数，这题哦你歌唱可以通过controller的构造参数来达到。</span></span><br><span class="line">  intensiveComputation().withTimeout(<span class="number">1.</span>seconds).map &#123; i =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Got result: &quot;</span> + i)</span><br><span class="line">  &#125;.recover &#123;</span><br><span class="line">    <span class="keyword">case</span> e: scala.concurrent.<span class="type">TimeoutException</span> =&gt;</span><br><span class="line">      <span class="type">InternalServerError</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>超时(Timeout)与取消(cancellation) 是不同的。对于超时而言，即使出现了超时，给定的 <code>Future</code> 仍然会完成，即使未返回已完成的值。</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/beeb0951.html"><i class="fa fa-bolt" aria-hidden="true"></i> 🎮 Play 入门与学习(二) Action Composition</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-14</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">12 分钟读完 (大约1858个字)</span></div></div><div class="content"><blockquote><p>本章将讲解 Action 的组成和原理,并且介绍了几种定义通用 Action 的方法。</p></blockquote><h2 id="Action-composition"><a href="#Action-composition" class="headerlink" title="Action composition"></a>Action composition</h2><blockquote><p>Action 组成结构</p></blockquote><h3 id="Custom-action-builders"><a href="#Custom-action-builders" class="headerlink" title="Custom action builders"></a>Custom action builders</h3><blockquote><p>自定义 action builders<br>我们有多种方法来声明一个 <code>Action</code>，使用 <code>request</code> 参数,不使用 <code>request</code> 参数, 使用 <code>body parser</code> 等等。实际上，并不止这些，我们将在异步编程一节进行讲述。</p></blockquote><p>这些用于构建 <code>actions</code> 的方法实际上都是由一个名为 <code>ActionBuilder</code> 的 <code>trait</code> 定义的。而我们用来声明 <code>Action</code> 的 <code>Action Object</code> 只是这个 <code>trait</code> 的一个实例。通过实现自己的 <code>ActionBuilder</code>，您可以声明可重用的 <code>action stack</code>，然后可以使用它们来构建 <code>actions</code>。</p><p>让我们从日志修饰符(<code>logging decorator</code>) 的简单示例开始，我们希望记录对 <code>action</code> 的每次调用日志。</p><p>第一种方法是在 <code>invokeBlock</code> 方法中实现这个功能，<code>ActionBuilder</code> 构建的每一个 <code>action</code> 都会调用这个方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingAction</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">parser: <span class="type">BodyParsers</span>.<span class="type">Default</span></span>)(<span class="params">implicit ec: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">ActionBuilderImpl</span>(<span class="params">parser</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>], block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>])=&#123;</span><br><span class="line">    <span class="type">Logger</span>.info(<span class="string">&quot;Calling action&quot;</span>)</span><br><span class="line">    block(request)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以在 <code>controllers</code> 中使用依赖注入来获取 <code>LoggingAction</code> 的一个实例，并且以使用普通 <code>Action</code> 的方式来使用它。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">loggingAction: <span class="type">LoggingAction</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                             cc:<span class="type">ControllerComponents</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AbstractController</span>(<span class="params">cc</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= loggingAction &#123;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since <code>ActionBuilder</code> provides all the different methods of building actions, this also works with, for example, declaring a custom body parser:</p><p>由于 <code>ActionBuilder</code> 提供了创建 <code>actions</code> 所有不同的方法，所以我们也可以在自定义的 <code>Action</code> 中使用 <code>body parser</code> 等普通 <code>Action</code> 的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span> </span>= loggingAction(parse.text) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got a body &quot;</span> + request.body.length + <span class="string">&quot; bytes long&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-actions"><a href="#组合-actions" class="headerlink" title="组合 actions"></a>组合 actions</h3><blockquote><p>Composing actions</p></blockquote><p>在大多数应用程序中,我们希望有多个 <code>action builders</code>, 比如一些做不同类型的 <code>authentication</code>, 一些提供不同类型的通用功能组件,等等。</p><p>在这种情况下,我们不想为每一个 <code>action builder</code> 重写 <code>loggingAction</code>，我们需要定义一个可重用的方式来简化代码。可重用的操作代码可以通过包装操作（<code>wrapping actions</code>）来实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Logging</span>[<span class="type">A</span>](<span class="params">action: <span class="type">Action</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">Action</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(request: <span class="type">Request</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">Result</span>] = &#123;</span><br><span class="line">    <span class="type">Logger</span>.info(<span class="string">&quot;Calling action&quot;</span>)</span><br><span class="line">    action(request)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">parser</span> </span>= action.parser</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">executionContext</span> </span>= action.executionContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can also use the <code>Action</code> action builder to build actions without defining our own action class:</p><p>我们也可以使用 <code>Action</code> action builder 来 创建 <code>actions</code> 而不需要定义我们自己的 <code>action class</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>])= <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  <span class="type">Logger</span>.info(<span class="string">&quot;Calling action&quot;</span>)</span><br><span class="line">  action(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>composeAction</code> 方法将 <code>Action</code> 混合到 <code>action builders</code> 中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingAction</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">parser: <span class="type">BodyParsers</span>.<span class="type">Default</span></span>)(<span class="params">implicit ec: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">ActionBuilderImpl</span>(<span class="params">parser</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>], block: (<span class="type">Request</span>[<span class="type">A</span>]) =&gt; <span class="type">Future</span>[<span class="type">Result</span>]) = &#123;</span><br><span class="line">    block(request)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">composeAction</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="keyword">new</span> <span class="type">Logging</span>(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样 <code>code</code> 后使用，效果和之前的例子一样</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= loggingAction &#123;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在不使用 <code>action builder</code> 的情况下将 <code>action</code> 混合到 <code>wrapping actions</code> 中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Logging</span> &#123;</span><br><span class="line">  <span class="type">Action</span> &#123;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="More-complicated-actions"><a href="#More-complicated-actions" class="headerlink" title="More complicated actions"></a>More complicated actions</h3><blockquote><p>更复杂的 Action</p></blockquote><p>到目前为止，我们只展示了完全不会影响请求的 actions。当然，我们也可以对传入的请求对象进行读取和修改。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"><span class="keyword">import</span> play.api.mvc.request.<span class="type">RemoteConnection</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xForwardedFor</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  <span class="keyword">val</span> newRequest = request.headers.get(<span class="string">&quot;X-Forwarded-For&quot;</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; request</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(xff) =&gt;</span><br><span class="line">      <span class="keyword">val</span> xffConnection = <span class="type">RemoteConnection</span>(xff, request.connection.secure, <span class="type">None</span>)</span><br><span class="line">      request.withConnection(xffConnection)</span><br><span class="line">  &#125;</span><br><span class="line">  action(newRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Play already has built in support for <code>X-Forwarded-For</code> headers.</p><p>我们可以 <code>block</code> 请求</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"><span class="keyword">import</span> play.api.mvc.<span class="type">Results</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onlyHttps</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  request.headers.get(<span class="string">&quot;X-Forwarded-Proto&quot;</span>).collect &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;https&quot;</span> =&gt; action(request)</span><br><span class="line">  &#125; getOrElse &#123;</span><br><span class="line">    <span class="type">Future</span>.successful(<span class="type">Forbidden</span>(<span class="string">&quot;Only HTTPS requests allowed&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还能修改返回的结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addUaHeader</span></span>[<span class="type">A</span>](action: <span class="type">Action</span>[<span class="type">A</span>]) = <span class="type">Action</span>.async(action.parser) &#123; request =&gt;</span><br><span class="line">  action(request).map(_.withHeaders(<span class="string">&quot;X-UA-Compatible&quot;</span> -&gt; <span class="string">&quot;Chrome=1&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Different-request-types"><a href="#Different-request-types" class="headerlink" title="Different request types"></a>Different request types</h3><blockquote><p>不同的请求类型</p></blockquote><p>虽然 <code>action composition</code> 允许您在 <code>HTTP</code> request 和 response 级别执行额外的处理，但是您通常希望构建数据转换管道( <code>pipelines</code>)，以便向请求本身添加上下文(<code>context</code>) 或 执行验证(<code>perfom validation</code>)。</p><p><code>ActionFunction</code> 可以看作是作用在 request 上的一个函数，在输入请求类型和传递到下一层的输出类型上都<strong>参数化</strong>。</p><p>每个操作函数都可以表示模块处理，例如身份验证、对象的数据库查找、权限检查或希望跨操作组合和重用的其他操作。</p><p>一些实现了实现 <code>ActionFunction</code> 的预定义的 <code>trait</code> 对于不同类型的处理非常有用。</p><ul><li><code>ActionTransformer</code><ul><li>can change the request, for example by adding additional information.</li><li>可以改变一个请求，例如为此请求添加额外信息等。</li></ul></li><li><code>ActionFilter</code><ul><li>can selectively intercept requests, for example to produce errors, without changing the request value.</li><li>可以选择性的拦截请求，例如在不改变请求的前提下产生一个错误。</li></ul></li><li><code>ActionRefiner</code><ul><li>is the general case of both of the above.</li><li>上面两个 trait 的通用父类(trait)。</li></ul></li><li><code>ActionBuilder</code><ul><li>is the special case of functions that take <code>Request</code> as input, and thus can build actions.</li><li>以 “<code>Request</code>“ 作为输入的函数的一种特殊情况，并且是否可以构建 actions。</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ActionRefiner</span>[-<span class="type">R</span>[_], <span class="title">+P</span>[_]] <span class="keyword">extends</span> <span class="title">ActionFunction</span>[<span class="type">R</span>, <span class="type">P</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 确定怎么处理一个请求，这是继承 ActionRefiner 后需要实现的主方法。</span></span><br><span class="line"><span class="comment">   *	 </span></span><br><span class="line"><span class="comment">   * 它可以决定立即拦截请求并返回结果(Left)，或者继续处理类型为P的新参数(Right)。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return Either a result or a new parameter to pass to the Action block</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">refine</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">Either</span>[<span class="type">Result</span>, <span class="type">P</span>[<span class="type">A</span>]]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">invokeBlock</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>], block: <span class="type">P</span>[<span class="type">A</span>] =&gt; <span class="type">Future</span>[<span class="type">Result</span>]) =</span><br><span class="line">    refine(request).flatMap(_.fold(<span class="type">Future</span>.successful, block))(executionContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ActionFilter</span>[<span class="type">R</span>[_]] <span class="keyword">extends</span> <span class="title">ActionRefiner</span>[<span class="type">R</span>, <span class="type">R</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 确定是否处理请求。这是 ActionFilter 必须实现的主要方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 它可以决定立即拦截请求并返回结果(Some)，或者继续处理(None)。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return An optional Result with which to abort the request</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">Option</span>[<span class="type">Result</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">refine</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]) =</span><br><span class="line">    filter(request).map(_.toLeft(request))(executionContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ActionTransformer</span>[-<span class="type">R</span>[_], <span class="title">+P</span>[_]] <span class="keyword">extends</span> <span class="title">ActionRefiner</span>[<span class="type">R</span>, <span class="type">P</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *扩展或转换现有请求。这是ActionTransformer必须实现的主要方法</span></span><br><span class="line"><span class="comment">   * @return The new parameter to pass to the Action block</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]): <span class="type">Future</span>[<span class="type">P</span>[<span class="type">A</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">refine</span></span>[<span class="type">A</span>](request: <span class="type">R</span>[<span class="type">A</span>]) =</span><br><span class="line">    transform(request).map(<span class="type">Right</span>(_))(executionContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以通过实现 <code>invokeBlock</code> 方法定义自己的 <code>ActionFunction</code>。这样通常可以方便地创建请求的输入和输出类型实例(使用 <code>WrappedRequest</code>)，但这并不是严格必需的。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><blockquote><p><code>action functions</code> 最常见的用例之一是身份验证。我们可以很容易地实现我们自己的身份验证操作转换器，它从原始请求确定用户并将其添加到新的 <code>UserRequest</code>。注意，这也是一个 <code>ActionBuilder</code>，因为它接受一个简单的请求作为输入</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRequest</span>[<span class="type">A</span>](<span class="params">val username: <span class="type">Option</span>[<span class="type">String</span>], request: <span class="type">Request</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">WrappedRequest</span>[<span class="type">A</span>](<span class="params">request</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UserAction</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">val parser: <span class="type">BodyParsers</span>.<span class="type">Default</span></span>)(<span class="params">implicit val executionContext: <span class="type">ExecutionContext</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ActionBuilder</span>[<span class="type">UserRequest</span>, <span class="type">AnyContent</span>] <span class="keyword">with</span> <span class="title">ActionTransformer</span>[<span class="type">Request</span>, <span class="type">UserRequest</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>[<span class="type">A</span>](request: <span class="type">Request</span>[<span class="type">A</span>]) = <span class="type">Future</span>.successful &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">UserRequest</span>(request.session.get(<span class="string">&quot;username&quot;</span>), request)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的 <code>authentication action builder</code> 只是一个方便的帮助程序，它可以最小化实现简单情况下身份验证所需的代码，其实现与上面的示例非常相似。</p><p>由于编写自己的身份验证帮助程序很简单，所以如果内置的帮助程序不适合您的需要，我们建议这样做。</p></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><a class="has-link-black-ter" id="article-title" href="/p/468029a2.html"><i class="fa fa-bolt" aria-hidden="true"></i> 🎮 Play 入门与学习(一) Controller &amp; Router &amp; BodyParser</a></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">24 分钟读完 (大约3592个字)</span></div></div><div class="content"><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">cc: <span class="type">ControllerComponents</span></span>) <span class="keyword">extends</span> <span class="title">AbstractController</span>(<span class="params">cc</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.index())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">explore</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.explore())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tutorial</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.tutorial())</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>conf</code> 目录下配置 <code>routes</code> 文件，对请求url 进行映射到 <code>controllers</code>，和 <code>springmvc</code> 的 <code>@RequestMapping</code> 很类似。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Routes</span></span><br><span class="line"><span class="comment"># This file defines all application routes (Higher priority routes first)</span></span><br><span class="line"><span class="comment"># https://www.playframework.com/documentation/latest/ScalaRouting</span></span><br><span class="line"><span class="comment"># ~~~~</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># An example controller showing a sample home page</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/                    controllers.HomeController.index</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/explore             controllers.HomeController.explore</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/tutorial            controllers.HomeController.tutorial</span></span><br></pre></td></tr></table></figure><p>通过上述配置之后，我们就可以通过 url 访问到具体的 请求方法了。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>每一个请求是被一个 Action 进行处理了，处理之后返回 Results</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>常见的 <code>results</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Got request [&quot;</span> + request + <span class="string">&quot;]&quot;</span>)</span><br></pre></td></tr></table></figure><p>重定向到另一个 <code>url</code> 对应的 <code>Action</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Redirect</span>(<span class="string">&quot;/echo&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>mark</code> 方法还没有完成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">todo</span></span>() = <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>自定义 <code>Result</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Result</span>(</span><br><span class="line">  header = <span class="type">ResponseHeader</span>(<span class="number">200</span>, <span class="type">Map</span>.empty),</span><br><span class="line">  body = <span class="type">HttpEntity</span>.<span class="type">Strict</span>(<span class="type">ByteString</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="type">Some</span>(<span class="string">&quot;text/plain&quot;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Http-Routing"><a href="#Http-Routing" class="headerlink" title="Http Routing"></a>Http Routing</h2><blockquote><p>所有路由信息将定义在 <code>conf/routes</code> 文件下,前文有提及到。<code>router</code> 是负责将每个传入 <code>HTTP</code> 请求转换为 <code>Action</code> 的组件。</p></blockquote><p>每一个 <code>Http</code> 请求被 Play MVC Framework 认为是一个事件。每个请求包含两条主要信息：</p><ul><li>请求路径，restful 风格</li><li>http 请求方法，类似 Get、Post、Delete、Put 等</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>conf/routes</code> 是 <code>router</code> 使用的配置文件。该文件列出了应用程序所需的所有 <code>routes</code>。每个路由由一个 <code>HTTP</code> 方法和 <code>URI</code> 模式组成，它们都与 <code>Action</code> 的调用相关联。</p><p>让我们看看路由定义是什么样的:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br></pre></td></tr></table></figure><p>通过 <code>-&gt;</code> 来使用不同的路由规则</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>      <span class="string">/api                        api.MyRouter</span></span><br></pre></td></tr></table></figure><p>当与字符串插值路由DSL(也称为SIRD路由)结合使用时，或者在处理使用多个路由文件路由的子项目时，这一点尤其有用。</p><p>通过 <code>nocsrf</code> 来禁用 <code>CSRF filter</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">+</span> <span class="string">nocsrf</span></span><br><span class="line"><span class="attr">POST</span>  <span class="string">/api/new              controllers.Api.newThing</span></span><br></pre></td></tr></table></figure><p>URL规则:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态 path</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/all          controllers.Clients.list()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态 path</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则匹配模式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/files/*name          controllers.Application.download(name)</span></span><br></pre></td></tr></table></figure><p>逆向、反转 routing</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Redirect(routes.HelloController.echo())</span></span><br></pre></td></tr></table></figure><h2 id="操作处理结果返回"><a href="#操作处理结果返回" class="headerlink" title="操作处理结果返回"></a>操作处理结果返回</h2><p>结果内容类型自动从您指定作为响应体的Scala值推断出来。</p><p>通过 <code>play.api.http.ContentTypeOf</code> 来实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Will automatically set the Content-Type header to text/plain, while:</span></span><br><span class="line"><span class="keyword">val</span> textResult = <span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//will set the Content-Type header to application/xml.</span></span><br><span class="line"><span class="keyword">val</span> xmlResult = <span class="type">Ok</span>(&lt;message&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/message&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己定义返回类型</span></span><br><span class="line"><span class="keyword">val</span> htmlResult = <span class="type">Ok</span>(&lt;h1&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/h1&gt;).as(<span class="string">&quot;text/html&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> htmlResult2 = <span class="type">Ok</span>(&lt;h1&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/h1&gt;).as(<span class="type">HTML</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Manipulating-Http-headers-操纵-Http-头"><a href="#Manipulating-Http-headers-操纵-Http-头" class="headerlink" title="Manipulating Http headers (操纵 Http 头)"></a>Manipulating Http headers (操纵 Http 头)</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加返回头信息</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>).withHeaders(<span class="type">CACHE_CONTROL</span> -&gt; <span class="string">&quot;max-age=3600&quot;</span>,<span class="type">ETAG</span> -&gt; <span class="string">&quot;xx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Session-and-Flash"><a href="#Session-and-Flash" class="headerlink" title="Session and Flash"></a>Session and Flash</h2><blockquote><p>存储在 session 中的数据在整个会话期间都是可用的，存储在 flash 作用域的数据只对下一个请求可用。</p><p>需要注意，session 和 flash 的数据不是由服务器存储的，而是使用 cookie 机制添加到每个后续 http 请求中的。这意味着数据大小将非常有限(up to 4kb),并且只能存储字符串值。 cookie 的默认名称是 <code>PLAY_SESSION</code>。这可以在 <code>application.conf</code> 通过配置 key <code>play.http.session</code> 来更改。</p></blockquote><h3 id="Session-存储"><a href="#Session-存储" class="headerlink" title="Session 存储"></a>Session 存储</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这会将 session 完全替换掉</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Welcome!&quot;</span>).withSession(<span class="string">&quot;connected&quot;</span> -&gt; <span class="string">&quot;user@gmail.com&quot;</span>)</span><br><span class="line"><span class="comment">//在现有session 基础上添加 element 内容即可</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>).withSession(request.session + (<span class="string">&quot;saidHello&quot;</span> -&gt; <span class="string">&quot;yes&quot;</span>))</span><br><span class="line"><span class="comment">//通过key remove 部分内容</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Theme reset!&quot;</span>).withSession(request.session - <span class="string">&quot;theme&quot;</span>)</span><br></pre></td></tr></table></figure><p>读取 <code>Session</code> 内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span> &#123; request =&gt;</span><br><span class="line">  request.session.get(<span class="string">&quot;connected&quot;</span>).map &#123; user =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Hello &quot;</span> + user)</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    <span class="type">Unauthorized</span>(<span class="string">&quot;Oops, you are not connected&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>丢弃整个 <code>Session</code> 内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Bye&quot;</span>).withNewSession</span><br></pre></td></tr></table></figure><h3 id="Flash-Scope-Flash作用域"><a href="#Flash-Scope-Flash作用域" class="headerlink" title="Flash Scope (Flash作用域)"></a>Flash Scope (<code>Flash</code>作用域)</h3><blockquote><p>flash scope 和 session 作用很像，但是有两个区别</p></blockquote><ul><li>data are kept for only one request</li><li>the Flash cookie is not signed, making it possible for the user to modify it.</li></ul><p>session 的 cookie 会进行加密，而 flash 的 cookie 不会进行加密。</p><p><code>Flash作用域</code> 应该只用于在简单的 <code>非ajax</code> 应用程序上传输 成功/错误消息。由于数据只是为下一个请求保存的，而且在复杂的 <code>Web</code> 应用程序中不能保证请求顺序，所以 <code>Flash作用域</code> 受竞态条件的限制。(the Flash scope is subject to race conditions.)</p><h3 id="code-using-flash-scope"><a href="#code-using-flash-scope" class="headerlink" title="code using flash scope"></a>code using flash scope</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request =&gt;</span><br><span class="line">  <span class="type">Ok</span> &#123;</span><br><span class="line">    request.flash.get(<span class="string">&quot;success&quot;</span>).getOrElse(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span> &#123;</span><br><span class="line">  <span class="type">Redirect</span>(<span class="string">&quot;/home&quot;</span>).flashing(<span class="string">&quot;success&quot;</span> -&gt; <span class="string">&quot;The item has been created&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To retrieve the Flash scope value in your view, add an implicit Flash parameter</p><p>要在视图中检索Flash作用域值，请添加一个隐式Flash参数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@()(<span class="keyword">implicit</span> flash: <span class="type">Flash</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">@flash</span>.get(<span class="string">&quot;success&quot;</span>).getOrElse(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="请求体解析-Body-Parsers"><a href="#请求体解析-Body-Parsers" class="headerlink" title="请求体解析 Body Parsers"></a>请求体解析 Body Parsers</h2><blockquote><p>什么是 body parsers</p></blockquote><p><code>HTTP请求</code> 是header 后面跟着 body。header 通常很小——它可以安全地缓冲在内存中，因此在 <code>Play</code> 中它是使用<code>RequestHeader</code> 类建模的。</p><p>然而，<code>body</code> 可能非常长，因此不在内存中缓冲，而是建模为流。然而，许多请求体有效负载 (<code>payloads</code>) 都很小，并且可以在内存中建模，因此为了将 <code>body流</code> 映射到内存中的对象，<code>Play</code> 提供了一个<code>BodyParser</code> 抽象。</p><p>由于 <code>Play</code> 是一个异步框架，传统的 <code>InputStream</code> 不能用于读取请求体——输入流阻塞了，当您调用 <code>read</code> 时，调用它的线程必须等待数据可用。</p><p>相反，<code>Play</code> 使用一个名为 <code>Akka Streams</code> 的异步流库。<strong>Akka Streams</strong> 是 <strong>Reactive Streams</strong> 的一个实现。</p><p>允许许多异步流api 无缝地协同工作,所以尽管传统 <code>InputStream</code> 的基础技术不适合使用, 但是<code>Akka Streams</code> 和 <code>Reactive Streams</code> 的整个生态系统的异步库将为你提供你需要的一切。</p><h3 id="使用-Body-Parsers"><a href="#使用-Body-Parsers" class="headerlink" title="使用 Body Parsers"></a>使用 Body Parsers</h3><blockquote><p>如果没有显式选择 <code>body parser</code>，<code>Play</code> 将使用的缺省的 <code>body parser</code> 将查看传入的 <code>Content-Type</code>，并相应地解析body。</p><p>例如，类型 <code>application/json</code> 的内容类型将被解析为 <code>JsValue</code>，而类型 <code>application/x-www-form- urlencoding</code> 的内容类型将被解析为 <code>Map[String, Seq[String]]</code></p></blockquote><p>默认的 <code>Body Parser</code> 生成 <code>AnyContent</code> 类型的 <code>Body</code>。<code>AnyContent</code> 支持的各种类型, 可以通过 <code>as方法</code> 访问，例如 <code>asJson</code>，它返回一个 Option[body类型]</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span> &#123; request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">  <span class="keyword">val</span> body: <span class="type">AnyContent</span> = request.body</span><br><span class="line">  <span class="keyword">val</span> jsonBody: <span class="type">Option</span>[<span class="type">JsValue</span>] = body.asJson</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Expecting json body</span></span><br><span class="line">  jsonBody.map &#123; json =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (json \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    <span class="type">BadRequest</span>(<span class="string">&quot;Expecting application/json request body&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是默认 <code>body parser</code> 支持的类型映射 (<code>The following is a mapping of types supported by the default body parser</code>)</p><ul><li><strong>text/plain</strong>: <code>String</code>, accessible via <code>asText</code>.</li><li><strong>application/json</strong>: <a target="_blank" rel="noopener" href="https://static.javadoc.io/com.typesafe.play/play-json_2.12/2.6.9/play/api/libs/json/JsValue.html"><code>JsValue</code></a>, accessible via <code>asJson</code>.</li><li><strong>application/xml</strong>, <strong>text/xml</strong> or <strong>application/XXX+xml</strong>: <code>scala.xml.NodeSeq</code>, accessible via <code>asXml</code>.</li><li><strong>application/x-www-form-urlencoded</strong>: <code>Map[String, Seq[String]]</code>, accessible via <code>asFormUrlEncoded</code>.</li><li><strong>multipart/form-data</strong>: <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/api/scala/play/api/mvc/MultipartFormData.html"><code>MultipartFormData</code></a>, accessible via <code>asMultipartFormData</code>.</li><li>Any other content type: <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/api/scala/play/api/mvc/RawBuffer.html"><code>RawBuffer</code></a>, accessible via <code>asRaw</code>.</li></ul><p>默认的 body parser 在解析之前会 <code>try to determine</code> 请求是否具有 <code>body</code>。</p><p>根据 <code>HTTP</code> 规范(spec)，内容长度(Content-Length) 或 传输编码标头(Transfer-Encoding) 的出现都表示主体的存在，因此解析器只在出现其中一个标头时进行解析，或者在显式设置非空主体时在 FakeRequest 上进行解析。</p><p>如果希望在所有情况下解析主体，可以使用下面描述的anyContent主体解析器。</p><h3 id="显示的选择一个-Body-Parser"><a href="#显示的选择一个-Body-Parser" class="headerlink" title="显示的选择一个 Body Parser"></a>显示的选择一个 Body Parser</h3><p>如果希望显式地选择主体解析器，可以将 body parser 传递给 Action 的 apply或 async 方法。</p><p>Play 提供了许多开箱即用的 body parser (<code>Play provides a number of body parsers out of the box</code>)，</p><p>这是通过 <code>PlayBodyParsers</code> trait 提供的，它可以注入到您的控制器中。</p><p>例子，如果要定义一个 request body 期望是 Json Body 的 Action</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不是 Json类型会返回 415 Unsupported Media Type , 类似 Springmvc 在参数前面加 @RequestBody</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.json) &#123; request: <span class="type">Request</span>[<span class="type">JsValue</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (request.body \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述 body 的类型为 <code>JsValue</code>, 它不是 <code>Option</code> 类型的了。原因是 json body parser 会验证请求是否具有 <code>application/json</code> 的 <code>Content-Type</code>，如果不是，则会返回 415 的错误，即 <code>415 Unsupported Media Type</code>,这样我们就不用再次检查了。</p><p>这样依赖，这个方法将要对请求的type 有严格的限制了，客户端要清楚这一点。如果希望有更宽松的做法，即不是 ``application/json<code>类型的</code>Content-Type` 也能够进行解析，可以使用如下方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会返回 415，会尝试进行解析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.tolerantJson) &#123; request: <span class="type">Request</span>[<span class="type">JsValue</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (request.body \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子，保存文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.file(to = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;/tmp/upload&quot;</span>))) &#123; request: <span class="type">Request</span>[<span class="type">File</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-Body-Parsers-Combining-body-parsers"><a href="#组合-Body-Parsers-Combining-body-parsers" class="headerlink" title="组合 Body Parsers (Combining body parsers)"></a>组合 Body Parsers (Combining body parsers)</h3><p>在上一个保存文件的示例中，所有请求 bodies 都存储在同一个文件中 (<code>/tmp/upload</code>)，这是存在问题的。</p><p>我们可以编写另一个自定义主体解析器，它从请求会话中提取用户名，为每个用户提供一个惟一的文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> storeInUserFile: <span class="type">BodyParser</span>[<span class="type">File</span>] = parse.using &#123; request =&gt;</span><br><span class="line">  request.session.get(<span class="string">&quot;username&quot;</span>).map &#123; user =&gt;</span><br><span class="line">    parse.file(to = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;/tmp/&quot;</span> + user + <span class="string">&quot;.upload&quot;</span>))</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    sys.error(<span class="string">&quot;You don&#x27;t have the right to upload here&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义 body parser</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span></span>: <span class="type">Action</span>[<span class="type">File</span>] = <span class="type">Action</span>(storeInUserFile) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们并没有真正编写自己的 <code>BodyParser</code>，而只是组合现有的 <code>BodyParser</code>。这通常就足够了，应该涵盖大多数用例。高级主题部分将介绍从头编写 <code>BodyParser</code></p><h3 id="Max-content-length"><a href="#Max-content-length" class="headerlink" title="Max content length"></a>Max content length</h3><p>基于文本的 body parsers (例如 text、json、xml 或 formurlencoding) 需要有一个最大内容长度。因为它们必须将所有内容加载到内存中。默认情况下，它们将解析的最大内容长度是 <code>100KB</code>。可以通过指定 <code>play.http.parser</code> 来覆盖它。可以通过在 <code>application.conf</code> 指定 <code>maxMemoryBuffer</code>属性来改变这个大小。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.conf</span></span><br><span class="line"><span class="meta">play.http.parser.maxMemoryBuffer</span>=<span class="string">128K</span></span><br></pre></td></tr></table></figure><p>对于将内容缓冲 (<code>buffer</code>) 到磁盘上的 body parser，例如 <code>raw parser</code> 或 <code>multipart/form-data</code> 等，它们的最大内容长度使用 <code>play.http.parser</code> 的 <code>maxDiskBuffer</code> 来进行指定。</p><p><code>maxDiskBuffer</code>属性，默认值为<code>10MB</code>。<code>multipart/form-data</code> 解析器还强制为数据字段的聚合设置文本最大长度属性。</p><p>您还可以通过在 <code>Action</code> 中显示指定来覆盖默认的最大长度。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept only 10KB of data.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.text(maxLength = <span class="number">1024</span> * <span class="number">10</span>)) &#123; request: <span class="type">Request</span>[<span class="type">String</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can also wrap any body parser with <code>maxLength</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept only 10KB of data.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.maxLength(<span class="number">1024</span> * <span class="number">10</span>, storeInUserFile)) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Writing-a-custom-body-parser"><a href="#Writing-a-custom-body-parser" class="headerlink" title="Writing a custom body parser"></a>Writing a custom body parser</h3><blockquote><p>我们可以实现 <code>BodyParser</code> 特质来自定义 body parser，这个 trait 是一个很简单的函数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BodyParser</span>[+<span class="type">A</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">RequestHeader</span> =&gt; <span class="type">Accumulator</span>[<span class="type">ByteString</span>, <span class="type">Either</span>[<span class="type">Result</span>, <span class="type">A</span>]]</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p>接收一个 <code>RequestHeader</code>，这样我们可以检查关于请求的信息，它通常用于获取 Content-Type,这样 body 就会被正确的解析。</p></li><li><p>函数的返回类型是 <code>Accumulator</code>，它是一个累加器。<code>Accumulator</code> 是 围绕 <code>Akka Streams Sink</code> 的一层薄层。<code>Accumulator</code> 异步地将 <code>streams of elements</code> 加到结果中，它可以通过传入 <code>Akka Streams Source</code> 来运行。这将返回一个 <code>Future</code>，并且在累加器完成时，<code>future</code>得到完成。</p></li><li><p><code>Accumulator</code> 本质上和 Sink[E,Future[A]] 一样，事实上，Accumulator 是 Sink 的一个包装器。但是最大的区别是 Accumulator 提供了方便的方法，比如 map、mapFuture、recover 等等。</p></li><li><p><code>Accumulator</code> 用于将结果作为一个 <code>promise</code> 来处理，其中 Sink 要求将所有的操作包装在 mapMaterializedValue 的调用中。</p></li><li><p>Accumulator 的 apply 返回 ByteString 类型的元素，这些元素本质上是字节数组，但与 byte[] 不同的是，<code>ByteString</code> 是不可变的，它的许多操作(如 slicing 或者 appending) 都是在固定的时间内完成的。</p></li></ul><p><code>Accumulator</code> 的返回类型是 <code>Either[Result, A]</code>，它要么返回一个 <code>Result</code>，要么返回一个类型 <code>A</code>。通常在发生错误的情况下返回 <code>Result</code>。例如，如果 body 解析失败，比如 Content-Type 与 Body Parser 接受的类型不匹配，或者内存缓冲区溢出了。当 <code>body parser</code> 返回一个 <code>result</code> 时，这将缩短 <code>action</code> 的处理时间，<code>action</code> 的结果将里脊返回，并且永远不会调用该操作。</p><h4 id="将-Body-引向别处-Directing-the-body-elsewhere"><a href="#将-Body-引向别处-Directing-the-body-elsewhere" class="headerlink" title="将 Body 引向别处 Directing the body elsewhere"></a>将 Body 引向别处 Directing the body elsewhere</h4><blockquote><p>编写 body parser 的一个常见用例是，当您实际上不想解析主体时，而是想将它以流的形式引入到其他地方(<code>stream it elsewhere</code>)。为此，您可以定义一个自定义 body parser</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.streams._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.ws._</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span></span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">ByteString</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyController</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">ws: <span class="type">WSClient</span>, val controllerComponents: <span class="type">ControllerComponents</span></span>)(<span class="params">implicit ec: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span></span>(request: <span class="type">WSRequest</span>): <span class="type">BodyParser</span>[<span class="type">WSResponse</span>] = <span class="type">BodyParser</span> &#123; req =&gt;</span><br><span class="line">    <span class="type">Accumulator</span>.source[<span class="type">ByteString</span>].mapFuture &#123; source =&gt;</span><br><span class="line">      request</span><br><span class="line">    	.withBody(source)</span><br><span class="line">        .execute()</span><br><span class="line">        .map(<span class="type">Right</span>.apply)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myAction</span> </span>= <span class="type">Action</span>(forward(ws.url(<span class="string">&quot;https://example.com&quot;</span>))) &#123; req =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Uploaded&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Akka-Streams-进行自定义的解析"><a href="#使用-Akka-Streams-进行自定义的解析" class="headerlink" title="使用 Akka Streams 进行自定义的解析"></a>使用 Akka Streams 进行自定义的解析</h4><blockquote><p>Custom parsing using Akka Streams</p></blockquote><p>在很少的情况下，可能需要使用 <code>Akka Streams</code> 编写自定义解析器。在大多数情况下，先用 <code>ByteString</code> 缓冲 body 就足够了，这通常提供一种简单得多的解析方法，因为您可以对主体使用强制方法和随机访问。</p><p>但是，当这不可行时，例如需要解析的主体太长而无法装入内存时，则可能需要编写自定义主体解析器。</p><p>关于如何使用 <code>Akka Streams</code> 的完整描述超出了本文档的范围——最好从阅读 <code>Akka Streams</code> 文档开始。但是，下面显示了一个 <code>CSV</code> 解析器，它基于<code>Akka Streams</code> 烹饪书中 <code>ByteStrings</code> 文档流的解析行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc.<span class="type">BodyParser</span></span><br><span class="line"><span class="keyword">import</span> play.api.libs.streams._</span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">ByteString</span></span><br><span class="line"><span class="keyword">import</span> akka.stream.scaladsl._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> csv: <span class="type">BodyParser</span>[<span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">String</span>]]] = <span class="type">BodyParser</span> &#123; req =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A flow that splits the stream into CSV lines</span></span><br><span class="line">  <span class="keyword">val</span> sink: <span class="type">Sink</span>[<span class="type">ByteString</span>, <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">String</span>]]]] = <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">    <span class="comment">//我们按照 new line character 进行分割，每行最多允许 1000个字符。</span></span><br><span class="line">    .via(<span class="type">Framing</span>.delimiter(<span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>), <span class="number">1000</span>, allowTruncation = <span class="literal">true</span>))</span><br><span class="line">    <span class="comment">//把每一行变成一个String，用逗号分隔</span></span><br><span class="line">    .map(_.utf8String.trim.split(<span class="string">&quot;,&quot;</span>).toSeq)</span><br><span class="line">    <span class="comment">// 现在我们使用 fold 将其变为一个列表 List</span></span><br><span class="line">    .toMat(<span class="type">Sink</span>.fold(<span class="type">Seq</span>.empty[<span class="type">Seq</span>[<span class="type">String</span>]])(_ :+ _))(<span class="type">Keep</span>.right)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 body 转为为 Either right 返回</span></span><br><span class="line">  <span class="type">Accumulator</span>(sink).map(<span class="type">Right</span>.apply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/maple.png" alt="枫叶"></figure><p class="title is-size-4 is-block" style="line-height:inherit">枫叶</p><p class="is-size-6 is-block">技术博客</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·武汉</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="public_avatar" src="/img/%E9%9D%9E%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%91%982.jpeg" alt="zane ray"></figure><div class="level"><a class="level-item button is-primary is-rounded" href="/img/%E9%9D%9E%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%91%981.jpeg" target="_blank" rel="noopener">↑关注我的公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat.png"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><link href="/music/APlayer.min.css"><div id="aplayer" style="margin:0 auto"></div><script src="/music/APlayer.min.js"></script><script src="/music/APlayer_Music.js"></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Dubbo/"><span class="level-start"><span class="level-item">Dubbo</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Nginx/"><span class="level-start"><span class="level-item">Nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Nginx/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Play/"><span class="level-start"><span class="level-item">Play</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/java/rocketmq/"><span class="level-start"><span class="level-item">rocketmq</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/spring%E4%B8%93%E9%A2%98/"><span class="level-start"><span class="level-item">spring专题</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/angular/"><span class="level-start"><span class="level-item">angular</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/p/ac45747d.html"><img src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></figure><div class="media-content"><p class="date"><time datetime="2021-05-07T02:54:53.000Z">2021-05-07</time></p><p class="title"><a href="/p/ac45747d.html">Spring 学习 [1]</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/p/a8949b93.html"><img src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></figure><div class="media-content"><p class="date"><time datetime="2019-04-01T11:43:12.000Z">2019-04-01</time></p><p class="title"><a href="/p/a8949b93.html">Scala实战 -- 对List中的部分元素进行合并操作</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-09T16:00:00.000Z">2019-01-10</time></p><p class="title"><a href="/p/6e951315.html">🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-24T16:00:00.000Z">2018-12-25</time></p><p class="title"><a href="/p/87290a79.html">🎮 Play 入门与学习(五) Dependency Injection</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-16T16:00:00.000Z">2018-12-17</time></p><p class="title"><a href="/p/fe729f21.html">🎮 Play 入门与学习(三) Asynchronous results</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Play/"><span class="tag">Play</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a><p class="is-size-7"><span>&copy; 2021 Zane Ray</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script></body></html>
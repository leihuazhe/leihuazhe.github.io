<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>🎮 Play 入门与学习(一) Controller &amp; Router &amp; BodyParser - 非普通程序员</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非普通程序员"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非普通程序员"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Play 学习系列文章第一篇"><meta property="og:type" content="blog"><meta property="og:title" content="🎮 Play 入门与学习(一) Controller &amp; Router &amp; BodyParser"><meta property="og:url" content="http://leihuazhe.github.io/p/468029a2.html"><meta property="og:site_name" content="非普通程序员"><meta property="og:description" content="Play 学习系列文章第一篇"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://leihuazhe.github.io/img/og_image.png"><meta property="article:published_time" content="2018-12-11T16:00:00.000Z"><meta property="article:modified_time" content="2021-05-06T04:35:17.155Z"><meta property="article:author" content="Zane Ray"><meta property="article:tag" content="Scala"><meta property="article:tag" content="Play"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://leihuazhe.github.io/p/468029a2.html"},"headline":"非普通程序员","image":["http://leihuazhe.github.io/img/og_image.png"],"datePublished":"2018-12-11T16:00:00.000Z","dateModified":"2021-05-06T04:35:17.155Z","author":{"@type":"Person","name":"Zane Ray"},"description":"Play 学习系列文章第一篇"}</script><link rel="canonical" href="http://leihuazhe.github.io/p/468029a2.html"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fa fa-bolt" aria-hidden="true"></i> 🎮 Play 入门与学习(一) Controller &amp; Router &amp; BodyParser</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">24 分钟读完 (大约3592个字)</span></div></div><div class="content"><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">cc: <span class="type">ControllerComponents</span></span>) <span class="keyword">extends</span> <span class="title">AbstractController</span>(<span class="params">cc</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.index())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">explore</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.explore())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tutorial</span></span>() = <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">    <span class="type">Ok</span>(views.html.tutorial())</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>conf</code> 目录下配置 <code>routes</code> 文件，对请求url 进行映射到 <code>controllers</code>，和 <code>springmvc</code> 的 <code>@RequestMapping</code> 很类似。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Routes</span></span><br><span class="line"><span class="comment"># This file defines all application routes (Higher priority routes first)</span></span><br><span class="line"><span class="comment"># https://www.playframework.com/documentation/latest/ScalaRouting</span></span><br><span class="line"><span class="comment"># ~~~~</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># An example controller showing a sample home page</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/                    controllers.HomeController.index</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/explore             controllers.HomeController.explore</span></span><br><span class="line"><span class="attr">GET</span>         <span class="string">/tutorial            controllers.HomeController.tutorial</span></span><br></pre></td></tr></table></figure><p>通过上述配置之后，我们就可以通过 url 访问到具体的 请求方法了。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>每一个请求是被一个 Action 进行处理了，处理之后返回 Results</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>常见的 <code>results</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Got request [&quot;</span> + request + <span class="string">&quot;]&quot;</span>)</span><br></pre></td></tr></table></figure><p>重定向到另一个 <code>url</code> 对应的 <code>Action</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Redirect</span>(<span class="string">&quot;/echo&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>mark</code> 方法还没有完成</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">todo</span></span>() = <span class="type">TODO</span></span><br></pre></td></tr></table></figure><p>自定义 <code>Result</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Result</span>(</span><br><span class="line">  header = <span class="type">ResponseHeader</span>(<span class="number">200</span>, <span class="type">Map</span>.empty),</span><br><span class="line">  body = <span class="type">HttpEntity</span>.<span class="type">Strict</span>(<span class="type">ByteString</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="type">Some</span>(<span class="string">&quot;text/plain&quot;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Http-Routing"><a href="#Http-Routing" class="headerlink" title="Http Routing"></a>Http Routing</h2><blockquote><p>所有路由信息将定义在 <code>conf/routes</code> 文件下,前文有提及到。<code>router</code> 是负责将每个传入 <code>HTTP</code> 请求转换为 <code>Action</code> 的组件。</p></blockquote><p>每一个 <code>Http</code> 请求被 Play MVC Framework 认为是一个事件。每个请求包含两条主要信息：</p><ul><li>请求路径，restful 风格</li><li>http 请求方法，类似 Get、Post、Delete、Put 等</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>conf/routes</code> 是 <code>router</code> 使用的配置文件。该文件列出了应用程序所需的所有 <code>routes</code>。每个路由由一个 <code>HTTP</code> 方法和 <code>URI</code> 模式组成，它们都与 <code>Action</code> 的调用相关联。</p><p>让我们看看路由定义是什么样的:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br></pre></td></tr></table></figure><p>通过 <code>-&gt;</code> 来使用不同的路由规则</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>      <span class="string">/api                        api.MyRouter</span></span><br></pre></td></tr></table></figure><p>当与字符串插值路由DSL(也称为SIRD路由)结合使用时，或者在处理使用多个路由文件路由的子项目时，这一点尤其有用。</p><p>通过 <code>nocsrf</code> 来禁用 <code>CSRF filter</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">+</span> <span class="string">nocsrf</span></span><br><span class="line"><span class="attr">POST</span>  <span class="string">/api/new              controllers.Api.newThing</span></span><br></pre></td></tr></table></figure><p>URL规则:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态 path</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/all          controllers.Clients.list()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态 path</span></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/clients/:id          controllers.Clients.show(id: Long)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则匹配模式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span>   <span class="string">/files/*name          controllers.Application.download(name)</span></span><br></pre></td></tr></table></figure><p>逆向、反转 routing</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Redirect(routes.HelloController.echo())</span></span><br></pre></td></tr></table></figure><h2 id="操作处理结果返回"><a href="#操作处理结果返回" class="headerlink" title="操作处理结果返回"></a>操作处理结果返回</h2><p>结果内容类型自动从您指定作为响应体的Scala值推断出来。</p><p>通过 <code>play.api.http.ContentTypeOf</code> 来实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Will automatically set the Content-Type header to text/plain, while:</span></span><br><span class="line"><span class="keyword">val</span> textResult = <span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//will set the Content-Type header to application/xml.</span></span><br><span class="line"><span class="keyword">val</span> xmlResult = <span class="type">Ok</span>(&lt;message&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/message&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己定义返回类型</span></span><br><span class="line"><span class="keyword">val</span> htmlResult = <span class="type">Ok</span>(&lt;h1&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/h1&gt;).as(<span class="string">&quot;text/html&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> htmlResult2 = <span class="type">Ok</span>(&lt;h1&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/h1&gt;).as(<span class="type">HTML</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Manipulating-Http-headers-操纵-Http-头"><a href="#Manipulating-Http-headers-操纵-Http-头" class="headerlink" title="Manipulating Http headers (操纵 Http 头)"></a>Manipulating Http headers (操纵 Http 头)</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加返回头信息</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>).withHeaders(<span class="type">CACHE_CONTROL</span> -&gt; <span class="string">&quot;max-age=3600&quot;</span>,<span class="type">ETAG</span> -&gt; <span class="string">&quot;xx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Session-and-Flash"><a href="#Session-and-Flash" class="headerlink" title="Session and Flash"></a>Session and Flash</h2><blockquote><p>存储在 session 中的数据在整个会话期间都是可用的，存储在 flash 作用域的数据只对下一个请求可用。</p><p>需要注意，session 和 flash 的数据不是由服务器存储的，而是使用 cookie 机制添加到每个后续 http 请求中的。这意味着数据大小将非常有限(up to 4kb),并且只能存储字符串值。 cookie 的默认名称是 <code>PLAY_SESSION</code>。这可以在 <code>application.conf</code> 通过配置 key <code>play.http.session</code> 来更改。</p></blockquote><h3 id="Session-存储"><a href="#Session-存储" class="headerlink" title="Session 存储"></a>Session 存储</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这会将 session 完全替换掉</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Welcome!&quot;</span>).withSession(<span class="string">&quot;connected&quot;</span> -&gt; <span class="string">&quot;user@gmail.com&quot;</span>)</span><br><span class="line"><span class="comment">//在现有session 基础上添加 element 内容即可</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Hello World!&quot;</span>).withSession(request.session + (<span class="string">&quot;saidHello&quot;</span> -&gt; <span class="string">&quot;yes&quot;</span>))</span><br><span class="line"><span class="comment">//通过key remove 部分内容</span></span><br><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Theme reset!&quot;</span>).withSession(request.session - <span class="string">&quot;theme&quot;</span>)</span><br></pre></td></tr></table></figure><p>读取 <code>Session</code> 内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span> &#123; request =&gt;</span><br><span class="line">  request.session.get(<span class="string">&quot;connected&quot;</span>).map &#123; user =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Hello &quot;</span> + user)</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    <span class="type">Unauthorized</span>(<span class="string">&quot;Oops, you are not connected&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>丢弃整个 <code>Session</code> 内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Ok</span>(<span class="string">&quot;Bye&quot;</span>).withNewSession</span><br></pre></td></tr></table></figure><h3 id="Flash-Scope-Flash作用域"><a href="#Flash-Scope-Flash作用域" class="headerlink" title="Flash Scope (Flash作用域)"></a>Flash Scope (<code>Flash</code>作用域)</h3><blockquote><p>flash scope 和 session 作用很像，但是有两个区别</p></blockquote><ul><li>data are kept for only one request</li><li>the Flash cookie is not signed, making it possible for the user to modify it.</li></ul><p>session 的 cookie 会进行加密，而 flash 的 cookie 不会进行加密。</p><p><code>Flash作用域</code> 应该只用于在简单的 <code>非ajax</code> 应用程序上传输 成功/错误消息。由于数据只是为下一个请求保存的，而且在复杂的 <code>Web</code> 应用程序中不能保证请求顺序，所以 <code>Flash作用域</code> 受竞态条件的限制。(the Flash scope is subject to race conditions.)</p><h3 id="code-using-flash-scope"><a href="#code-using-flash-scope" class="headerlink" title="code using flash scope"></a>code using flash scope</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span> &#123; <span class="keyword">implicit</span> request =&gt;</span><br><span class="line">  <span class="type">Ok</span> &#123;</span><br><span class="line">    request.flash.get(<span class="string">&quot;success&quot;</span>).getOrElse(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span> &#123;</span><br><span class="line">  <span class="type">Redirect</span>(<span class="string">&quot;/home&quot;</span>).flashing(<span class="string">&quot;success&quot;</span> -&gt; <span class="string">&quot;The item has been created&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To retrieve the Flash scope value in your view, add an implicit Flash parameter</p><p>要在视图中检索Flash作用域值，请添加一个隐式Flash参数:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@()(<span class="keyword">implicit</span> flash: <span class="type">Flash</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">@flash</span>.get(<span class="string">&quot;success&quot;</span>).getOrElse(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="请求体解析-Body-Parsers"><a href="#请求体解析-Body-Parsers" class="headerlink" title="请求体解析 Body Parsers"></a>请求体解析 Body Parsers</h2><blockquote><p>什么是 body parsers</p></blockquote><p><code>HTTP请求</code> 是header 后面跟着 body。header 通常很小——它可以安全地缓冲在内存中，因此在 <code>Play</code> 中它是使用<code>RequestHeader</code> 类建模的。</p><p>然而，<code>body</code> 可能非常长，因此不在内存中缓冲，而是建模为流。然而，许多请求体有效负载 (<code>payloads</code>) 都很小，并且可以在内存中建模，因此为了将 <code>body流</code> 映射到内存中的对象，<code>Play</code> 提供了一个<code>BodyParser</code> 抽象。</p><p>由于 <code>Play</code> 是一个异步框架，传统的 <code>InputStream</code> 不能用于读取请求体——输入流阻塞了，当您调用 <code>read</code> 时，调用它的线程必须等待数据可用。</p><p>相反，<code>Play</code> 使用一个名为 <code>Akka Streams</code> 的异步流库。<strong>Akka Streams</strong> 是 <strong>Reactive Streams</strong> 的一个实现。</p><p>允许许多异步流api 无缝地协同工作,所以尽管传统 <code>InputStream</code> 的基础技术不适合使用, 但是<code>Akka Streams</code> 和 <code>Reactive Streams</code> 的整个生态系统的异步库将为你提供你需要的一切。</p><h3 id="使用-Body-Parsers"><a href="#使用-Body-Parsers" class="headerlink" title="使用 Body Parsers"></a>使用 Body Parsers</h3><blockquote><p>如果没有显式选择 <code>body parser</code>，<code>Play</code> 将使用的缺省的 <code>body parser</code> 将查看传入的 <code>Content-Type</code>，并相应地解析body。</p><p>例如，类型 <code>application/json</code> 的内容类型将被解析为 <code>JsValue</code>，而类型 <code>application/x-www-form- urlencoding</code> 的内容类型将被解析为 <code>Map[String, Seq[String]]</code></p></blockquote><p>默认的 <code>Body Parser</code> 生成 <code>AnyContent</code> 类型的 <code>Body</code>。<code>AnyContent</code> 支持的各种类型, 可以通过 <code>as方法</code> 访问，例如 <code>asJson</code>，它返回一个 Option[body类型]</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span> &#123; request: <span class="type">Request</span>[<span class="type">AnyContent</span>] =&gt;</span><br><span class="line">  <span class="keyword">val</span> body: <span class="type">AnyContent</span> = request.body</span><br><span class="line">  <span class="keyword">val</span> jsonBody: <span class="type">Option</span>[<span class="type">JsValue</span>] = body.asJson</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Expecting json body</span></span><br><span class="line">  jsonBody.map &#123; json =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (json \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    <span class="type">BadRequest</span>(<span class="string">&quot;Expecting application/json request body&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是默认 <code>body parser</code> 支持的类型映射 (<code>The following is a mapping of types supported by the default body parser</code>)</p><ul><li><strong>text/plain</strong>: <code>String</code>, accessible via <code>asText</code>.</li><li><strong>application/json</strong>: <a target="_blank" rel="noopener" href="https://static.javadoc.io/com.typesafe.play/play-json_2.12/2.6.9/play/api/libs/json/JsValue.html"><code>JsValue</code></a>, accessible via <code>asJson</code>.</li><li><strong>application/xml</strong>, <strong>text/xml</strong> or <strong>application/XXX+xml</strong>: <code>scala.xml.NodeSeq</code>, accessible via <code>asXml</code>.</li><li><strong>application/x-www-form-urlencoded</strong>: <code>Map[String, Seq[String]]</code>, accessible via <code>asFormUrlEncoded</code>.</li><li><strong>multipart/form-data</strong>: <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/api/scala/play/api/mvc/MultipartFormData.html"><code>MultipartFormData</code></a>, accessible via <code>asMultipartFormData</code>.</li><li>Any other content type: <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/api/scala/play/api/mvc/RawBuffer.html"><code>RawBuffer</code></a>, accessible via <code>asRaw</code>.</li></ul><p>默认的 body parser 在解析之前会 <code>try to determine</code> 请求是否具有 <code>body</code>。</p><p>根据 <code>HTTP</code> 规范(spec)，内容长度(Content-Length) 或 传输编码标头(Transfer-Encoding) 的出现都表示主体的存在，因此解析器只在出现其中一个标头时进行解析，或者在显式设置非空主体时在 FakeRequest 上进行解析。</p><p>如果希望在所有情况下解析主体，可以使用下面描述的anyContent主体解析器。</p><h3 id="显示的选择一个-Body-Parser"><a href="#显示的选择一个-Body-Parser" class="headerlink" title="显示的选择一个 Body Parser"></a>显示的选择一个 Body Parser</h3><p>如果希望显式地选择主体解析器，可以将 body parser 传递给 Action 的 apply或 async 方法。</p><p>Play 提供了许多开箱即用的 body parser (<code>Play provides a number of body parsers out of the box</code>)，</p><p>这是通过 <code>PlayBodyParsers</code> trait 提供的，它可以注入到您的控制器中。</p><p>例子，如果要定义一个 request body 期望是 Json Body 的 Action</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不是 Json类型会返回 415 Unsupported Media Type , 类似 Springmvc 在参数前面加 @RequestBody</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.json) &#123; request: <span class="type">Request</span>[<span class="type">JsValue</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (request.body \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述 body 的类型为 <code>JsValue</code>, 它不是 <code>Option</code> 类型的了。原因是 json body parser 会验证请求是否具有 <code>application/json</code> 的 <code>Content-Type</code>，如果不是，则会返回 415 的错误，即 <code>415 Unsupported Media Type</code>,这样我们就不用再次检查了。</p><p>这样依赖，这个方法将要对请求的type 有严格的限制了，客户端要清楚这一点。如果希望有更宽松的做法，即不是 ``application/json<code>类型的</code>Content-Type` 也能够进行解析，可以使用如下方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会返回 415，会尝试进行解析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.tolerantJson) &#123; request: <span class="type">Request</span>[<span class="type">JsValue</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + (request.body \ <span class="string">&quot;name&quot;</span>).as[<span class="type">String</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子，保存文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.file(to = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;/tmp/upload&quot;</span>))) &#123; request: <span class="type">Request</span>[<span class="type">File</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-Body-Parsers-Combining-body-parsers"><a href="#组合-Body-Parsers-Combining-body-parsers" class="headerlink" title="组合 Body Parsers (Combining body parsers)"></a>组合 Body Parsers (Combining body parsers)</h3><p>在上一个保存文件的示例中，所有请求 bodies 都存储在同一个文件中 (<code>/tmp/upload</code>)，这是存在问题的。</p><p>我们可以编写另一个自定义主体解析器，它从请求会话中提取用户名，为每个用户提供一个惟一的文件</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> storeInUserFile: <span class="type">BodyParser</span>[<span class="type">File</span>] = parse.using &#123; request =&gt;</span><br><span class="line">  request.session.get(<span class="string">&quot;username&quot;</span>).map &#123; user =&gt;</span><br><span class="line">    parse.file(to = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;/tmp/&quot;</span> + user + <span class="string">&quot;.upload&quot;</span>))</span><br><span class="line">  &#125;.getOrElse &#123;</span><br><span class="line">    sys.error(<span class="string">&quot;You don&#x27;t have the right to upload here&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义 body parser</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span></span>: <span class="type">Action</span>[<span class="type">File</span>] = <span class="type">Action</span>(storeInUserFile) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们并没有真正编写自己的 <code>BodyParser</code>，而只是组合现有的 <code>BodyParser</code>。这通常就足够了，应该涵盖大多数用例。高级主题部分将介绍从头编写 <code>BodyParser</code></p><h3 id="Max-content-length"><a href="#Max-content-length" class="headerlink" title="Max content length"></a>Max content length</h3><p>基于文本的 body parsers (例如 text、json、xml 或 formurlencoding) 需要有一个最大内容长度。因为它们必须将所有内容加载到内存中。默认情况下，它们将解析的最大内容长度是 <code>100KB</code>。可以通过指定 <code>play.http.parser</code> 来覆盖它。可以通过在 <code>application.conf</code> 指定 <code>maxMemoryBuffer</code>属性来改变这个大小。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.conf</span></span><br><span class="line"><span class="meta">play.http.parser.maxMemoryBuffer</span>=<span class="string">128K</span></span><br></pre></td></tr></table></figure><p>对于将内容缓冲 (<code>buffer</code>) 到磁盘上的 body parser，例如 <code>raw parser</code> 或 <code>multipart/form-data</code> 等，它们的最大内容长度使用 <code>play.http.parser</code> 的 <code>maxDiskBuffer</code> 来进行指定。</p><p><code>maxDiskBuffer</code>属性，默认值为<code>10MB</code>。<code>multipart/form-data</code> 解析器还强制为数据字段的聚合设置文本最大长度属性。</p><p>您还可以通过在 <code>Action</code> 中显示指定来覆盖默认的最大长度。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept only 10KB of data.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.text(maxLength = <span class="number">1024</span> * <span class="number">10</span>)) &#123; request: <span class="type">Request</span>[<span class="type">String</span>]  =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got: &quot;</span> + text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can also wrap any body parser with <code>maxLength</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept only 10KB of data.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span> </span>= <span class="type">Action</span>(parse.maxLength(<span class="number">1024</span> * <span class="number">10</span>, storeInUserFile)) &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Saved the request content to &quot;</span> + request.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Writing-a-custom-body-parser"><a href="#Writing-a-custom-body-parser" class="headerlink" title="Writing a custom body parser"></a>Writing a custom body parser</h3><blockquote><p>我们可以实现 <code>BodyParser</code> 特质来自定义 body parser，这个 trait 是一个很简单的函数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BodyParser</span>[+<span class="type">A</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">RequestHeader</span> =&gt; <span class="type">Accumulator</span>[<span class="type">ByteString</span>, <span class="type">Either</span>[<span class="type">Result</span>, <span class="type">A</span>]]</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p>接收一个 <code>RequestHeader</code>，这样我们可以检查关于请求的信息，它通常用于获取 Content-Type,这样 body 就会被正确的解析。</p></li><li><p>函数的返回类型是 <code>Accumulator</code>，它是一个累加器。<code>Accumulator</code> 是 围绕 <code>Akka Streams Sink</code> 的一层薄层。<code>Accumulator</code> 异步地将 <code>streams of elements</code> 加到结果中，它可以通过传入 <code>Akka Streams Source</code> 来运行。这将返回一个 <code>Future</code>，并且在累加器完成时，<code>future</code>得到完成。</p></li><li><p><code>Accumulator</code> 本质上和 Sink[E,Future[A]] 一样，事实上，Accumulator 是 Sink 的一个包装器。但是最大的区别是 Accumulator 提供了方便的方法，比如 map、mapFuture、recover 等等。</p></li><li><p><code>Accumulator</code> 用于将结果作为一个 <code>promise</code> 来处理，其中 Sink 要求将所有的操作包装在 mapMaterializedValue 的调用中。</p></li><li><p>Accumulator 的 apply 返回 ByteString 类型的元素，这些元素本质上是字节数组，但与 byte[] 不同的是，<code>ByteString</code> 是不可变的，它的许多操作(如 slicing 或者 appending) 都是在固定的时间内完成的。</p></li></ul><p><code>Accumulator</code> 的返回类型是 <code>Either[Result, A]</code>，它要么返回一个 <code>Result</code>，要么返回一个类型 <code>A</code>。通常在发生错误的情况下返回 <code>Result</code>。例如，如果 body 解析失败，比如 Content-Type 与 Body Parser 接受的类型不匹配，或者内存缓冲区溢出了。当 <code>body parser</code> 返回一个 <code>result</code> 时，这将缩短 <code>action</code> 的处理时间，<code>action</code> 的结果将里脊返回，并且永远不会调用该操作。</p><h4 id="将-Body-引向别处-Directing-the-body-elsewhere"><a href="#将-Body-引向别处-Directing-the-body-elsewhere" class="headerlink" title="将 Body 引向别处 Directing the body elsewhere"></a>将 Body 引向别处 Directing the body elsewhere</h4><blockquote><p>编写 body parser 的一个常见用例是，当您实际上不想解析主体时，而是想将它以流的形式引入到其他地方(<code>stream it elsewhere</code>)。为此，您可以定义一个自定义 body parser</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject._</span><br><span class="line"><span class="keyword">import</span> play.api.mvc._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.streams._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.ws._</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span></span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">ByteString</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyController</span> <span class="title">@Inject</span>(<span class="params"></span>) (<span class="params">ws: <span class="type">WSClient</span>, val controllerComponents: <span class="type">ControllerComponents</span></span>)(<span class="params">implicit ec: <span class="type">ExecutionContext</span></span>) <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span></span>(request: <span class="type">WSRequest</span>): <span class="type">BodyParser</span>[<span class="type">WSResponse</span>] = <span class="type">BodyParser</span> &#123; req =&gt;</span><br><span class="line">    <span class="type">Accumulator</span>.source[<span class="type">ByteString</span>].mapFuture &#123; source =&gt;</span><br><span class="line">      request</span><br><span class="line">    	.withBody(source)</span><br><span class="line">        .execute()</span><br><span class="line">        .map(<span class="type">Right</span>.apply)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myAction</span> </span>= <span class="type">Action</span>(forward(ws.url(<span class="string">&quot;https://example.com&quot;</span>))) &#123; req =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Uploaded&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Akka-Streams-进行自定义的解析"><a href="#使用-Akka-Streams-进行自定义的解析" class="headerlink" title="使用 Akka Streams 进行自定义的解析"></a>使用 Akka Streams 进行自定义的解析</h4><blockquote><p>Custom parsing using Akka Streams</p></blockquote><p>在很少的情况下，可能需要使用 <code>Akka Streams</code> 编写自定义解析器。在大多数情况下，先用 <code>ByteString</code> 缓冲 body 就足够了，这通常提供一种简单得多的解析方法，因为您可以对主体使用强制方法和随机访问。</p><p>但是，当这不可行时，例如需要解析的主体太长而无法装入内存时，则可能需要编写自定义主体解析器。</p><p>关于如何使用 <code>Akka Streams</code> 的完整描述超出了本文档的范围——最好从阅读 <code>Akka Streams</code> 文档开始。但是，下面显示了一个 <code>CSV</code> 解析器，它基于<code>Akka Streams</code> 烹饪书中 <code>ByteStrings</code> 文档流的解析行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.mvc.<span class="type">BodyParser</span></span><br><span class="line"><span class="keyword">import</span> play.api.libs.streams._</span><br><span class="line"><span class="keyword">import</span> akka.util.<span class="type">ByteString</span></span><br><span class="line"><span class="keyword">import</span> akka.stream.scaladsl._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> csv: <span class="type">BodyParser</span>[<span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">String</span>]]] = <span class="type">BodyParser</span> &#123; req =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A flow that splits the stream into CSV lines</span></span><br><span class="line">  <span class="keyword">val</span> sink: <span class="type">Sink</span>[<span class="type">ByteString</span>, <span class="type">Future</span>[<span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">String</span>]]]] = <span class="type">Flow</span>[<span class="type">ByteString</span>]</span><br><span class="line">    <span class="comment">//我们按照 new line character 进行分割，每行最多允许 1000个字符。</span></span><br><span class="line">    .via(<span class="type">Framing</span>.delimiter(<span class="type">ByteString</span>(<span class="string">&quot;\n&quot;</span>), <span class="number">1000</span>, allowTruncation = <span class="literal">true</span>))</span><br><span class="line">    <span class="comment">//把每一行变成一个String，用逗号分隔</span></span><br><span class="line">    .map(_.utf8String.trim.split(<span class="string">&quot;,&quot;</span>).toSeq)</span><br><span class="line">    <span class="comment">// 现在我们使用 fold 将其变为一个列表 List</span></span><br><span class="line">    .toMat(<span class="type">Sink</span>.fold(<span class="type">Seq</span>.empty[<span class="type">Seq</span>[<span class="type">String</span>]])(_ :+ _))(<span class="type">Keep</span>.right)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 body 转为为 Either right 返回</span></span><br><span class="line">  <span class="type">Accumulator</span>(sink).map(<span class="type">Right</span>.apply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>🎮 Play 入门与学习(一) Controller &amp; Router &amp; BodyParser</p><p><a href="http://leihuazhe.github.io/p/468029a2.html">http://leihuazhe.github.io/p/468029a2.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zane Ray</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-12-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/gathering_qr.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/p/beeb0951.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">🎮 Play 入门与学习(二) Action Composition</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/p/da1f3173.html"><span class="level-item">使用 Docker 容器方式搭建 Zookeeper 集群</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget"><link href="/music/APlayer.min.css"><div id="aplayer" style="margin:0 auto"></div><script src="/music/APlayer.min.js"></script><script src="/music/APlayer_Music.js"></script></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Controllers"><span class="level-left"><span class="level-item">1</span><span class="level-item">Controllers</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Action"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Action</span></span></a></li><li><a class="level is-mobile" href="#Results"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Results</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Http-Routing"><span class="level-left"><span class="level-item">2</span><span class="level-item">Http Routing</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#语法"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">语法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#操作处理结果返回"><span class="level-left"><span class="level-item">3</span><span class="level-item">操作处理结果返回</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Manipulating-Http-headers-操纵-Http-头"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Manipulating Http headers (操纵 Http 头)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Session-and-Flash"><span class="level-left"><span class="level-item">4</span><span class="level-item">Session and Flash</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Session-存储"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Session 存储</span></span></a></li><li><a class="level is-mobile" href="#Flash-Scope-Flash作用域"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Flash Scope (Flash作用域)</span></span></a></li><li><a class="level is-mobile" href="#code-using-flash-scope"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">code using flash scope</span></span></a></li></ul></li><li><a class="level is-mobile" href="#请求体解析-Body-Parsers"><span class="level-left"><span class="level-item">5</span><span class="level-item">请求体解析 Body Parsers</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用-Body-Parsers"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">使用 Body Parsers</span></span></a></li><li><a class="level is-mobile" href="#显示的选择一个-Body-Parser"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">显示的选择一个 Body Parser</span></span></a></li><li><a class="level is-mobile" href="#组合-Body-Parsers-Combining-body-parsers"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">组合 Body Parsers (Combining body parsers)</span></span></a></li><li><a class="level is-mobile" href="#Max-content-length"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">Max content length</span></span></a></li><li><a class="level is-mobile" href="#Writing-a-custom-body-parser"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">Writing a custom body parser</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#将-Body-引向别处-Directing-the-body-elsewhere"><span class="level-left"><span class="level-item">5.5.1</span><span class="level-item">将 Body 引向别处 Directing the body elsewhere</span></span></a></li><li><a class="level is-mobile" href="#使用-Akka-Streams-进行自定义的解析"><span class="level-left"><span class="level-item">5.5.2</span><span class="level-item">使用 Akka Streams 进行自定义的解析</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/p/ac45747d.html"><img src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></figure><div class="media-content"><p class="date"><time datetime="2021-05-07T02:54:53.000Z">2021-05-07</time></p><p class="title"><a href="/p/ac45747d.html">Spring 学习 [1]</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/p/a8949b93.html"><img src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></figure><div class="media-content"><p class="date"><time datetime="2019-04-01T11:43:12.000Z">2019-04-01</time></p><p class="title"><a href="/p/a8949b93.html">Scala实战 -- 对List中的部分元素进行合并操作</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-09T16:00:00.000Z">2019-01-10</time></p><p class="title"><a href="/p/6e951315.html">🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-24T16:00:00.000Z">2018-12-25</time></p><p class="title"><a href="/p/87290a79.html">🎮 Play 入门与学习(五) Dependency Injection</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-16T16:00:00.000Z">2018-12-17</time></p><p class="title"><a href="/p/fe729f21.html">🎮 Play 入门与学习(三) Asynchronous results</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Play/"><span class="tag">Play</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a><p class="is-size-7"><span>&copy; 2021 Zane Ray</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script></body></html>
<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>从示例逐渐理解Scala尾递归 - 非普通程序员</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非普通程序员"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非普通程序员"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文为当年初学 Scala 文章时的一篇分享，主要通过示例的形式来介绍Scala尾递归"><meta property="og:type" content="blog"><meta property="og:title" content="从示例逐渐理解Scala尾递归"><meta property="og:url" content="http://leihuazhe.github.io/p/b2d7d4cd.html"><meta property="og:site_name" content="非普通程序员"><meta property="og:description" content="本文为当年初学 Scala 文章时的一篇分享，主要通过示例的形式来介绍Scala尾递归"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://leihuazhe.github.io/img/og_image.png"><meta property="article:published_time" content="2018-11-11T16:00:00.000Z"><meta property="article:modified_time" content="2021-05-06T04:35:14.657Z"><meta property="article:author" content="Zane Ray"><meta property="article:tag" content="Scala"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://leihuazhe.github.io/p/b2d7d4cd.html"},"headline":"非普通程序员","image":["http://leihuazhe.github.io/img/og_image.png"],"datePublished":"2018-11-11T16:00:00.000Z","dateModified":"2021-05-06T04:35:14.657Z","author":{"@type":"Person","name":"Zane Ray"},"description":"本文为当年初学 Scala 文章时的一篇分享，主要通过示例的形式来介绍Scala尾递归"}</script><link rel="canonical" href="http://leihuazhe.github.io/p/b2d7d4cd.html"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fa fa-bolt" aria-hidden="true"></i> 从示例逐渐理解Scala尾递归</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-11-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">21 分钟读完 (大约3165个字)</span></div></div><div class="content"><h3 id="1-递归与尾递归"><a href="#1-递归与尾递归" class="headerlink" title="1.递归与尾递归"></a>1.递归与尾递归</h3><h4 id="1-1-递归"><a href="#1-1-递归" class="headerlink" title="1.1 递归"></a>1.1 递归</h4><h5 id="1-1-1-递归定义"><a href="#1-1-1-递归定义" class="headerlink" title="1.1.1 递归定义"></a>1.1.1 递归定义</h5><blockquote><p>递归大家都不陌生，一个函数直接或间接的调用它自己本身，就是递归。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以执行多次重复的计算。</p></blockquote><h5 id="1-1-2-递归的条件"><a href="#1-1-2-递归的条件" class="headerlink" title="1.1.2 递归的条件"></a>1.1.2 递归的条件</h5><p>一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p><p>以递归方式实现阶乘函数的实现：</p><p>代码清单1-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">factorial</span><span class="params">(n:Int)</span>: Long </span>=&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> n * factorial(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单中，<code>if(n &lt;= 0) 1</code>是递归返回段，<code>else</code>后面部分是递归前进段。</p><h5 id="1-1-3-递归的缺点："><a href="#1-1-3-递归的缺点：" class="headerlink" title="1.1.3 递归的缺点："></a>1.1.3 递归的缺点：</h5><ul><li>需要保持调用堆栈,如代码清单1-1,每一次递归都要保存<code>n*factorial(n-1)</code>栈帧信息。如果调用次数太多，可能会导致栈溢出</li><li>效率会比较低，递归就是不断的调用自己本身，如果方法本身比较复杂，每次调用自己效率会较低。</li></ul><h4 id="1-2-尾递归"><a href="#1-2-尾递归" class="headerlink" title="1.2 尾递归"></a>1.2 尾递归</h4><h5 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h5><p>尾递归的定义比较简单，即<strong>函数在函数体最后调用它本身，就被称为尾递归</strong>。</p><p>我们可以这样理解尾递归</p><ul><li>所有递归形式的调用都出现在函数的末尾</li><li>递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分</li></ul><h5 id="1-2-2-例子程序"><a href="#1-2-2-例子程序" class="headerlink" title="1.2.2 例子程序"></a>1.2.2 例子程序</h5><p>下面我们使用尾递归的模式实现上面的阶乘<br><br>代码清单1-2</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n:<span class="type">Int</span>):<span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(main:<span class="type">Int</span>,aggr:<span class="type">Int</span>): <span class="type">Long</span> =&#123;</span><br><span class="line">        <span class="keyword">if</span>(main &lt;= <span class="number">0</span>) aggr</span><br><span class="line">        <span class="keyword">else</span> factorial(main<span class="number">-1</span>,main*aggr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   factorial(n,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以比较代码清单1-1和1-2<br>1-1中，每次的递归调用都要本身时依赖n这个变量，所以，它只能是个不同的递归。</p><p>1-2中，函数<code>factorial</code>每次返回的都是它自己本身，没有依赖任何值。它做的是将main每次减1，将aggr每次乘main，然后将这两个结果作为下一次递归调用的参数，进行调用。</p><p>尾递归的核心思想是通过参数来传递每一次的调用结果，达到不压栈。它维护着一个迭代器和一个累加器。</p><h4 id="1-3-循环"><a href="#1-3-循环" class="headerlink" title="1.3 循环"></a>1.3 循环</h4><p>循环能够解决大多数的累计问题，循环可以完成累加和迭代，处理问题比较简单，思想也比较符合，容易理解</p><p>n的阶乘循环的写法</p><p>代码清单1-3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibfor</span><span class="params">(n:Int)</span>: Int </span>=&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        m = m * i</span><br><span class="line">    &#125;</span><br><span class="line">    m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环版本，会有var的可变变量，我们知道，函数式编程就应该更函数范，我们尽可能的要用vals去替换可变的vars<br>所以我们可以使用递归的方式来消除掉vars</p><hr><h3 id="2-改写-循环，递归-TO-尾递归"><a href="#2-改写-循环，递归-TO-尾递归" class="headerlink" title="2.改写 (循环，递归 TO 尾递归)"></a>2.改写 (循环，递归 TO 尾递归)</h3><blockquote><p>事实上，scala都是将尾递归直接编译成循环模式的。所以我们可以大胆的说，所有的循环模式都能改写为尾递归的写法模式</p></blockquote><p>尾递归会维护一个或多个累计值(<code>aggregate</code>)参数和一个迭代参数。我们具体分析</p><h4 id="2-1迭代器和累计器"><a href="#2-1迭代器和累计器" class="headerlink" title="2.1迭代器和累计器"></a>2.1迭代器和累计器</h4><ul><li><p>累计值参数<code>aggregate</code>将每次循环产生的结果进行累计，然后传到下一次的调用中。</p></li><li><p>迭代器，和普通递归或循环一样，每次递归或循环后，改变一次。(如for(i=0;i&lt;1-;i++)里面的i)</p></li></ul><h4 id="2-2-普通递归转换为尾递归"><a href="#2-2-普通递归转换为尾递归" class="headerlink" title="2.2 普通递归转换为尾递归"></a>2.2 普通递归转换为尾递归</h4><blockquote><p>并不是所有的递归都能改写为尾递归，那些比较复杂的递归调用时无法优化为尾递归的。但是大部分还是能够进行优化的。</p></blockquote><p>代码清单1-1 和代码清单 1-2 是求n阶阶乘的普通递归与尾递归的写法，前者没有进行优化，每次调用都会压栈。<br>后者，通过定义一个<code>aggregate</code>(累计)参数，对每一次调用后的结果做一次累计,而另一个参数main称为迭代器,每一次调用都会-1，当达到符合返回的条件时，将累计值返回。</p><h4 id="2-3-循环（while-loop）转为尾递归（tail-recursion）"><a href="#2-3-循环（while-loop）转为尾递归（tail-recursion）" class="headerlink" title="2.3 循环（while loop）转为尾递归（tail recursion）"></a>2.3 循环（while loop）转为尾递归（tail recursion）</h4><blockquote><p>正如上文循环例子所述，存在<code>var</code>,函数式编程就应该有函数范，我们尽量使用<code>val</code>来代替，所以接下来来看，怎么将循环转换为尾递归</p></blockquote><h5 id="2-3-1-循环和尾递归"><a href="#2-3-1-循环和尾递归" class="headerlink" title="2.3.1 循环和尾递归"></a>2.3.1 循环和尾递归</h5><blockquote><p>正如上文所说的迭代器和累计器，循环和尾递归都有这两个概念</p></blockquote><p><strong>迭代器</strong>和<strong>累计器</strong></p><p>尾递归每一次的调用自身都会有一次累加（或者累积，累减等），然后会有一个迭代器进行迭代，一个累加器进行累加迭代的结果，然后作为参数，再去调用自身。</p><h5 id="2-3-2-如上面求n阶乘的尾递归例子："><a href="#2-3-2-如上面求n阶乘的尾递归例子：" class="headerlink" title="2.3.2 如上面求n阶乘的尾递归例子："></a>2.3.2 如上面求n阶乘的尾递归例子：</h5><ul><li><p>1.循环的例子中存在一个<code>var</code>，它在每次循环中充当一个累加器的角色，累加每一次的迭代结果，而每次迭代过程就是<code>m*i</code>的一个过程。</p></li><li><p>2.尾递归也是一样的思想，以<code>main</code>作为迭代器，每次递减<code>1</code>，类似循环里的<code>i</code>，以<code>aggr</code>作为累加器，每次累计迭代的结果，类似循环的<code>m</code>。</p></li><li><p>3.相对于普通的递归，这里尾递归多的一个参数就是累加器<code>aggr</code>，用于累计每一次递归迭代的结果。这样做的目的就是每一次调用的结果可以作为下一次函数调用的参数。</p></li></ul><h3 id="3-具体示例-加深理解"><a href="#3-具体示例-加深理解" class="headerlink" title="3.具体示例-加深理解"></a>3.具体示例-加深理解</h3><h4 id="3-1-例子1-求斐波拉契数列"><a href="#3-1-例子1-求斐波拉契数列" class="headerlink" title="3.1 例子1 - 求斐波拉契数列"></a>3.1 例子1 - 求斐波拉契数列</h4><ul><li><p>普通递归写法（性能较低）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacci</span><span class="params">(n:Int)</span>: Long </span>=&#123;</span><br><span class="line">    n match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环的写法（循环写法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacciFor</span><span class="params">(n:Int)</span>: Int </span>= &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">2</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(i &lt;- <span class="number">2</span> until n) &#123;</span><br><span class="line">            <span class="keyword">var</span> aggr = current + next</span><br><span class="line">            current = next</span><br><span class="line">            next = aggr</span><br><span class="line">        &#125;   </span><br><span class="line">        next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，aggr是累加器，然后将累加的值赋值给下一个next，而current等于next，每一次循环，都有给current和next赋予新值,当累加完成后，返回next的值。</p></li><li><p>尾递归写法</p><blockquote><p>如何对其进行优化？<br><br>仔细分析,上面的普通循环，每一轮两个值都在改变，然后又一个累加器aggr，对这两个值进行累加，并赋值给更大的next，然后进入下一次循环。</p></blockquote></li></ul><p>尾递归，我们也是同样的做法，定义两个接受值，当前的，和下一个，然后需要一个累加值。</p><p>这里普通方法的递归调用是两个原函数相加，涉及到的变量有 n , n-1 , n-2<br><br>因此,我们在考虑使用尾递归时，可能也需要使用到三个参数，初略涉及，尾递归函数需要使用三个参数，于是改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibonacci</span><span class="params">(n: Int)</span>: Long </span>= &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function">def <span class="title">fibonacciTail</span><span class="params">(main: Int, current: Int, next: Int)</span>: Long </span>= &#123;</span><br><span class="line">      main match &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; next</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; fibonacciByTail(main - <span class="number">1</span>, next, current+next)</span><br><span class="line">      &#125;</span><br><span class="line">      fibonacciTail(n, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fibonacciTail(n,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用尾递归和模式匹配。每一次调用自身，将next赋值给current，然后累加current和next的值赋值给新的next值，call下一轮。思想上和上面循环很像。但是更函数范，消除掉了var。</p><hr><h4 id="3-2-例子2-loadBalance算法"><a href="#3-2-例子2-loadBalance算法" class="headerlink" title="3.2 例子2 - loadBalance算法"></a>3.2 例子2 - loadBalance算法</h4><blockquote><p>需求，设计一个程序，传入一个比例数组，比如Array（1,3,6,一直调用该函数，返回的3个节点的比例也应该如传入的1:3:6的比例一样。</p></blockquote><ul><li>我最开始使用<code>for循环</code>和<code>return</code>实现了这个需求，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">loadBalance</span><span class="params">(arr:Array[Int])</span>: Int </span>=&#123;</span><br><span class="line">      <span class="comment">//根据传入的数组使用scan高级函数进行变化，具体算法例子：</span></span><br><span class="line">      <span class="comment">//eg （1，3，6） -&gt;  (1,4,10)</span></span><br><span class="line">      <span class="comment">//这样的目的是，随机出来的值为0-1时，选择第一个节点，为1-4时选择第二节点，依次类推</span></span><br><span class="line">      val segment:Array[Int] = arr.scan(<span class="number">0</span>)(_ + _).drop(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//随机数的范围，根据传入的数组的数据之和来，例如上的便是 10 ，产生的随机数介于0 - 9 之间</span></span><br><span class="line">      val weightSum:Int  = arr.sum</span><br><span class="line">      val random = <span class="keyword">new</span> Random().nextInt(weightSum)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until segment.size )&#123;</span><br><span class="line">        <span class="keyword">if</span>(random &lt; segment(i))&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我通过测试程序调用1万次该方法，返回的随机节点的比例是符合传入的比例的。</li></ul><p><strong>思考</strong>：<br><br>虽然这样可以达到目的，但是代码写的既不优雅，在scala函数式编程中最好是不能使用<code>return</code>来强行打断函数执行的，并且在最后，我还需要去写一个0来作为默认返回。</p><h5 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h5><blockquote><p>大部分或者几乎所有的for循环都能使用尾递归进行优化，那上面这个代码如何进行优化呢？</p></blockquote><p><strong>思路</strong>：上文的for循环，每次增加的是<code>segment</code>的下标，每循环一次 +1，因此，我们在设计尾递归时，可以使用一个参数来实现相同的功能，而另一个参数应该就是产生的随机数。<br>ok，我们来进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">loadBalance</span><span class="params">(arr:Array[Int])</span>: Int </span>=&#123;</span><br><span class="line">      <span class="comment">//根据传入的数组使用scan高级函数进行变化，具体算法例子：</span></span><br><span class="line">      <span class="comment">//eg （1，3，6） -&gt;  (1,4,10)</span></span><br><span class="line">      <span class="comment">//这样的目的是，随机出来的值为0-1时，选择第一个节点，为1-4时选择第二节点，依次类推</span></span><br><span class="line">      val segment:Array[Int] = arr.scan(<span class="number">0</span>)(_ + _).drop(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//随机数的范围，根据传入的数组的数据之和来，例如上的便是 10 ，产生的随机数介于0 - 9 之间</span></span><br><span class="line">      val weightSum:Int  = arr.sum</span><br><span class="line">      val random = <span class="keyword">new</span> Random().nextInt(weightSum)</span><br><span class="line">      <span class="comment">//写一个内部方法</span></span><br><span class="line">      <span class="function">def <span class="title">loadUtil</span><span class="params">(rand:Int,index:Int)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//assert，保证程序健壮</span></span><br><span class="line">        <span class="keyword">assert</span>(index &lt; arr.length &amp;&amp; arr(index) &gt;= <span class="number">0</span>)</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(rand &lt; segment(index)) index</span><br><span class="line">        <span class="keyword">else</span> loadUtil(rand,index+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    loadUtil(random,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，使用尾递归的做法，代码会非常的优雅，现在写一个测试类进行测试！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    val arr = Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">    val countMap = collection.mutable.Map[Int,Int]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(_ &lt;- <span class="number">1</span> until <span class="number">100000</span>) &#123;</span><br><span class="line">      val res = loadBalance(arr)</span><br><span class="line"></span><br><span class="line">      countMap.get(res) match &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">Some</span><span class="params">(x)</span> </span>=&gt; countMap += (res -&gt; (x+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">case</span> None =&gt; countMap +=(res -&gt; <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countMap.foreach(x =&gt; &#123;</span><br><span class="line">      println(s<span class="string">&quot;$&#123;x._1&#125;  调用次数 $&#123;x._2&#125;&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试10000次，返回结果如下：</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>  调用次数 <span class="number">69966</span></span><br><span class="line"><span class="number">1</span>  调用次数 <span class="number">20028</span></span><br><span class="line"><span class="number">0</span>  调用次数 <span class="number">10005</span></span><br></pre></td></tr></table></figure><p>如上，测试是通过的！是不是很优雅，感受到了尾递归的魅力？</p><hr><h3 id="4-scala编译器对尾递归的优化"><a href="#4-scala编译器对尾递归的优化" class="headerlink" title="4. scala编译器对尾递归的优化"></a>4. scala编译器对尾递归的优化</h3><p>Scala 对形式上严格的尾递归进行了优化，对于严格的尾递归，不需要注解</p><p>@tailrec 可以让编译器去检查该函数到底是不是尾递归，如果不是会报错</p><h5 id="具体以上面那个计算斐波拉契数列的例子进行性能分析"><a href="#具体以上面那个计算斐波拉契数列的例子进行性能分析" class="headerlink" title="具体以上面那个计算斐波拉契数列的例子进行性能分析"></a>具体以上面那个计算斐波拉契数列的例子进行性能分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def time[T](t: =&gt;T): T  = &#123;</span><br><span class="line">    val b = System.nanoTime()</span><br><span class="line">    val x = t</span><br><span class="line">    val e = System.nanoTime();</span><br><span class="line">    println(<span class="string">&quot;time: &quot;</span> + (e-b)/<span class="number">1000</span> + <span class="string">&quot;us&quot;</span>);</span><br><span class="line">    x</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count: Long = <span class="number">0</span></span><br><span class="line">  <span class="comment">// @tailrec</span></span><br><span class="line">  <span class="function">def <span class="title">fib2</span><span class="params">(n: Long)</span>: Long </span>= &#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    n match &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        fib2(n-<span class="number">1</span>) + fib2(n-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面时间和调用次数的测试，可以得出尾递归的性能消耗很低，速度很快。</p><h4 id="4-1-编译器对尾递归的优化"><a href="#4-1-编译器对尾递归的优化" class="headerlink" title="4.1 编译器对尾递归的优化"></a>4.1 编译器对尾递归的优化</h4><p>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。</p><p>scala编译器会察觉到尾递归，并对其进行优化，将它编译成循环的模式。</p><h4 id="4-2-Scala尾递归的限制"><a href="#4-2-Scala尾递归的限制" class="headerlink" title="4.2 Scala尾递归的限制"></a>4.2 Scala尾递归的限制</h4><ul><li><p>尾递归有严格的要求，就是最后一个语句是递归调用，因此写法比较严格。</p></li><li><p>尾递归最后调用的必须是它本身，间接的赋值它本身的函数也无法进行优化。</p></li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>循环调用都是一个累计器和一个迭代器的作用，同理，尾递归也是如此，它也是通过累加和迭代将结果赋值给新一轮的调用，通过这个思路，我们可以轻松的将循环转换为尾递归的形式。</p><p>[本文完，欢迎转载，转载请注明出处]</p></div><div class="article-licensing box"><div class="licensing-title"><p>从示例逐渐理解Scala尾递归</p><p><a href="http://leihuazhe.github.io/p/b2d7d4cd.html">http://leihuazhe.github.io/p/b2d7d4cd.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zane Ray</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-11-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/gathering_qr.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/p/2ed76eda.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">从示例逐渐理解Scala隐式转换</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/p/c81b0f21.html"><span class="level-item">程序员如何保持优秀</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget"><link href="/music/APlayer.min.css"><div id="aplayer" style="margin:0 auto"></div><script src="/music/APlayer.min.js"></script><script src="/music/APlayer_Music.js"></script></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-递归与尾递归"><span class="level-left"><span class="level-item">1</span><span class="level-item">1.递归与尾递归</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-递归"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1.1 递归</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-递归定义"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">1.1.1 递归定义</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-递归的条件"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">1.1.2 递归的条件</span></span></a></li><li><a class="level is-mobile" href="#1-1-3-递归的缺点："><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">1.1.3 递归的缺点：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-尾递归"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">1.2 尾递归</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-2-1-定义"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">1.2.1 定义</span></span></a></li><li><a class="level is-mobile" href="#1-2-2-例子程序"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">1.2.2 例子程序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-循环"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">1.3 循环</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-改写-循环，递归-TO-尾递归"><span class="level-left"><span class="level-item">2</span><span class="level-item">2.改写 (循环，递归 TO 尾递归)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1迭代器和累计器"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">2.1迭代器和累计器</span></span></a></li><li><a class="level is-mobile" href="#2-2-普通递归转换为尾递归"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">2.2 普通递归转换为尾递归</span></span></a></li><li><a class="level is-mobile" href="#2-3-循环（while-loop）转为尾递归（tail-recursion）"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">2.3 循环（while loop）转为尾递归（tail recursion）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-3-1-循环和尾递归"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">2.3.1 循环和尾递归</span></span></a></li><li><a class="level is-mobile" href="#2-3-2-如上面求n阶乘的尾递归例子："><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">2.3.2 如上面求n阶乘的尾递归例子：</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#3-具体示例-加深理解"><span class="level-left"><span class="level-item">3</span><span class="level-item">3.具体示例-加深理解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-例子1-求斐波拉契数列"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 例子1 - 求斐波拉契数列</span></span></a></li><li><a class="level is-mobile" href="#3-2-例子2-loadBalance算法"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 例子2 - loadBalance算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#尾递归优化"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">尾递归优化</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#4-scala编译器对尾递归的优化"><span class="level-left"><span class="level-item">4</span><span class="level-item">4. scala编译器对尾递归的优化</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#具体以上面那个计算斐波拉契数列的例子进行性能分析"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">具体以上面那个计算斐波拉契数列的例子进行性能分析</span></span></a></li></ul><li><a class="level is-mobile" href="#4-1-编译器对尾递归的优化"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">4.1 编译器对尾递归的优化</span></span></a></li><li><a class="level is-mobile" href="#4-2-Scala尾递归的限制"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">4.2 Scala尾递归的限制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-总结"><span class="level-left"><span class="level-item">5</span><span class="level-item">5. 总结</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/p/ac45747d.html"><img src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></figure><div class="media-content"><p class="date"><time datetime="2021-05-07T02:54:53.000Z">2021-05-07</time></p><p class="title"><a href="/p/ac45747d.html">Spring 学习 [1]</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/p/a8949b93.html"><img src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></figure><div class="media-content"><p class="date"><time datetime="2019-04-01T11:43:12.000Z">2019-04-01</time></p><p class="title"><a href="/p/a8949b93.html">Scala实战 -- 对List中的部分元素进行合并操作</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-09T16:00:00.000Z">2019-01-10</time></p><p class="title"><a href="/p/6e951315.html">🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-24T16:00:00.000Z">2018-12-25</time></p><p class="title"><a href="/p/87290a79.html">🎮 Play 入门与学习(五) Dependency Injection</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-16T16:00:00.000Z">2018-12-17</time></p><p class="title"><a href="/p/fe729f21.html">🎮 Play 入门与学习(三) Asynchronous results</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Play/"><span class="tag">Play</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a><p class="is-size-7"><span>&copy; 2021 Zane Ray</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script></body></html>
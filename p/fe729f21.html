<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>🎮 Play 入门与学习(三) Asynchronous results - 非普通程序员</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非普通程序员"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非普通程序员"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本章我们将讲解使用 Play 进行异步非阻塞编程情况下，如何处理异步返回结果的问题。"><meta property="og:type" content="blog"><meta property="og:title" content="🎮 Play 入门与学习(三) Asynchronous results"><meta property="og:url" content="http://leihuazhe.github.io/p/fe729f21.html"><meta property="og:site_name" content="非普通程序员"><meta property="og:description" content="本章我们将讲解使用 Play 进行异步非阻塞编程情况下，如何处理异步返回结果的问题。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://leihuazhe.github.io/img/og_image.png"><meta property="article:published_time" content="2018-12-16T16:00:00.000Z"><meta property="article:modified_time" content="2021-05-06T04:35:14.653Z"><meta property="article:author" content="Zane Ray"><meta property="article:tag" content="Scala"><meta property="article:tag" content="Play"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://leihuazhe.github.io/p/fe729f21.html"},"headline":"非普通程序员","image":["http://leihuazhe.github.io/img/og_image.png"],"datePublished":"2018-12-16T16:00:00.000Z","dateModified":"2021-05-06T04:35:14.653Z","author":{"@type":"Person","name":"Zane Ray"},"description":"本章我们将讲解使用 Play 进行异步非阻塞编程情况下，如何处理异步返回结果的问题。"}</script><link rel="canonical" href="http://leihuazhe.github.io/p/fe729f21.html"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fa fa-bolt" aria-hidden="true"></i> 🎮 Play 入门与学习(三) Asynchronous results</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-17</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Play/">Play</a></span><span class="level-item">14 分钟读完 (大约2145个字)</span></div></div><div class="content"><blockquote><p>本章我们将讲解使用 Play 进行异步非阻塞编程情况下，如何处理异步返回结果的问题。</p></blockquote><h2 id="Handling-asynchronous-results"><a href="#Handling-asynchronous-results" class="headerlink" title="Handling asynchronous results"></a>Handling asynchronous results</h2><blockquote><p>从现在开始我们将进入异步 <code>http</code> 编程模块，本章将会介绍如何处理异步返回结果。</p></blockquote><h3 id="Make-controllers-asynchronous"><a href="#Make-controllers-asynchronous" class="headerlink" title="Make controllers asynchronous"></a>Make controllers asynchronous</h3><blockquote><p>使 controllers 变为异步的</p></blockquote><p>在 <code>Play Framework</code> 内部，其机制是自底向上全异步编程模式的，Play 会以异步、非阻塞的方式处理每个请求。</p><p>默认配置(<code>configuration</code>) 针对异步控制器(<code>asynchronous controllers</code>) 进行了优化。换句话说，应用程序代码应该尽量避免在控制器中进行阻塞,这样会导致控制器一直等待那个阻塞的操作。此类阻塞操作的常见示例有JDBC调用、流API、HTTP请求和长计算等。</p><p>虽然可以增加默认 <code>executionContext</code> 中线程的数量，以允许阻塞控制器处理更多的并发请求，但是遵循建议的保持控制器异步的方法可以更容易地进行扩展，并在负载下保持系统响应。</p><h3 id="Creating-non-blocking-actions"><a href="#Creating-non-blocking-actions" class="headerlink" title="Creating non-blocking actions"></a>Creating non-blocking actions</h3><blockquote><p>创建非阻塞的 <code>actions</code></p></blockquote><p>由于 <code>Play</code> 的工作方式，<code>action</code> 代码必须尽可能快，即非阻塞。那么，如果我们在还没有生成结果情形下，如何返回结果呢?答案是使用 <code>Future</code>。</p><p>A <code>Future[Result]</code> will eventually be redeemed with a value of type <code>Result</code>.</p><p>By giving a <code>Future[Result]</code> instead of a normal <code>Result</code>, we are able to quickly generate the result without blocking.</p><p>Play will then serve the result as soon as the promise is redeemed.</p><p>The web client will be blocked while waiting for the response, but nothing will be blocked on the server, and server resources can be used to serve other clients.</p><p>Using a <code>Future</code> is only half of the picture though!</p><blockquote><p>然而，使用<code>Future</code>只是这幅画的一半. (使用 Future 只是 Play 异步编程的一半)</p></blockquote><p>If you are calling out to a blocking API such as JDBC,then you still will need to have your ExecutionStage(<code>执行阶段</code>) run with a different executor, to move it off Play’s rendering thread pool.</p><p>You can do this by creating a subclass of <code>play.api.libs.concurrent.CustomExecutionContext</code>with a reference to the <a target="_blank" rel="noopener" href="https://doc.akka.io/docs/akka/2.5/dispatchers.html?language=scala">custom dispatcher</a>.</p><blockquote><p>这里意思是如果针对长时间阻塞的任务，比如JDBC，像上述方式操作，我们只不过是把当前任务的执行放到了另外一条线程中继续阻塞了而已，因此仍然是假异步。这时候，我们可以定义自定义的<code>CustomExecutionContext</code></p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> play.api.libs.concurrent.<span class="type">CustomExecutionContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请确保使用&quot;Scala Dependency Injection&quot;文档页面中列出的 custom binding 技术之一</span></span><br><span class="line"><span class="comment">//将 new context 绑定到当前 trait </span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyExecutionContext</span> <span class="keyword">extends</span> <span class="title">ExecutionContext</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyExecutionContextImpl</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">system: <span class="type">ActorSystem</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">CustomExecutionContext</span>(<span class="params">system, &quot;my.executor&quot;</span>) <span class="keyword">with</span> <span class="title">MyExecutionContext</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HomeController</span> <span class="title">@Inject</span>(<span class="params"></span>)(<span class="params">myExecutionContext: <span class="type">MyExecutionContext</span>, val controllerComponents: <span class="type">ControllerComponents</span></span>) <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">    <span class="type">Future</span> &#123;</span><br><span class="line">      <span class="comment">// Call some blocking API</span></span><br><span class="line">      <span class="type">Ok</span>(<span class="string">&quot;result of blocking call&quot;</span>)</span><br><span class="line">    &#125;(myExecutionContext)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="How-to-create-a-Future-Result"><a href="#How-to-create-a-Future-Result" class="headerlink" title="How to create a Future[Result]"></a>How to create a Future[Result]</h3><blockquote><p>要创建一个 <code>Future[Result]</code>，我们首先需要另一个<code>future</code>, 这个 <code>future</code> 会给我们返回我们需要计算的实际的结果。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futurePIValue: <span class="type">Future</span>[<span class="type">Double</span>] = computePIAsynchronously()</span><br><span class="line"><span class="keyword">val</span> futureResult: <span class="type">Future</span>[<span class="type">Result</span>] = futurePIValue.map &#123; pi =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;PI value computed: &quot;</span> + pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All of Play’s asynchronous API calls give you a <code>Future</code>. This is the case whether you are calling an external web service using the <code>play.api.libs.WS</code> API, or using Akka to schedule asynchronous tasks or to communicate with actors using <code>play.api.libs.Akka</code>.</p><blockquote><p><code>PlayFramework</code> 所有异步的 <code>API</code> 返回的结果都是一个 <code>Future</code>，无论你是通过 <code>play.api.libs.WS</code> API 调用一个外部的 <code>web</code> 服务，或者使用Akka调度异步任务，或者使用 <code>play. API .lib .Akka</code>与 <code>actor</code> 通信等等，返回都是 <code>Future</code>。</p></blockquote><p>下面是一个通过异步模式执行一段阻塞的代码，并返回一个 Future 简单的例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futureInt: <span class="type">Future</span>[<span class="type">Int</span>] = scala.concurrent.<span class="type">Future</span> &#123;</span><br><span class="line">  intensiveComputation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>It’s important to understand which thread code runs on with futures. In the two code blocks above, there is an import on Plays default execution context. This is an implicit parameter that gets passed to all methods on the future API that accept callbacks. The execution context will often be equivalent to a thread pool, though not necessarily.</p><blockquote><p>理解哪些线程代码在 Future 上运行是很重要的。在上面的两个代码块中，在 Play 默认 executionContext 上有一个导入。这是一个隐式参数，传递给 future API上所有接受回调的方法。executionContext 通常等价于线程池，但也不一定。</p></blockquote><p>You can’t magically turn synchronous IO into asynchronous by wrapping it in a <code>Future</code>. If you can’t change the application’s architecture to avoid blocking operations, at some point that operation will have to be executed, and that thread is going to block. So in addition to enclosing the operation in a <code>Future</code>, it’s necessary to configure it to run in a separate execution context that has been configured with enough threads to deal with the expected concurrency. See <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/ThreadPools">Understanding Play thread pools</a> for more information, and download the <a target="_blank" rel="noopener" href="https://playframework.com/download#examples">play example templates</a> that show database integration.</p><blockquote><p>你不能通过将代码块包装在一个 Future下来神奇地把<strong>同步IO</strong>变成异步的。如果您不能更改应用程序的体系结构以避免阻塞操作，那么在某个时刻，该操作将不得不执行，而该线程将阻塞。</p><p>因此，除了将操作封装在 <code>Future</code> 中之外，还需要将其配置为在一个单独的 <code>executionContext</code> 中运行，该上下文中已经配置了足够的线程来处理预期的并发。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.6.x/ThreadPools">了解Play线程池</a>，并下载显示数据库集成的<a target="_blank" rel="noopener" href="https://playframework.com/download#example">Play示例模板</a></p></blockquote><p>It can also be helpful to use Actors for blocking operations.</p><p>Actors provide a clean model for handling timeouts and failures, setting up blocking execution contexts, and managing any state that may be associated with the service.</p><p>Also Actors provide patterns like <code>ScatterGatherFirstCompletedRouter</code> to address simultaneous cache and database requests and allow remote execution on a cluster of backend servers. But an Actor may be overkill depending on what you need.</p><blockquote><p>对于阻塞操作场景，使用 Actors 模式是一个不错的选择。<code>Actors</code> 提供了一个简单一个简单的模型，来处理超时、故障、设置阻塞的 <code>executionContext</code> 以及与服务关联的任何状态。</p><p>Actors 还提供了像 “ScatterGatherFirstCompletedRouter” 这样的模式来处理同步缓存和数据库请求，并允许在后端服务器集群上远程执行。但是一个 actor 可能会因为你的需要而 overkill。</p></blockquote><h3 id="Returning-futures"><a href="#Returning-futures" class="headerlink" title="Returning futures"></a>Returning futures</h3><blockquote><p>返回 futures</p></blockquote><p>While we were using the <code>Action.apply</code> builder method to build actions until now, to send an asynchronous result we need to use the <code>Action.async</code> builder method:</p><p>当我们使用 <code>Action.apply</code> 时，将 <code>builder</code> 方法应用于 <code>actions</code> ，到目前为止，要发送异步结果，我们需要使用异步的 Actiton builder 方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">  <span class="keyword">val</span> futureInt = scala.concurrent.<span class="type">Future</span> &#123; intensiveComputation() &#125;</span><br><span class="line">  futureInt.map(i =&gt; <span class="type">Ok</span>(<span class="string">&quot;Got result: &quot;</span> + i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Actions-are-asynchronous-by-default"><a href="#Actions-are-asynchronous-by-default" class="headerlink" title="Actions are asynchronous by default"></a>Actions are asynchronous by default</h3><blockquote><p>默认情况下，<code>Actions</code> 是异步的。例如，在下面的控制器代码中，代码的<code>&#123;Ok(…)&#125;</code> 部分不是控制器的方法体。它是一个匿名函数，被传递给 <code>Action</code> 对象的 <code>apply</code>方法，该方法创建一个 <code>Action</code> 类型的对象。在内部，您编写的匿名函数将被调用，其结果将返回在 <code>Future</code>中。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span> </span>= <span class="type">Action</span> &#123; request =&gt;</span><br><span class="line">  <span class="type">Ok</span>(<span class="string">&quot;Got request [&quot;</span> + request + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Both <code>Action.apply</code> and <code>Action.async</code> create <code>Action</code> objects that are handled internally in the same way. There is a single kind of <code>Action</code>, which is asynchronous, and not two kinds (a synchronous one and an asynchronous one). The <code>.async</code> builder is just a facility to simplify creating actions based on APIs that return a <code>Future</code>, which makes it easier to write non-blocking code.</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><code>Action.apply</code> 和 <code>Action.async</code> 在内部都以相同的方式来处理 <code>Action</code> 对象。</p><p>有一种单独的 Action，它是异步的，但是不是a synchronous one and an asynchronous one 中的一种。</p><p><code>.async</code> builder只是一个工具，用于在创建 <code>actions</code> 时基于返回 <code>Future</code> result 的 api 的操作进行简化，这使得编写非阻塞代码更加容易。</p><h3 id="Handling-time-outs"><a href="#Handling-time-outs" class="headerlink" title="Handling time-outs"></a>Handling time-outs</h3><blockquote><p>处理超时情况</p></blockquote><p>正确处理超时，避免 <code>web</code> 浏览器阻塞并在出现问题时等待，这通常很有用。您可以使用 <code>play.api.libs.concurrent.Futures</code> 来将非阻塞的超时包装在一个 <code>Futures</code> 中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> play.api.libs.concurrent.<span class="type">Futures</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> </span>= <span class="type">Action</span>.async &#123;</span><br><span class="line">  <span class="comment">// 你可以隐式的提供一个超时参数，这题哦你歌唱可以通过controller的构造参数来达到。</span></span><br><span class="line">  intensiveComputation().withTimeout(<span class="number">1.</span>seconds).map &#123; i =&gt;</span><br><span class="line">    <span class="type">Ok</span>(<span class="string">&quot;Got result: &quot;</span> + i)</span><br><span class="line">  &#125;.recover &#123;</span><br><span class="line">    <span class="keyword">case</span> e: scala.concurrent.<span class="type">TimeoutException</span> =&gt;</span><br><span class="line">      <span class="type">InternalServerError</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>超时(Timeout)与取消(cancellation) 是不同的。对于超时而言，即使出现了超时，给定的 <code>Future</code> 仍然会完成，即使未返回已完成的值。</p></div><div class="article-licensing box"><div class="licensing-title"><p>🎮 Play 入门与学习(三) Asynchronous results</p><p><a href="http://leihuazhe.github.io/p/fe729f21.html">http://leihuazhe.github.io/p/fe729f21.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zane Ray</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-12-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala, </a><a class="link-muted" rel="tag" href="/tags/Play/">Play</a></div></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/gathering_qr.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/p/87290a79.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">🎮 Play 入门与学习(五) Dependency Injection</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/p/beeb0951.html"><span class="level-item">🎮 Play 入门与学习(二) Action Composition</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Handling-asynchronous-results"><span class="level-left"><span class="level-item">1</span><span class="level-item">Handling asynchronous results</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Make-controllers-asynchronous"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Make controllers asynchronous</span></span></a></li><li><a class="level is-mobile" href="#Creating-non-blocking-actions"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Creating non-blocking actions</span></span></a></li><li><a class="level is-mobile" href="#How-to-create-a-Future-Result"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">How to create a Future[Result]</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#注意点"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">注意点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Returning-futures"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Returning futures</span></span></a></li><li><a class="level is-mobile" href="#Actions-are-asynchronous-by-default"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Actions are asynchronous by default</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#注意"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">注意</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Handling-time-outs"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">Handling time-outs</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#注意-1"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">注意</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/p/ac45747d.html"><img src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></figure><div class="media-content"><p class="date"><time datetime="2021-05-07T02:54:53.000Z">2021-05-07</time></p><p class="title"><a href="/p/ac45747d.html">Spring 学习 [1]</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/p/a8949b93.html"><img src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></figure><div class="media-content"><p class="date"><time datetime="2019-04-01T11:43:12.000Z">2019-04-01</time></p><p class="title"><a href="/p/a8949b93.html">Scala实战 -- 对List中的部分元素进行合并操作</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-09T16:00:00.000Z">2019-01-10</time></p><p class="title"><a href="/p/6e951315.html">🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-24T16:00:00.000Z">2018-12-25</time></p><p class="title"><a href="/p/87290a79.html">🎮 Play 入门与学习(五) Dependency Injection</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-16T16:00:00.000Z">2018-12-17</time></p><p class="title"><a href="/p/fe729f21.html">🎮 Play 入门与学习(三) Asynchronous results</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Play/"><span class="tag">Play</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a><p class="is-size-7"><span>&copy; 2021 Zane Ray</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script></body></html>
<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>从示例逐渐理解Scala隐式转换 - 非普通程序员</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非普通程序员"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非普通程序员"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="隐式转换和隐式参数是 &amp;#96;Scala&amp;#96; 的两个功能强大的工具。隐式转换可以丰富现有类的功能，隐式对象是如何被自动呼出以用于执行转换或其他任务的。利用这两点，我们可以提供优雅的类库。"><meta property="og:type" content="blog"><meta property="og:title" content="从示例逐渐理解Scala隐式转换"><meta property="og:url" content="http://leihuazhe.github.io/p/2ed76eda.html"><meta property="og:site_name" content="非普通程序员"><meta property="og:description" content="隐式转换和隐式参数是 &amp;#96;Scala&amp;#96; 的两个功能强大的工具。隐式转换可以丰富现有类的功能，隐式对象是如何被自动呼出以用于执行转换或其他任务的。利用这两点，我们可以提供优雅的类库。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6393906-98ae4bd56e64e4de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800"><meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6393906-47e180d949563b81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="article:published_time" content="2018-11-17T16:00:00.000Z"><meta property="article:modified_time" content="2021-05-06T04:35:14.656Z"><meta property="article:author" content="Zane Ray"><meta property="article:tag" content="Scala"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://upload-images.jianshu.io/upload_images/6393906-98ae4bd56e64e4de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://leihuazhe.github.io/p/2ed76eda.html"},"headline":"非普通程序员","image":[],"datePublished":"2018-11-17T16:00:00.000Z","dateModified":"2021-05-06T04:35:14.656Z","author":{"@type":"Person","name":"Zane Ray"},"description":"隐式转换和隐式参数是 &#96;Scala&#96; 的两个功能强大的工具。隐式转换可以丰富现有类的功能，隐式对象是如何被自动呼出以用于执行转换或其他任务的。利用这两点，我们可以提供优雅的类库。"}</script><link rel="canonical" href="http://leihuazhe.github.io/p/2ed76eda.html"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a><a class="navbar-item" href="/tools">工具</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leihuazhe"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fa fa-bolt" aria-hidden="true"></i> 从示例逐渐理解Scala隐式转换</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-11-18</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-05-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Scala/">Scala</a></span><span class="level-item">16 分钟读完 (大约2379个字)</span></div></div><div class="content"><blockquote><p>隐式转换和隐式参数是 <code>Scala</code> 的两个功能强大的工具。隐式转换可以丰富现有类的功能，隐式对象是如何被自动呼出以用于执行转换或其他任务的。利用这两点，我们可以提供优雅的类库。</p></blockquote><p>本文将通过几个示例代码来整体学习一下 <code>Scala</code> 隐式转换的四个特性和运用。它们分别是 隐式函数运用、隐式类扩展运用、隐式参数、类型类(<code>Type class</code>)运用。</p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><blockquote><p>implicit conversion function：指的是那种以 <code>implicit</code> 关键字声明的带有单个参数的函数。这样的函数将被自动应用，将值从一种类型转换为另一种类型。</p></blockquote><h3 id="隐式函数-implicit-def"><a href="#隐式函数-implicit-def" class="headerlink" title="隐式函数 implicit def"></a>隐式函数 implicit def</h3><p>定义一个 <code>case class</code> 类 <code>Multiply</code>，并定义一个方法 <code>multiply</code> ，接收一个当前对象，并将值相乘后返回。<br>定义隐式转换函数 <code>int2Multiply</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span>(<span class="params">m: <span class="type">Int</span>, n: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(other: <span class="type">Multiply</span>): <span class="type">Multiply</span> = &#123;</span><br><span class="line">        <span class="type">Multiply</span>(other.m * m, other.n * n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyImplicit</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义隐式转换函数，参数单个，将 int 隐式转换为 Multiply 对象</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类 <code>MultiplyMain</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//导入隐式转换方法（局部引用可以避免不想要的隐式转换发生）</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> x: <span class="type">Multiply</span> = <span class="number">3.</span>multiply(<span class="type">Multiply</span>(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(x.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行程序结果如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结果为：Multiply(6,2)</span><br><span class="line">&#x2F;&#x2F;计算过程，3 隐式转换为 Multiply(3, 2)</span><br><span class="line">3 &#x3D;&gt; Multiply(3, 2)</span><br><span class="line">&#x2F;&#x2F;调用multiply计算</span><br><span class="line">Multiply(3, 2).multiply(Multiply(2, 1)) &#x3D;Multiply( 3*2 , 2*1 )</span><br></pre></td></tr></table></figure>如果我们提供多个隐式转换函数<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyImplicit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">2</span>)</span><br><span class="line">  <span class="comment">//提供第二个隐式转换函数</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">int2Multiply2</span></span>(n: <span class="type">Int</span>): <span class="type">Multiply</span> = <span class="type">Multiply</span>(n, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在 <code>Main</code> 中，我们可以通过两种方式进行指定具体使用哪个隐式转换函数。<br>比如我们选择使用 <code>int2Multiply</code>的隐式转换<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultiplyMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//方法1: 排除 int2Multiply2 方法，引入其余所有的方法</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>.&#123;int2Multiply2 ⇒ _, _&#125;</span><br><span class="line"> <span class="comment">// 方法2: 精确引入</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.one.<span class="type">MultiplyImplicit</span>.int2Multiply</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> x: <span class="type">Multiply</span> = <span class="number">3.</span>multiply(<span class="type">Multiply</span>(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(x.toString)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式类，丰富现有类库功能"><a href="#隐式类，丰富现有类库功能" class="headerlink" title="隐式类，丰富现有类库功能"></a>隐式类，丰富现有类库功能</h3><blockquote><p>你是否希望某个类拥有新的方法，而此方法该类并没有提供，那么隐式转换可以丰富这个类，给它提供更多的方法</p></blockquote></li></ul><p>例如数据库连接类 <code>Connection</code>, 我们希望给它新增一个 <code>executeUpdate</code> 方法来对数据进行修改，例子如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.maple.implic.two</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.<span class="type">Connection</span></span><br><span class="line"><span class="keyword">import</span> scala.language.implicitConversions</span><br><span class="line"><span class="comment">//隐式类，Rich表示对Connection的增强类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichConnection</span>(<span class="params">conn: <span class="type">Connection</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//定义的新方法 executeUpdate，对数据操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">executeUpdate</span></span>(sql: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    conn.prepareStatement(sql).executeUpdate()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供隐式转换 func 来将原有类型转换为Rich 类型</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichConnection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">executeUpdate</span></span>(connection: <span class="type">Connection</span>) = <span class="keyword">new</span> <span class="type">RichConnection</span>(connection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConnectionMain</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引入隐式转换 func</span></span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.two.<span class="type">RichConnection</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//定义 dataSource</span></span><br><span class="line">    <span class="keyword">val</span> ds: <span class="type">DataSource</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> ds = <span class="keyword">new</span> <span class="type">MysqlDataSource</span></span><br><span class="line">      ds.setURL(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/maple?useUnicode=true&amp;characterEncoding=utf8&quot;</span>)</span><br><span class="line">      ds.setUser(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">      ds.setPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">      ds</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取 conn</span></span><br><span class="line">    <span class="keyword">val</span> connection = ds.getConnection</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    connection.executeUpdate(<span class="string">&quot;UPDATE t_user SET name = &#x27;maple&#x27; WHERE id = 1&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面通过定义一个 <code>RichConnection</code> 我们可以增强现有类 <code>Connection</code> 的功能。这样一来，通过 <code>connection</code> 对数据库进行增删改查，可以简化大量代码。</p><h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><blockquote><p>函数或方法可以带有一个标记为 <code>implicit</code> 的参数列表。在这种情况下，编译器将会查找默认值，提供给本次函数调用。</p></blockquote><h3 id="利用隐式参数进行隐式转换"><a href="#利用隐式参数进行隐式转换" class="headerlink" title="利用隐式参数进行隐式转换"></a>利用隐式参数进行隐式转换</h3><blockquote><p>隐式的函数参数也可以被用作隐式转换。如果我们定义一个泛型函数</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">larger</span></span>[<span class="type">T</span>](x: <span class="type">T</span>, y: <span class="type">T</span>) = <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br></pre></td></tr></table></figure><h2><a href="#" class="headerlink"></a><img src="https://upload-images.jianshu.io/upload_images/6393906-98ae4bd56e64e4de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="ex.png"></h2><p>关于隐式参数的另一件事是，它们可能最常用于提供有关在早期参数列表中显式提到的类型的信息，类似于Haskell的类型类。作为示例，请考虑清单21.2中所示的maxListUpBound函数，该函数返回传递列表的最大元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxListUpBound</span></span>[<span class="type">T</span> &lt;: <span class="type">Ordered</span>[<span class="type">T</span>]](elements: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">    elements <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;empty list!&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">      <span class="keyword">case</span> x :: rest =&gt;</span><br><span class="line">        <span class="keyword">val</span> maxRest = maxListUpBound(rest)</span><br><span class="line">        <span class="keyword">if</span> (x &gt; maxRest) x</span><br><span class="line">        <span class="keyword">else</span> maxRest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>maxListUpBound</code> 表示传入一个 <code>List</code>，然后返回 <code>list</code> 中最大的一个元素。功能简单，但是用法十分限制，该List中的成员必须是 <code>Ordered[T]</code> 的子类，否则就会报错。比如我们运行如下例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParameterMain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">import</span> com.maple.implic.three.<span class="type">ImplicitParameter</span>._</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = maxListUpBound(<span class="type">List</span>[<span class="type">Integer</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    println(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们运行 <code>main</code> 函数时，编译器会报如下错。意思是 <code>Int</code> 不是 <code>Ordered[T]</code> 子类，因此无法使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error:(49, 18) inferred type arguments [Int] do not conform to method maxListUpBound&#39;s type parameter bounds [T &lt;: Ordered[T]]</span><br><span class="line">    val result &#x3D; maxListUpBound(List[Int](1, 2, 3))</span><br><span class="line">Error:(49, 42) type mismatch;</span><br><span class="line"> found   : List[Int]</span><br><span class="line"> required: List[T]</span><br><span class="line">    val result &#x3D; maxListUpBound(List[Int](1, 2, 3))</span><br></pre></td></tr></table></figure><h4 id="使用隐式参数优化"><a href="#使用隐式参数优化" class="headerlink" title="使用隐式参数优化"></a>使用隐式参数优化</h4><blockquote><p>如果让 <code>maxListUpBound</code> 更通用，我们需要分离这个函数，增加一个参数，来将 <code>T</code> 转换为 <code>Ordered[T]</code>，使用隐式参数 <code>implicit orders: T ⇒ Ordered[T]</code>来做到这一点。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxListUpBound2</span></span>[<span class="type">T</span>](elements: <span class="type">List</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> orders: <span class="type">T</span> ⇒ <span class="type">Ordered</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">    elements <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>() =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;empty list!&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">      <span class="keyword">case</span> x :: rest =&gt;</span><br><span class="line">        <span class="keyword">val</span> maxRest = maxListUpBound2(rest)</span><br><span class="line">        <span class="keyword">if</span> (x &gt; maxRest) x</span><br><span class="line">        <span class="keyword">else</span> maxRest</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.three.<span class="type">ImplicitParameter</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = maxListUpBound2(<span class="type">List</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为3，并没有报错。这其中编译器是将 <code>Int</code> 转换为了 <code>Ordered[Int]</code></p><h3 id="类型类-type-class"><a href="#类型类-type-class" class="headerlink" title="类型类(type class)"></a>类型类(type class)</h3><blockquote><p>让某个类拥有某个算法，我们无需修改这个类，提供一个隐式转换即可。这种做法相对于面向对象的继承扩展来的更灵活。</p></blockquote><p>看下面两个例子，<code>Ordering</code> 是 <code>Scala</code> 提供的类型类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Implicits</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedExt</span>[<span class="type">T</span>: <span class="type">Ordering</span>](<span class="params">v: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">between</span></span>(min: <span class="type">T</span>, max: <span class="type">T</span>) = &#123;</span><br><span class="line">        <span class="keyword">val</span> ordering = implicitly[<span class="type">Ordering</span>[<span class="type">T</span>]]</span><br><span class="line">        ordering.lteq(min, v) &amp;&amp; ordering.lteq(v, max)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedExt2</span>[<span class="type">T</span>](<span class="params">v: <span class="type">T</span></span>)(<span class="params">implicit ordering: <span class="type">Ordering</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">between2</span></span>(min: <span class="type">T</span>, max: <span class="type">T</span>) = &#123;</span><br><span class="line">      ordering.lteq(min, v) &amp;&amp; ordering.lteq(v, max)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用，上面两种写法都可以达到相同的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.<span class="type">Implicits</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> isBetween = <span class="number">10.</span>between(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> isBetween2 = <span class="number">30.</span>between2(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">    println(isBetween)</span><br><span class="line">    println(isBetween2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Ordering</code> 这样的特质(<code>trait</code>) 被称为类型类(<code>type class</code>，源自 <code>Haskell</code>) 。类型类定义了某种行为，任何类型都可以通过提供相应的行为来加入这个类。这个类是因为共用的目的而组合在一起的类型。</p><h3 id="自定义类型类"><a href="#自定义类型类" class="headerlink" title="自定义类型类"></a>自定义类型类</h3><blockquote><p><code>Scala</code> 标准类库提供了不少类型类。比如 <code>Equiv</code>、<code>Numeric</code>、<code>Fractional</code>、<code>Hashing</code>、<code>IsTraverableOne</code>、<code>IsTraverableLike</code> 等。我们通过自定义一个类型 <code>CustomOperation</code> 来更深入的学习。</p></blockquote><p><strong>定义特质 <code>CustomOperation</code></strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CustomOperation</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 加操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="comment">// 乘操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在伴生对象中给 String 类型扩展基于 <code>CustomOperation</code> 的功能。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CustomOperation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">StringCustomOperation</span> <span class="keyword">extends</span> <span class="title">CustomOperation</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + <span class="string">&quot;*&quot;</span> + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义隐式类,对 `String` 进行增强</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomImplicitClass</span>[<span class="type">T</span>: <span class="type">CustomOperation</span>](<span class="params">v: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">      <span class="comment">//从冥界召唤的CustomOperation[T]隐式类型。</span></span><br><span class="line">      <span class="keyword">val</span> custom = implicitly[<span class="type">CustomOperation</span>[<span class="type">T</span>]]</span><br><span class="line">      custom.multiply(v, x) + <span class="string">&quot;+&quot;</span> + custom.multiply(v, y).toString</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//另外一种写法</span></span><br><span class="line">  <span class="comment">/* def multiply(x: T, y: T)(implicit custom: CustomOperation[T]): String = &#123;</span></span><br><span class="line"><span class="comment">      custom.multiply(v, x) + custom.multiply(v, y).toString</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">String</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> custom = implicitly[<span class="type">CustomOperation</span>[<span class="type">T</span>]]</span><br><span class="line">      custom.plus(v, x) + custom.plus(v, y).toString</span><br><span class="line">      <span class="comment">//      custom.plus(x, y)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类 <code>CustomOperationMain</code>:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.typeclass.<span class="type">CustomOperation</span>._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CustomOperationMain</span> </span>&#123;</span><br><span class="line"> <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">&quot;maple&quot;</span>.plus(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    println(str)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maple&lt;maple&gt;</span><br><span class="line"><span class="comment">//隐式转换的运算过程为</span></span><br><span class="line"> custom.plus(v, x) + custom.plus(v, y).toString</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x + y</span><br></pre></td></tr></table></figure><p>如果想要对 <code>Double</code> 支持上述操作，同样定义如下类型类扩展即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">DoubleCustomOperation</span> <span class="keyword">extends</span> <span class="title">CustomOperation</span>[<span class="type">Double</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>): <span class="type">Double</span> = x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>): <span class="type">Double</span> = x * y</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.maple.implic.typeclass.<span class="type">CustomOperation</span>._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> doubleValue = <span class="number">5.5</span>.multiply(<span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    println(doubleValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为 <code>11.0+16.5</code><br>计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">custom.multiply(v, x) + &quot;+&quot; + custom.multiply(v, y).toString</span><br><span class="line">override def multiply(x: Double, y: Double): Double &#x3D; x * y</span><br><span class="line">&#x2F;&#x2F;相乘后字符串相加</span><br><span class="line">5.5*2.0 + 5.5*3.0 &#x3D;&#x3D;&#x3D;&gt;  11.0+16.5</span><br></pre></td></tr></table></figure><h3 id="Type-Class-总结"><a href="#Type-Class-总结" class="headerlink" title="Type Class 总结"></a>Type Class 总结</h3><p><code>TypeClass</code> 将 <strong>行为定义</strong> 与 <strong>具有行为的对象</strong> 分离。有点类似于 <code>AOP</code>，但是比 <code>AOP</code> 简洁很多。同时, 在函数式编程中，通常将 <strong>数据</strong> 与 <strong>行为</strong> 相分离，甚至是数据与行为按需绑定，已达到更为高级的组合特性。</p><h3 id="隐式转换触发时机"><a href="#隐式转换触发时机" class="headerlink" title="隐式转换触发时机"></a>隐式转换触发时机</h3><p><code>Scala</code> 会考虑如下的隐式转换函数：</p><ul><li>1.位于源或目标类型的伴生对象中的隐式函数或隐式类。</li><li>2.位于当前作用域中可以以单个标识符指代的隐式函数或隐式类。<br>隐式转换可以显示加上，来进行代码调试。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍 <code>Scala</code> 隐式转换的几种用法，通过详细的例子加深读者对隐式转换的理解。关于隐式转换的触发时机以及编译器优化顺序等，将不在本篇文章详细介绍，可以关注笔者后续文章。</p><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>最后推荐一下本人微信公众号，欢迎大家关注。</p><p><img src="https://upload-images.jianshu.io/upload_images/6393906-47e180d949563b81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></div><div class="article-licensing box"><div class="licensing-title"><p>从示例逐渐理解Scala隐式转换</p><p><a href="http://leihuazhe.github.io/p/2ed76eda.html">http://leihuazhe.github.io/p/2ed76eda.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zane Ray</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-11-18</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Scala/">Scala</a></div></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/gathering_qr.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/p/da1f3173.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用 Docker 容器方式搭建 Zookeeper 集群</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/p/b2d7d4cd.html"><span class="level-item">从示例逐渐理解Scala尾递归</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget"><link href="/music/APlayer.min.css"><div id="aplayer" style="margin:0 auto"></div><script src="/music/APlayer.min.js"></script><script src="/music/APlayer_Music.js"></script></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#隐式转换"><span class="level-left"><span class="level-item">1</span><span class="level-item">隐式转换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#隐式函数-implicit-def"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">隐式函数 implicit def</span></span></a></li><li><a class="level is-mobile" href="#隐式类，丰富现有类库功能"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">隐式类，丰富现有类库功能</span></span></a></li><li><a class="level is-mobile" href="#隐式参数"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">隐式参数</span></span></a></li><li><a class="level is-mobile" href="#利用隐式参数进行隐式转换"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">利用隐式参数进行隐式转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">2</span><span class="level-item"></span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#使用隐式参数优化"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">使用隐式参数优化</span></span></a></li></ul><li><a class="level is-mobile" href="#类型类-type-class"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">类型类(type class)</span></span></a></li><li><a class="level is-mobile" href="#自定义类型类"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">自定义类型类</span></span></a></li><li><a class="level is-mobile" href="#Type-Class-总结"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Type Class 总结</span></span></a></li><li><a class="level is-mobile" href="#隐式转换触发时机"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">隐式转换触发时机</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#推荐"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">推荐</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/p/ac45747d.html"><img src="/gallery/covers/56_1.jpg" alt="Spring 学习 [1]"></a></figure><div class="media-content"><p class="date"><time datetime="2021-05-07T02:54:53.000Z">2021-05-07</time></p><p class="title"><a href="/p/ac45747d.html">Spring 学习 [1]</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/p/a8949b93.html"><img src="/gallery/covers/56_1.jpg" alt="Scala实战 -- 对List中的部分元素进行合并操作"></a></figure><div class="media-content"><p class="date"><time datetime="2019-04-01T11:43:12.000Z">2019-04-01</time></p><p class="title"><a href="/p/a8949b93.html">Scala实战 -- 对List中的部分元素进行合并操作</a></p><p class="categories"><a href="/categories/Scala/">Scala</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-09T16:00:00.000Z">2019-01-10</time></p><p class="title"><a href="/p/6e951315.html">🎮 Play 入门与学习(五) 2.5.x 版本自定义 Action</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-24T16:00:00.000Z">2018-12-25</time></p><p class="title"><a href="/p/87290a79.html">🎮 Play 入门与学习(五) Dependency Injection</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-12-16T16:00:00.000Z">2018-12-17</time></p><p class="title"><a href="/p/fe729f21.html">🎮 Play 入门与学习(三) Asynchronous results</a></p><p class="categories"><a href="/categories/Play/">Play</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Play/"><span class="tag">Play</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scala/"><span class="tag">Scala</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Zookeeper/"><span class="tag">Zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/maple.png" alt="非普通程序员" height="28"></a><p class="is-size-7"><span>&copy; 2021 Zane Ray</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>